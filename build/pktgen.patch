diff --git a/app/meson.build b/app/meson.build
index eb0682f..67b0cbe 100644
--- a/app/meson.build
+++ b/app/meson.build
@@ -48,7 +48,7 @@ deps += [cc.find_library('rte_net_ice', dirs: [dpdk_libs_path], required: false)
 deps += [cc.find_library('rte_bus_vdev', dirs: [dpdk_libs_path], required: false)]
 
 deps += [dependency('threads')]
-deps += [dependency('numa', required: true)]
+deps += [dependency('numa', required: false)]
 deps += [dependency('pcap', required: true)]
 deps += [cc.find_library('dl', required: false)]
 deps += [cc.find_library('m', required: false)]
diff --git a/app/pktgen-port-cfg.c b/app/pktgen-port-cfg.c
index 1e4042a..894b612 100644
--- a/app/pktgen-port-cfg.c
+++ b/app/pktgen-port-cfg.c
@@ -180,13 +180,33 @@ allocate_port_info(uint16_t pid)
         goto leave;
     }
 
-    pinfo->rx_pkts = rte_calloc_socket("RxMbufs", MAX_PKT_RX_BURST, sizeof(struct rte_mbuf *),
-                                       RTE_CACHE_LINE_SIZE, sid);
-    pinfo->tx_pkts = rte_calloc_socket("TxMbufs", MAX_PKT_TX_BURST, sizeof(struct rte_mbuf *),
-                                       RTE_CACHE_LINE_SIZE, sid);
-    if (pinfo->rx_pkts == NULL || pinfo->tx_pkts == NULL) {
-        pktgen_log_error("Cannot allocate RX/TX burst for port %u", pid);
-        goto leave;
+    /* Allocate RX packet buffers for each queue */
+    for (int q = 0; q < 16; q++) {
+        pinfo->rx_pkts[q] = rte_calloc_socket("RxMbufs", MAX_PKT_RX_BURST, sizeof(struct rte_mbuf *),
+                                               RTE_CACHE_LINE_SIZE, sid);
+        if (pinfo->rx_pkts[q] == NULL) {
+            pktgen_log_error("Cannot allocate RX burst for port %u queue %d", pid, q);
+            /* Free previously allocated queues */
+            for (int i = 0; i < q; i++)
+                rte_free(pinfo->rx_pkts[i]);
+            goto leave;
+        }
+    }
+
+    /* Allocate TX burst for each queue */
+    for (int q = 0; q < 16; q++) {
+        pinfo->tx_pkts[q] = rte_calloc_socket("TxMbufs", MAX_PKT_TX_BURST, sizeof(struct rte_mbuf *),
+                                           RTE_CACHE_LINE_SIZE, sid);
+        if (pinfo->tx_pkts[q] == NULL) {
+            pktgen_log_error("Cannot allocate TX burst for port %u queue %d", pid, q);
+            /* Free all RX queues */
+            for (int i = 0; i < 16; i++)
+                rte_free(pinfo->rx_pkts[i]);
+            /* Free allocated TX queues */
+            for (int i = 0; i < q; i++)
+                rte_free(pinfo->tx_pkts[i]);
+            goto leave;
+        }
     }
 
     if (l2p_set_port_pinfo(pid, pinfo)) {
@@ -227,8 +247,10 @@ allocate_port_info(uint16_t pid)
     return pinfo;
 leave:
     if (pinfo) {
-        rte_free(pinfo->rx_pkts);
-        rte_free(pinfo->tx_pkts);
+        for (int q = 0; q < 16; q++) {
+            rte_free(pinfo->rx_pkts[q]);
+            rte_free(pinfo->tx_pkts[q]);
+        }
         rte_free(pinfo);
         l2p_set_port_pinfo(pid, NULL);
     }
diff --git a/app/pktgen-port-cfg.h b/app/pktgen-port-cfg.h
index d2b54a6..ef6f7d8 100644
--- a/app/pktgen-port-cfg.h
+++ b/app/pktgen-port-cfg.h
@@ -133,8 +133,8 @@ typedef struct {
 typedef struct port_info_s {
     struct rte_eth_dev_info dev_info; /**< Device information */
     struct rte_eth_conf conf;         /**< Configuration settings */
-    struct rte_mbuf **rx_pkts;        /**< Array of pointers to packet buffers for RX */
-    struct rte_mbuf **tx_pkts;        /**< Array of pointers to packet buffers for TX */
+    struct rte_mbuf **rx_pkts[16];    /**< Array of pointers to packet buffers for RX per queue */
+    struct rte_mbuf **tx_pkts[16];    /**< Array of pointers to packet buffers for TX per queue */
 
     rte_atomic64_t port_flags;       /**< Special send flags for ARP and other */
     rte_atomic64_t transmit_count;   /**< Packets to transmit loaded into current_tx_count */
diff --git a/app/pktgen.c b/app/pktgen.c
index 627034d..3ca8b1b 100644
--- a/app/pktgen.c
+++ b/app/pktgen.c
@@ -18,6 +18,9 @@ TXlib */
 #include <rte_arp.h>
 #include <rte_cycles.h>
 #include <rte_hexdump.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
 
 #include "pktgen.h"
 #include "pktgen-gre.h"
@@ -38,11 +41,85 @@ TXlib */
 #include <pthread.h>
 #include <sched.h>
 
+/* Debug logging control - set to 1 to enable debug logs, 0 to disable */
+#define PKTGEN_DEBUG_LOGS 1  /* Change this to 1 for debug mode, 0 for release */
+
+#if PKTGEN_DEBUG_LOGS
+#define PKTGEN_DEBUG_LOG(fmt, args...) do { fprintf(stderr, fmt "\n", ##args); fflush(stderr); } while(0)
+#else
+#define PKTGEN_DEBUG_LOG(fmt, args...) do {} while(0)
+#endif
+
 #define FAST_TX_MODE 0
 
 /* Allocated the pktgen structure for global use */
 pktgen_t pktgen;
 
+/* Workqueue setup synchronization */
+static volatile uint16_t workq_setup_done[RTE_MAX_ETHPORTS][2]; /* [port][WORKQ_RX/WORKQ_TX] */
+
+/* Analyze and log packet details */
+static void
+analyze_packet(struct rte_mbuf *pkt, unsigned int lcore_id, uint16_t port_id, const char *direction)
+{
+#if PKTGEN_DEBUG_LOGS
+    struct rte_ether_hdr *eth_hdr;
+    struct rte_ipv4_hdr *ipv4_hdr;
+    struct rte_tcp_hdr *tcp_hdr;
+    struct rte_udp_hdr *udp_hdr;
+    uint32_t src_ip, dst_ip;
+    uint16_t src_port = 0, dst_port = 0;
+    uint8_t proto;
+    char src_ip_str[INET_ADDRSTRLEN];
+    char dst_ip_str[INET_ADDRSTRLEN];
+
+    eth_hdr = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
+    
+    if (RTE_ETH_IS_IPV4_HDR(pkt->packet_type)) {
+        ipv4_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);
+        src_ip = rte_be_to_cpu_32(ipv4_hdr->src_addr);
+        dst_ip = rte_be_to_cpu_32(ipv4_hdr->dst_addr);
+        proto = ipv4_hdr->next_proto_id;
+
+        /* Convert IPs to string format */
+        struct in_addr addr;
+        addr.s_addr = rte_cpu_to_be_32(src_ip);
+        inet_ntop(AF_INET, &addr, src_ip_str, INET_ADDRSTRLEN);
+        addr.s_addr = rte_cpu_to_be_32(dst_ip);
+        inet_ntop(AF_INET, &addr, dst_ip_str, INET_ADDRSTRLEN);
+
+        /* Extract port numbers for TCP/UDP */
+        if (proto == IPPROTO_TCP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*tcp_hdr)) {
+            tcp_hdr = (struct rte_tcp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+            src_port = rte_be_to_cpu_16(tcp_hdr->src_port);
+            dst_port = rte_be_to_cpu_16(tcp_hdr->dst_port);
+            PKTGEN_DEBUG_LOG("PKTGEN: [%s] lcore=%u port=%u TCP %s:%u -> %s:%u (RSS=0x%08x)",
+                direction, lcore_id, port_id, src_ip_str, src_port, dst_ip_str, dst_port, pkt->hash.rss);
+        } else if (proto == IPPROTO_UDP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*udp_hdr)) {
+            udp_hdr = (struct rte_udp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+            src_port = rte_be_to_cpu_16(udp_hdr->src_port);
+            dst_port = rte_be_to_cpu_16(udp_hdr->dst_port);
+            PKTGEN_DEBUG_LOG("PKTGEN: [%s] lcore=%u port=%u UDP %s:%u -> %s:%u (RSS=0x%08x)",
+                direction, lcore_id, port_id, src_ip_str, src_port, dst_ip_str, dst_port, pkt->hash.rss);
+        } else {
+            PKTGEN_DEBUG_LOG("PKTGEN: [%s] lcore=%u port=%u IP proto=%u %s -> %s (RSS=0x%08x)",
+                direction, lcore_id, port_id, proto, src_ip_str, dst_ip_str, pkt->hash.rss);
+        }
+    } else if (RTE_ETH_IS_IPV6_HDR(pkt->packet_type)) {
+        PKTGEN_DEBUG_LOG("PKTGEN: [%s] lcore=%u port=%u IPv6 packet", direction, lcore_id, port_id);
+    } else {
+        PKTGEN_DEBUG_LOG("PKTGEN: [%s] lcore=%u port=%u Non-IP packet (type=0x%04x)",
+            direction, lcore_id, port_id, rte_be_to_cpu_16(eth_hdr->ether_type));
+    }
+#else
+    /* Suppress unused parameter warnings when debug is disabled */
+    (void)pkt;
+    (void)lcore_id;
+    (void)port_id;
+    (void)direction;
+#endif
+}
+
 double
 next_poisson_time(double rateParameter)
 {
@@ -280,11 +357,17 @@ tx_send_packets(port_info_t *pinfo, uint16_t qid, struct rte_mbuf **pkts, uint16
 {
     if (nb_pkts) {
         uint16_t sent, to_send = nb_pkts;
+        unsigned int lcore_id = rte_lcore_id();
 
         pinfo->queue_stats.q_opackets[qid] += nb_pkts;
         for (int i = 0; i < nb_pkts; i++)
             pinfo->queue_stats.q_obytes[qid] += rte_pktmbuf_pkt_len(pkts[i]);
 
+        /* Analyze TX packets for debugging */
+        for (int i = 0; i < nb_pkts; i++) {
+            analyze_packet(pkts[i], lcore_id, pinfo->pid, "TX");
+        }
+
         if (pktgen_tst_port_flags(pinfo, SEND_RANDOM_PKTS))
             pktgen_rnd_bits_apply(pinfo, pkts, to_send, NULL);
 
@@ -973,7 +1056,7 @@ void
 pktgen_send_pkts(port_info_t *pinfo, uint16_t qid, struct rte_mempool *mp)
 {
     uint64_t txCnt;
-    struct rte_mbuf **pkts = pinfo->tx_pkts;
+    struct rte_mbuf **pkts = pinfo->tx_pkts[qid];
 
     if (!pktgen_tst_port_flags(pinfo, SEND_FOREVER)) {
         txCnt = pkt_atomic64_tx_count(&pinfo->current_tx_count, pinfo->tx_burst);
@@ -1027,7 +1110,7 @@ fast_main_transmit(port_info_t *pinfo, uint16_t qid)
 {
     if (pktgen_tst_port_flags(pinfo, SENDING_PACKETS)) {
         struct rte_mempool *mp = l2p_get_tx_mp(pinfo->pid);
-        struct rte_mbuf **pkts = pinfo->tx_pkts;
+        struct rte_mbuf **pkts = pinfo->tx_pkts[qid];
 
         /* Use mempool routines instead of pktmbuf to make sure the mbufs is not altered */
         if (rte_mempool_get_bulk(mp, (void **)pkts, pinfo->tx_burst) == 0) {
@@ -1057,7 +1140,7 @@ static inline void
 pktgen_main_receive(port_info_t *pinfo, uint16_t qid)
 {
     uint16_t nb_rx, nb_pkts = pinfo->rx_burst, pid;
-    struct rte_mbuf **pkts = pinfo->rx_pkts;
+    struct rte_mbuf **pkts = pinfo->rx_pkts[qid];
 
     if (unlikely(pktgen_tst_port_flags(pinfo, STOP_RECEIVING_PACKETS)))
         return;
@@ -1066,12 +1149,19 @@ pktgen_main_receive(port_info_t *pinfo, uint16_t qid)
 
     /* Read packets from RX queues and free the mbufs */
     if (likely((nb_rx = rte_eth_rx_burst(pid, qid, pkts, nb_pkts)) > 0)) {
+        // printf("Core %d received %u packets\n", rte_lcore_id(), nb_rx);
         struct rte_eth_stats *qstats = &pinfo->queue_stats;
+        unsigned int lcore_id = rte_lcore_id();
 
         qstats->q_ipackets[qid] += nb_rx;
         for (int i = 0; i < nb_rx; i++)
             qstats->q_ibytes[qid] += rte_pktmbuf_pkt_len(pkts[i]);
 
+        /* Analyze RX packets for debugging */
+        for (int i = 0; i < nb_rx; i++) {
+            analyze_packet(pkts[i], lcore_id, pid, "RX");
+        }
+
         pktgen_tstamp_check(pinfo, pkts, nb_rx);
 
         /* classify the packets for the counters */
@@ -1122,12 +1212,52 @@ pktgen_tx_workq_setup(uint16_t pid)
 }
 
 static int
-pktgen_workq_setup(workq_type_t wqt, uint16_t pid, void *arg)
+pktgen_workq_setup_once(workq_type_t wqt, uint16_t pid, void *arg)
 {
-    if (workq_port_arg_set(pid, arg))
-        return -1;
+    uint16_t wqt_idx = (wqt == WORKQ_RX) ? 0 : 1;
+
+    /* Check if this workqueue type for this port is already set up */
+    if (__atomic_compare_exchange_n(&workq_setup_done[pid][wqt_idx],
+                                    &(uint16_t){0}, 1,
+                                    false, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) {
+        /* This core won the race - perform the actual setup */
+        printf("Core %d: Setting up %s workqueue for port %d\n",
+               rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+
+        if (workq_port_arg_set(pid, arg)) {
+            __atomic_store_n(&workq_setup_done[pid][wqt_idx], 0, __ATOMIC_RELEASE);
+            return -1;
+        }
+
+        int ret = (wqt == WORKQ_RX) ? pktgen_rx_workq_setup(pid) : pktgen_tx_workq_setup(pid);
+        if (ret != 0) {
+            /* Reset on failure */
+            __atomic_store_n(&workq_setup_done[pid][wqt_idx], 0, __ATOMIC_RELEASE);
+            return ret;
+        }
+
+        printf("Core %d: Successfully set up %s workqueue for port %d\n",
+               rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+    } else {
+        /* Another core is setting it up - wait for completion */
+        printf("Core %d: Waiting for %s workqueue setup for port %d\n",
+               rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+
+        while (__atomic_load_n(&workq_setup_done[pid][wqt_idx], __ATOMIC_ACQUIRE) != 1) {
+            rte_pause();
+        }
 
-    return (wqt == WORKQ_RX) ? pktgen_rx_workq_setup(pid) : pktgen_tx_workq_setup(pid);
+        printf("Core %d: %s workqueue for port %d is ready\n",
+               rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+    }
+
+    return 0;
+}
+
+static int
+pktgen_workq_setup(workq_type_t wqt, uint16_t pid, void *arg)
+{
+    return pktgen_workq_setup_once(wqt, pid, arg);
 }
 
 /**
@@ -1280,7 +1410,7 @@ pktgen_main_rx_loop(void)
 
     pinfo  = l2p_get_pinfo_by_lcore(lid);
     rx_qid = l2p_get_rxqid(lid);
-
+    printf("DEBUG: RX Core Info: lid %3d, rx_qid %2d, cpu_id %2d, pinfo %p\n", lid, rx_qid, sched_getcpu(), pinfo);
     printf("RX lid %3d, pid %2d, qid %2d, Mempool %-16s @ %p\n", lid, pinfo->pid, rx_qid,
            l2p_get_rx_mp(pinfo->pid)->name, l2p_get_rx_mp(pinfo->pid));
 
diff --git a/scripts/measure-rx-tx-rate.lua b/scripts/measure-rx-tx-rate.lua
new file mode 100644
index 0000000..351bbc2
--- /dev/null
+++ b/scripts/measure-rx-tx-rate.lua
@@ -0,0 +1,133 @@
+-- RX/TX Rate Measurement Script (based on measure-tx-rate.lua)
+
+-- Since we run from Pktgen-DPDK directory, just add current directory to path
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = tonumber(os.getenv("PKTGEN_DURATION")) or 10
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Configuration (same as measure-tx-rate.lua)
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 100)  -- Maximum rate
+pktgen.set(port, "count", 0)   -- Continuous transmission
+
+-- Set MAC addresses (same as measure-tx-rate.lua)
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+
+-- Set IP addresses (same as measure-tx-rate.lua)
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+-- Set up Range configuration for TCP (same as measure-tx-rate.lua)
+pktgen.range.ip_proto("all", "tcp")
+
+-- Set MAC addresses in range (same as measure-tx-rate.lua)
+pktgen.range.src_mac(port, "start", "08:c0:eb:b6:cd:5d")
+pktgen.range.dst_mac(port, "start", "08:c0:eb:b6:e8:05")
+
+-- Set source IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.src_ip(port, "start", "10.0.1.7")
+pktgen.range.src_ip(port, "inc", "0.0.0.0")
+pktgen.range.src_ip(port, "min", "10.0.1.7")
+pktgen.range.src_ip(port, "max", "10.0.1.7")
+
+-- Set destination IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.dst_ip(port, "start", "10.0.1.8")
+pktgen.range.dst_ip(port, "inc", "0.0.0.0")
+pktgen.range.dst_ip(port, "min", "10.0.1.8")
+pktgen.range.dst_ip(port, "max", "10.0.1.8")
+
+-- Set source TCP port (20000-20255, increment by 1, same as measure-tx-rate.lua)
+pktgen.range.src_port(port, "start", 20000)
+pktgen.range.src_port(port, "inc", 1)
+pktgen.range.src_port(port, "min", 10000)
+pktgen.range.src_port(port, "max", 60000)
+
+-- Set destination TCP port (fixed at 20000, same as measure-tx-rate.lua)
+pktgen.range.dst_port(port, "start", 20000)
+pktgen.range.dst_port(port, "inc", 0)
+pktgen.range.dst_port(port, "min", 20000)
+pktgen.range.dst_port(port, "max", 20000)
+
+-- Set TTL (same as measure-tx-rate.lua)
+pktgen.range.ttl(port, "start", 64)
+pktgen.range.ttl(port, "inc", 0)
+pktgen.range.ttl(port, "min", 64)
+pktgen.range.ttl(port, "max", 64)
+
+-- Enable range mode (same as measure-tx-rate.lua)
+pktgen.set_range(port, "on")
+
+pktgen.delay(100)
+
+print("=== Starting RX/TX Rate Measurement ===")
+print("Configuration:")
+print("  Port: " .. port)
+print("  Packet Size: 64 bytes")
+print("  Protocol: TCP")
+print("  Test Duration: " .. sleeptime .. " seconds")
+print("  Rate: 100% (maximum)")
+print("  Range Mode: Enabled (Port 10000-60000)")
+print("==========================================")
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+-- Record initial statistics
+pktgen.delay(1000)  -- Wait 1 second for transmission to stabilize
+local initial_stats = pktgen.portStats("all", "port")[port]
+local initial_tx_pkts = initial_stats.opackets
+local initial_rx_pkts = initial_stats.ipackets
+
+-- Wait for test duration
+pktgen.delay(sleeptime * 1000)
+
+-- Stop transmission and get final statistics
+pktgen.stop(port)
+local final_stats = pktgen.portStats("all", "port")[port]
+local final_tx_pkts = final_stats.opackets
+local final_rx_pkts = final_stats.ipackets
+
+-- Calculate average rates in Mpps
+local total_tx_packets = final_tx_pkts - initial_tx_pkts
+local total_rx_packets = final_rx_pkts - initial_rx_pkts
+local avg_tx_rate_mpps = total_tx_packets / (sleeptime * 1000000)
+local avg_rx_rate_mpps = total_rx_packets / (sleeptime * 1000000)
+
+-- Calculate packet loss percentage
+local packet_loss_pct = 0
+if total_tx_packets > 0 then
+    packet_loss_pct = (1 - total_rx_packets/total_tx_packets) * 100
+end
+
+-- Display results
+print("\n=== RX/TX Rate Measurement Results ===")
+print("Test Duration: " .. sleeptime .. " seconds")
+print("Packet Size: 64 bytes")
+print("Protocol: TCP with ranges")
+print("Total Packets Transmitted: " .. total_tx_packets)
+print("Total Packets Received: " .. total_rx_packets)
+print("Average TX Rate: " .. string.format("%.3f", avg_tx_rate_mpps) .. " Mpps")
+print("Average RX Rate: " .. string.format("%.3f", avg_rx_rate_mpps) .. " Mpps")
+print("Packet Loss: " .. string.format("%.2f", packet_loss_pct) .. "%")
+print("=====================================")
+
+-- Print results in parseable format for automation
+print("RESULT_TX_RATE_MPPS:" .. string.format("%.3f", avg_tx_rate_mpps))
+print("RESULT_RX_RATE_MPPS:" .. string.format("%.3f", avg_rx_rate_mpps))
+print("RESULT_TX_PACKETS:" .. total_tx_packets)
+print("RESULT_RX_PACKETS:" .. total_rx_packets)
+
+-- Auto quit to prevent interactive mode - use os.exit instead of pktgen.quit()
+print("Auto-quitting pktgen...")
+pktgen.delay(1000)  -- Wait 1 second before quitting
+os.exit(0)
diff --git a/scripts/measure-tx-rate.lua b/scripts/measure-tx-rate.lua
new file mode 100644
index 0000000..d86e02a
--- /dev/null
+++ b/scripts/measure-tx-rate.lua
@@ -0,0 +1,99 @@
+-- TX Rate Measurement Script
+
+-- Since we run from Pktgen-DPDK directory, just add current directory to path
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = tonumber(os.getenv("PKTGEN_DURATION")) or 10
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Configuration
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 100)  -- Maximum rate
+pktgen.set(port, "count", 0)   -- Continuous transmission
+
+-- Set MAC addresses
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+
+-- Set IP addresses
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+-- Set up Range configuration for TCP
+pktgen.range.ip_proto("all", "tcp")
+
+-- Set MAC addresses in range
+pktgen.range.src_mac(port, "start", "08:c0:eb:b6:cd:5d")
+pktgen.range.dst_mac(port, "start", "08:c0:eb:b6:e8:05")
+
+-- Set source IP (fixed)
+pktgen.range.src_ip(port, "start", "10.0.1.7")
+pktgen.range.src_ip(port, "inc", "0.0.0.0")
+pktgen.range.src_ip(port, "min", "10.0.1.7")
+pktgen.range.src_ip(port, "max", "10.0.1.7")
+
+-- Set destination IP (fixed)
+pktgen.range.dst_ip(port, "start", "10.0.1.8")
+pktgen.range.dst_ip(port, "inc", "0.0.0.0")
+pktgen.range.dst_ip(port, "min", "10.0.1.8")
+pktgen.range.dst_ip(port, "max", "10.0.1.8")
+
+-- Set source TCP port (20000-20255, increment by 1)
+pktgen.range.src_port(port, "start", 20000)
+pktgen.range.src_port(port, "inc", 1)
+pktgen.range.src_port(port, "min", 20000)
+pktgen.range.src_port(port, "max", 20255)
+
+-- Set destination TCP port (fixed at 20000)
+pktgen.range.dst_port(port, "start", 20000)
+pktgen.range.dst_port(port, "inc", 0)
+pktgen.range.dst_port(port, "min", 20000)
+pktgen.range.dst_port(port, "max", 20000)
+
+-- Set TTL
+pktgen.range.ttl(port, "start", 64)
+pktgen.range.ttl(port, "inc", 0)
+pktgen.range.ttl(port, "min", 64)
+pktgen.range.ttl(port, "max", 64)
+
+-- Enable range mode
+pktgen.set_range(port, "on")
+
+pktgen.delay(100)
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+-- Record initial statistics
+pktgen.delay(1000)  -- Wait 1 second for transmission to stabilize
+local initial_stats = pktgen.portStats("all", "port")[port]
+local initial_tx_pkts = initial_stats.opackets
+
+-- Wait for test duration
+pktgen.delay(sleeptime * 1000)
+
+-- Stop transmission and get final statistics
+pktgen.stop(port)
+local final_stats = pktgen.portStats("all", "port")[port]
+local final_tx_pkts = final_stats.opackets
+
+-- Calculate average TX rate in Mpps
+local total_packets = final_tx_pkts - initial_tx_pkts
+local avg_tx_rate_mpps = total_packets / (sleeptime * 1000000)
+
+-- Display results
+print("\n=== TX Rate Measurement Results ===")
+print("Test Duration: " .. sleeptime .. " seconds")
+print("Packet Size: 64 bytes")
+print("Protocol: TCP")
+print("Total Packets Transmitted: " .. total_packets)
+print("Average TX Rate: " .. string.format("%.3f", avg_tx_rate_mpps) .. " Mpps")
+print("=====================================\n")
\ No newline at end of file
diff --git a/scripts/simple-test.lua b/scripts/simple-test.lua
new file mode 100644
index 0000000..e2a02c8
--- /dev/null
+++ b/scripts/simple-test.lua
@@ -0,0 +1,16 @@
+-- Simple test script to check if lua execution works
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+
+print("Simple test script loaded successfully")
+print("Stopping and clearing port " .. port)
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+print("Test completed successfully")
diff --git a/scripts/simple-tx-rate.lua b/scripts/simple-tx-rate.lua
new file mode 100644
index 0000000..86cde97
--- /dev/null
+++ b/scripts/simple-tx-rate.lua
@@ -0,0 +1,55 @@
+-- Simplified TX Rate Measurement Script
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = 3  -- Reduced to 3 seconds for testing
+
+print("Starting simplified TX rate measurement...")
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Basic configuration
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 100)  -- Maximum rate
+pktgen.set(port, "count", 0)   -- Continuous transmission
+
+-- Simple MAC and IP addresses (no range)
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+pktgen.delay(100)
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+-- Record initial statistics
+pktgen.delay(1000)  -- Wait 1 second for transmission to stabilize
+local initial_stats = pktgen.portStats("all", "port")[port]
+local initial_tx_pkts = initial_stats.opackets
+
+-- Wait for test duration
+pktgen.delay(sleeptime * 1000)
+
+-- Stop transmission and get final statistics
+pktgen.stop(port)
+local final_stats = pktgen.portStats("all", "port")[port]
+local final_tx_pkts = final_stats.opackets
+
+-- Calculate average TX rate in Mpps
+local total_packets = final_tx_pkts - initial_tx_pkts
+local avg_tx_rate_mpps = total_packets / (sleeptime * 1000000)
+
+-- Display results
+print("\n=== Simplified TX Rate Results ===")
+print("Test Duration: " .. sleeptime .. " seconds")
+print("Total Packets Transmitted: " .. total_packets)
+print("Average TX Rate: " .. string.format("%.3f", avg_tx_rate_mpps) .. " Mpps")
+print("====================================\n")
diff --git a/scripts/simple-tx-test.lua b/scripts/simple-tx-test.lua
new file mode 100644
index 0000000..dbffeaf
--- /dev/null
+++ b/scripts/simple-tx-test.lua
@@ -0,0 +1,76 @@
+-- RX/TX Rate Measurement Script (based on measure-tx-rate.lua)
+
+-- Since we run from Pktgen-DPDK directory, just add current directory to path
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = tonumber(os.getenv("PKTGEN_DURATION")) or 10
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Configuration (same as measure-tx-rate.lua)
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 0)  -- Maximum rate
+pktgen.set(port, "count", 10)   -- Continuous transmission
+
+-- Set MAC addresses (same as measure-tx-rate.lua)
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+
+-- Set IP addresses (same as measure-tx-rate.lua)
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+-- Set up Range configuration for TCP (same as measure-tx-rate.lua)
+pktgen.range.ip_proto("all", "tcp")
+
+-- Set MAC addresses in range (same as measure-tx-rate.lua)
+pktgen.range.src_mac(port, "start", "08:c0:eb:b6:cd:5d")
+pktgen.range.dst_mac(port, "start", "08:c0:eb:b6:e8:05")
+
+-- Set source IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.src_ip(port, "start", "10.0.1.7")
+pktgen.range.src_ip(port, "inc", "0.0.0.0")
+pktgen.range.src_ip(port, "min", "10.0.1.7")
+pktgen.range.src_ip(port, "max", "10.0.1.7")
+
+-- Set destination IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.dst_ip(port, "start", "10.0.1.8")
+pktgen.range.dst_ip(port, "inc", "0.0.0.0")
+pktgen.range.dst_ip(port, "min", "10.0.1.8")
+pktgen.range.dst_ip(port, "max", "10.0.1.8")
+
+-- Set source TCP port (20000-20255, increment by 1, same as measure-tx-rate.lua)
+pktgen.range.src_port(port, "start", 20000)
+pktgen.range.src_port(port, "inc", 1)
+pktgen.range.src_port(port, "min", 10000)
+pktgen.range.src_port(port, "max", 60000)
+
+-- Set destination TCP port (fixed at 20000, same as measure-tx-rate.lua)
+pktgen.range.dst_port(port, "start", 20000)
+pktgen.range.dst_port(port, "inc", 0)
+pktgen.range.dst_port(port, "min", 20000)
+pktgen.range.dst_port(port, "max", 20000)
+
+-- Set TTL (same as measure-tx-rate.lua)
+pktgen.range.ttl(port, "start", 64)
+pktgen.range.ttl(port, "inc", 0)
+pktgen.range.ttl(port, "min", 64)
+pktgen.range.ttl(port, "max", 64)
+
+-- Enable range mode (same as measure-tx-rate.lua)
+pktgen.set_range(port, "on")
+
+pktgen.delay(100)
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+pktgen.delay(1000)  -- Wait 1 second before quitting
+os.exit(0)
