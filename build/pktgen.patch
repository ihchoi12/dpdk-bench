diff --git a/app/lpktgenlib.c b/app/lpktgenlib.c
index 37136c7..2f45de7 100644
--- a/app/lpktgenlib.c
+++ b/app/lpktgenlib.c
@@ -53,6 +53,13 @@ pktgen_exit(lua_State *L __rte_unused)
     return 0;
 }
 
+static int
+pktgen_print_stats_summary(lua_State *L __rte_unused)
+{
+    print_pktgen_stats_summary();
+    return 0;
+}
+
 static inline double
 cycles_to_us(uint64_t cycles)
 {
@@ -3994,6 +4001,7 @@ static const luaL_Reg pktgenlib_range[] = {
 
 static const luaL_Reg pktgenlib[] = {
     {"quit", pktgen_exit},
+    {"print_stats", pktgen_print_stats_summary},
     {"set", pktgen_set}, /* Set a number of options */
 
     {"start", pktgen_start}, /* Start a set of ports sending packets */
diff --git a/app/meson.build b/app/meson.build
index eb0682f..67b0cbe 100644
--- a/app/meson.build
+++ b/app/meson.build
@@ -48,7 +48,7 @@ deps += [cc.find_library('rte_net_ice', dirs: [dpdk_libs_path], required: false)
 deps += [cc.find_library('rte_bus_vdev', dirs: [dpdk_libs_path], required: false)]
 
 deps += [dependency('threads')]
-deps += [dependency('numa', required: true)]
+deps += [dependency('numa', required: false)]
 deps += [dependency('pcap', required: true)]
 deps += [cc.find_library('dl', required: false)]
 deps += [cc.find_library('m', required: false)]
diff --git a/app/pktgen-cmds.c b/app/pktgen-cmds.c
index 086ac5a..95eaa6d 100644
--- a/app/pktgen-cmds.c
+++ b/app/pktgen-cmds.c
@@ -3895,6 +3895,9 @@ pktgen_set_vxlan_seq(port_info_t *pinfo, uint32_t seqnum, uint32_t flag, uint32_
 void
 pktgen_quit(void)
 {
+    /* Print packet statistics summary before quitting */
+    print_pktgen_stats_summary();
+
     cli_quit();
 }
 
diff --git a/app/pktgen-main.c b/app/pktgen-main.c
index b9ea903..7eb1230 100644
--- a/app/pktgen-main.c
+++ b/app/pktgen-main.c
@@ -327,6 +327,9 @@ sig_handler(int v __rte_unused)
 
     free(strings);
 
+    /* Print packet statistics summary before cleanup */
+    print_pktgen_stats_summary();
+
     cli_destroy();
     scrn_destroy();
 
diff --git a/app/pktgen-packet-loss.h b/app/pktgen-packet-loss.h
new file mode 100644
index 0000000..e69de29
diff --git a/app/pktgen-port-cfg.c b/app/pktgen-port-cfg.c
index 1e4042a..894b612 100644
--- a/app/pktgen-port-cfg.c
+++ b/app/pktgen-port-cfg.c
@@ -180,13 +180,33 @@ allocate_port_info(uint16_t pid)
         goto leave;
     }
 
-    pinfo->rx_pkts = rte_calloc_socket("RxMbufs", MAX_PKT_RX_BURST, sizeof(struct rte_mbuf *),
-                                       RTE_CACHE_LINE_SIZE, sid);
-    pinfo->tx_pkts = rte_calloc_socket("TxMbufs", MAX_PKT_TX_BURST, sizeof(struct rte_mbuf *),
-                                       RTE_CACHE_LINE_SIZE, sid);
-    if (pinfo->rx_pkts == NULL || pinfo->tx_pkts == NULL) {
-        pktgen_log_error("Cannot allocate RX/TX burst for port %u", pid);
-        goto leave;
+    /* Allocate RX packet buffers for each queue */
+    for (int q = 0; q < 16; q++) {
+        pinfo->rx_pkts[q] = rte_calloc_socket("RxMbufs", MAX_PKT_RX_BURST, sizeof(struct rte_mbuf *),
+                                               RTE_CACHE_LINE_SIZE, sid);
+        if (pinfo->rx_pkts[q] == NULL) {
+            pktgen_log_error("Cannot allocate RX burst for port %u queue %d", pid, q);
+            /* Free previously allocated queues */
+            for (int i = 0; i < q; i++)
+                rte_free(pinfo->rx_pkts[i]);
+            goto leave;
+        }
+    }
+
+    /* Allocate TX burst for each queue */
+    for (int q = 0; q < 16; q++) {
+        pinfo->tx_pkts[q] = rte_calloc_socket("TxMbufs", MAX_PKT_TX_BURST, sizeof(struct rte_mbuf *),
+                                           RTE_CACHE_LINE_SIZE, sid);
+        if (pinfo->tx_pkts[q] == NULL) {
+            pktgen_log_error("Cannot allocate TX burst for port %u queue %d", pid, q);
+            /* Free all RX queues */
+            for (int i = 0; i < 16; i++)
+                rte_free(pinfo->rx_pkts[i]);
+            /* Free allocated TX queues */
+            for (int i = 0; i < q; i++)
+                rte_free(pinfo->tx_pkts[i]);
+            goto leave;
+        }
     }
 
     if (l2p_set_port_pinfo(pid, pinfo)) {
@@ -227,8 +247,10 @@ allocate_port_info(uint16_t pid)
     return pinfo;
 leave:
     if (pinfo) {
-        rte_free(pinfo->rx_pkts);
-        rte_free(pinfo->tx_pkts);
+        for (int q = 0; q < 16; q++) {
+            rte_free(pinfo->rx_pkts[q]);
+            rte_free(pinfo->tx_pkts[q]);
+        }
         rte_free(pinfo);
         l2p_set_port_pinfo(pid, NULL);
     }
diff --git a/app/pktgen-port-cfg.h b/app/pktgen-port-cfg.h
index d2b54a6..ef6f7d8 100644
--- a/app/pktgen-port-cfg.h
+++ b/app/pktgen-port-cfg.h
@@ -133,8 +133,8 @@ typedef struct {
 typedef struct port_info_s {
     struct rte_eth_dev_info dev_info; /**< Device information */
     struct rte_eth_conf conf;         /**< Configuration settings */
-    struct rte_mbuf **rx_pkts;        /**< Array of pointers to packet buffers for RX */
-    struct rte_mbuf **tx_pkts;        /**< Array of pointers to packet buffers for TX */
+    struct rte_mbuf **rx_pkts[16];    /**< Array of pointers to packet buffers for RX per queue */
+    struct rte_mbuf **tx_pkts[16];    /**< Array of pointers to packet buffers for TX per queue */
 
     rte_atomic64_t port_flags;       /**< Special send flags for ARP and other */
     rte_atomic64_t transmit_count;   /**< Packets to transmit loaded into current_tx_count */
diff --git a/app/pktgen.c b/app/pktgen.c
index 627034d..ab6a845 100644
--- a/app/pktgen.c
+++ b/app/pktgen.c
@@ -18,6 +18,9 @@ TXlib */
 #include <rte_arp.h>
 #include <rte_cycles.h>
 #include <rte_hexdump.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
 
 #include "pktgen.h"
 #include "pktgen-gre.h"
@@ -38,11 +41,109 @@ TXlib */
 #include <pthread.h>
 #include <sched.h>
 
+/* Debug logging control - set to 1 to enable debug logs, 0 to disable */
+#define PKTGEN_DEBUG_LOGS 0  /* Change this to 1 for debug mode, 0 for release */
+
+#if PKTGEN_DEBUG_LOGS
+#define PKTGEN_DEBUG_LOG(fmt, args...) do { fprintf(stderr, fmt "\n", ##args); fflush(stderr); } while(0)
+#else
+#define PKTGEN_DEBUG_LOG(fmt, args...) do {} while(0)
+#endif
+
 #define FAST_TX_MODE 0
 
+/* Core statistics structure for summary reporting */
+typedef struct {
+    uint64_t rx_packets;
+    uint64_t tx_packets;
+    uint64_t start_time;
+    uint16_t port_id;
+} lcore_stats_t;
+
+/* Global array to store per-lcore statistics */
+static lcore_stats_t lcore_stats[RTE_MAX_LCORE];
+
+/* Function to print packet statistics summary */
+void print_pktgen_stats_summary(void);
+
+/* Function to print NIC hardware statistics */
+void print_nic_hw_stats(uint16_t port_id);
+void print_all_nic_hw_stats(void);
+
 /* Allocated the pktgen structure for global use */
 pktgen_t pktgen;
 
+/* Workqueue setup synchronization */
+static volatile uint16_t workq_setup_done[RTE_MAX_ETHPORTS][2]; /* [port][WORKQ_RX/WORKQ_TX] */
+
+#if PKTGEN_DEBUG_LOGS
+/* Analyze and log packet details */
+static void
+analyze_packet(struct rte_mbuf *pkt, unsigned int lcore_id, uint16_t port_id, const char *direction)
+{
+    struct rte_ether_hdr *eth_hdr;
+    struct rte_ipv4_hdr *ipv4_hdr;
+    struct rte_tcp_hdr *tcp_hdr;
+    struct rte_udp_hdr *udp_hdr;
+    uint32_t src_ip, dst_ip;
+    uint16_t src_port = 0, dst_port = 0;
+    uint8_t proto;
+    char src_ip_str[INET_ADDRSTRLEN];
+    char dst_ip_str[INET_ADDRSTRLEN];
+    char src_mac_str[18];
+    char dst_mac_str[18];
+
+    eth_hdr = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
+    uint16_t ether_type = rte_be_to_cpu_16(eth_hdr->ether_type);
+    
+    /* Convert MAC addresses to string format */
+    snprintf(src_mac_str, sizeof(src_mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+             eth_hdr->src_addr.addr_bytes[0], eth_hdr->src_addr.addr_bytes[1],
+             eth_hdr->src_addr.addr_bytes[2], eth_hdr->src_addr.addr_bytes[3],
+             eth_hdr->src_addr.addr_bytes[4], eth_hdr->src_addr.addr_bytes[5]);
+    snprintf(dst_mac_str, sizeof(dst_mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+             eth_hdr->dst_addr.addr_bytes[0], eth_hdr->dst_addr.addr_bytes[1],
+             eth_hdr->dst_addr.addr_bytes[2], eth_hdr->dst_addr.addr_bytes[3],
+             eth_hdr->dst_addr.addr_bytes[4], eth_hdr->dst_addr.addr_bytes[5]);
+    
+    if (ether_type == RTE_ETHER_TYPE_IPV4) {
+        ipv4_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);
+        src_ip = rte_be_to_cpu_32(ipv4_hdr->src_addr);
+        dst_ip = rte_be_to_cpu_32(ipv4_hdr->dst_addr);
+        proto = ipv4_hdr->next_proto_id;
+
+        /* Convert IPs to string format */
+        struct in_addr addr;
+        addr.s_addr = rte_cpu_to_be_32(src_ip);
+        inet_ntop(AF_INET, &addr, src_ip_str, INET_ADDRSTRLEN);
+        addr.s_addr = rte_cpu_to_be_32(dst_ip);
+        inet_ntop(AF_INET, &addr, dst_ip_str, INET_ADDRSTRLEN);
+
+        /* Extract port numbers for TCP/UDP */
+        if (proto == IPPROTO_TCP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*tcp_hdr)) {
+            tcp_hdr = (struct rte_tcp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+            src_port = rte_be_to_cpu_16(tcp_hdr->src_port);
+            dst_port = rte_be_to_cpu_16(tcp_hdr->dst_port);
+            PKTGEN_DEBUG_LOG("PKTGEN: [%s] lcore=%u port=%u TCP %s:%u -> %s:%u (MAC %s -> %s) (RSS=0x%08x)",
+                direction, lcore_id, port_id, src_ip_str, src_port, dst_ip_str, dst_port, src_mac_str, dst_mac_str, pkt->hash.rss);
+        } else if (proto == IPPROTO_UDP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*udp_hdr)) {
+            udp_hdr = (struct rte_udp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+            src_port = rte_be_to_cpu_16(udp_hdr->src_port);
+            dst_port = rte_be_to_cpu_16(udp_hdr->dst_port);
+            PKTGEN_DEBUG_LOG("PKTGEN: [%s] lcore=%u port=%u UDP %s:%u -> %s:%u (MAC %s -> %s) (RSS=0x%08x)",
+                direction, lcore_id, port_id, src_ip_str, src_port, dst_ip_str, dst_port, src_mac_str, dst_mac_str, pkt->hash.rss);
+        } else {
+            PKTGEN_DEBUG_LOG("PKTGEN: [%s] lcore=%u port=%u IP proto=%u %s -> %s (MAC %s -> %s) (RSS=0x%08x)",
+                direction, lcore_id, port_id, proto, src_ip_str, dst_ip_str, src_mac_str, dst_mac_str, pkt->hash.rss);
+        }
+    } else if (ether_type == RTE_ETHER_TYPE_IPV6) {
+        PKTGEN_DEBUG_LOG("PKTGEN: [%s] lcore=%u port=%u IPv6 packet (MAC %s -> %s)", direction, lcore_id, port_id, src_mac_str, dst_mac_str);
+    } else {
+        PKTGEN_DEBUG_LOG("PKTGEN: [%s] lcore=%u port=%u Non-IP packet (type=0x%04x) (MAC %s -> %s)",
+            direction, lcore_id, port_id, ether_type, src_mac_str, dst_mac_str);
+    }
+}
+#endif
 double
 next_poisson_time(double rateParameter)
 {
@@ -280,11 +381,23 @@ tx_send_packets(port_info_t *pinfo, uint16_t qid, struct rte_mbuf **pkts, uint16
 {
     if (nb_pkts) {
         uint16_t sent, to_send = nb_pkts;
+        unsigned int lcore_id = rte_lcore_id();
+
+        /* Update per-lcore statistics */
+        lcore_stats[lcore_id].tx_packets += nb_pkts;
+        lcore_stats[lcore_id].port_id = pinfo->pid;
+        if (lcore_stats[lcore_id].start_time == 0)
+            lcore_stats[lcore_id].start_time = rte_rdtsc();
 
         pinfo->queue_stats.q_opackets[qid] += nb_pkts;
         for (int i = 0; i < nb_pkts; i++)
             pinfo->queue_stats.q_obytes[qid] += rte_pktmbuf_pkt_len(pkts[i]);
-
+#if PKTGEN_DEBUG_LOGS
+        /* Analyze TX packets for debugging */
+        for (int i = 0; i < nb_pkts; i++) {
+            analyze_packet(pkts[i], lcore_id, pinfo->pid, "TX");
+        }
+#endif
         if (pktgen_tst_port_flags(pinfo, SEND_RANDOM_PKTS))
             pktgen_rnd_bits_apply(pinfo, pkts, to_send, NULL);
 
@@ -973,7 +1086,7 @@ void
 pktgen_send_pkts(port_info_t *pinfo, uint16_t qid, struct rte_mempool *mp)
 {
     uint64_t txCnt;
-    struct rte_mbuf **pkts = pinfo->tx_pkts;
+    struct rte_mbuf **pkts = pinfo->tx_pkts[qid];
 
     if (!pktgen_tst_port_flags(pinfo, SEND_FOREVER)) {
         txCnt = pkt_atomic64_tx_count(&pinfo->current_tx_count, pinfo->tx_burst);
@@ -1027,7 +1140,7 @@ fast_main_transmit(port_info_t *pinfo, uint16_t qid)
 {
     if (pktgen_tst_port_flags(pinfo, SENDING_PACKETS)) {
         struct rte_mempool *mp = l2p_get_tx_mp(pinfo->pid);
-        struct rte_mbuf **pkts = pinfo->tx_pkts;
+        struct rte_mbuf **pkts = pinfo->tx_pkts[qid];
 
         /* Use mempool routines instead of pktmbuf to make sure the mbufs is not altered */
         if (rte_mempool_get_bulk(mp, (void **)pkts, pinfo->tx_burst) == 0) {
@@ -1057,7 +1170,7 @@ static inline void
 pktgen_main_receive(port_info_t *pinfo, uint16_t qid)
 {
     uint16_t nb_rx, nb_pkts = pinfo->rx_burst, pid;
-    struct rte_mbuf **pkts = pinfo->rx_pkts;
+    struct rte_mbuf **pkts = pinfo->rx_pkts[qid];
 
     if (unlikely(pktgen_tst_port_flags(pinfo, STOP_RECEIVING_PACKETS)))
         return;
@@ -1066,12 +1179,25 @@ pktgen_main_receive(port_info_t *pinfo, uint16_t qid)
 
     /* Read packets from RX queues and free the mbufs */
     if (likely((nb_rx = rte_eth_rx_burst(pid, qid, pkts, nb_pkts)) > 0)) {
+        // printf("Core %d received %u packets\n", rte_lcore_id(), nb_rx);
         struct rte_eth_stats *qstats = &pinfo->queue_stats;
+        unsigned int lcore_id = rte_lcore_id();
+
+        /* Update per-lcore statistics */
+        lcore_stats[lcore_id].rx_packets += nb_rx;
+        lcore_stats[lcore_id].port_id = pid;
+        if (lcore_stats[lcore_id].start_time == 0)
+            lcore_stats[lcore_id].start_time = rte_rdtsc();
 
         qstats->q_ipackets[qid] += nb_rx;
         for (int i = 0; i < nb_rx; i++)
             qstats->q_ibytes[qid] += rte_pktmbuf_pkt_len(pkts[i]);
-
+#if PKTGEN_DEBUG_LOGS
+        /* Analyze RX packets for debugging */
+        for (int i = 0; i < nb_rx; i++) {
+            analyze_packet(pkts[i], lcore_id, pid, "RX");
+        }
+#endif
         pktgen_tstamp_check(pinfo, pkts, nb_rx);
 
         /* classify the packets for the counters */
@@ -1122,12 +1248,52 @@ pktgen_tx_workq_setup(uint16_t pid)
 }
 
 static int
-pktgen_workq_setup(workq_type_t wqt, uint16_t pid, void *arg)
+pktgen_workq_setup_once(workq_type_t wqt, uint16_t pid, void *arg)
 {
-    if (workq_port_arg_set(pid, arg))
-        return -1;
+    uint16_t wqt_idx = (wqt == WORKQ_RX) ? 0 : 1;
+
+    /* Check if this workqueue type for this port is already set up */
+    if (__atomic_compare_exchange_n(&workq_setup_done[pid][wqt_idx],
+                                    &(uint16_t){0}, 1,
+                                    false, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) {
+        /* This core won the race - perform the actual setup */
+        printf("Core %d: Setting up %s workqueue for port %d\n",
+               rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+
+        if (workq_port_arg_set(pid, arg)) {
+            __atomic_store_n(&workq_setup_done[pid][wqt_idx], 0, __ATOMIC_RELEASE);
+            return -1;
+        }
+
+        int ret = (wqt == WORKQ_RX) ? pktgen_rx_workq_setup(pid) : pktgen_tx_workq_setup(pid);
+        if (ret != 0) {
+            /* Reset on failure */
+            __atomic_store_n(&workq_setup_done[pid][wqt_idx], 0, __ATOMIC_RELEASE);
+            return ret;
+        }
+
+        printf("Core %d: Successfully set up %s workqueue for port %d\n",
+               rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+    } else {
+        /* Another core is setting it up - wait for completion */
+        printf("Core %d: Waiting for %s workqueue setup for port %d\n",
+               rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+
+        while (__atomic_load_n(&workq_setup_done[pid][wqt_idx], __ATOMIC_ACQUIRE) != 1) {
+            rte_pause();
+        }
+
+        printf("Core %d: %s workqueue for port %d is ready\n",
+               rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+    }
+
+    return 0;
+}
 
-    return (wqt == WORKQ_RX) ? pktgen_rx_workq_setup(pid) : pktgen_tx_workq_setup(pid);
+static int
+pktgen_workq_setup(workq_type_t wqt, uint16_t pid, void *arg)
+{
+    return pktgen_workq_setup_once(wqt, pid, arg);
 }
 
 /**
@@ -1280,7 +1446,7 @@ pktgen_main_rx_loop(void)
 
     pinfo  = l2p_get_pinfo_by_lcore(lid);
     rx_qid = l2p_get_rxqid(lid);
-
+    printf("DEBUG: RX Core Info: lid %3d, rx_qid %2d, cpu_id %2d, pinfo %p\n", lid, rx_qid, sched_getcpu(), pinfo);
     printf("RX lid %3d, pid %2d, qid %2d, Mempool %-16s @ %p\n", lid, pinfo->pid, rx_qid,
            l2p_get_rx_mp(pinfo->pid)->name, l2p_get_rx_mp(pinfo->pid));
 
@@ -1479,3 +1645,237 @@ pktgen_timer_setup(void)
     CPU_SET(rte_get_main_lcore(), cpuset);
     pthread_setaffinity_np(tid, sizeof(cpuset), cpuset);
 }
+
+/**
+ * print_pktgen_stats_summary - Print per-lcore packet statistics summary
+ *
+ * DESCRIPTION
+ * Print a summary table of RX/TX packet statistics for each lcore,
+ * similar to L3FWD's statistics output format.
+ *
+ * RETURNS: N/A
+ */
+void
+print_pktgen_stats_summary(void)
+{
+    unsigned int lcore_id;
+    uint64_t total_rx = 0, total_tx = 0;
+    uint64_t current_time = rte_rdtsc();
+    uint64_t tsc_hz = rte_get_tsc_hz();
+    
+    printf("\n");
+    printf("=====================================\n");
+    printf("PKTGEN Packet Statistics Summary\n");
+    printf("=====================================\n");
+    printf("%-8s %-12s %-12s %-10s %-10s %-8s\n", 
+        "Lcore", "RX Packets", "TX Packets", "RX Rate", "TX Rate", "Diff%");
+    printf("%-8s %-12s %-12s %-10s %-10s %-8s\n", 
+        "-----", "----------", "----------", "--------", "--------", "------");
+
+    RTE_LCORE_FOREACH(lcore_id) {
+        if (lcore_stats[lcore_id].start_time > 0) {
+            uint64_t duration = current_time - lcore_stats[lcore_id].start_time;
+            double elapsed_sec = (double)duration / tsc_hz;
+            double rx_rate = elapsed_sec > 0 ? lcore_stats[lcore_id].rx_packets / elapsed_sec : 0;
+            double tx_rate = elapsed_sec > 0 ? lcore_stats[lcore_id].tx_packets / elapsed_sec : 0;
+            
+            /* Calculate proper rate for individual lcore */
+            double rate = 0.0;
+            uint64_t rx = lcore_stats[lcore_id].rx_packets;
+            uint64_t tx = lcore_stats[lcore_id].tx_packets;
+            
+            if (rx > 0) {
+                if (tx > rx) {
+                    /* Amplification case: more TX than RX */
+                    rate = (double)(tx - rx) * 100.0 / rx;
+                } else {
+                    /* Loss case: less TX than RX */
+                    rate = (double)(rx - tx) * 100.0 / rx;
+                }
+            } else if (tx > 0) {
+                /* Only TX, no RX - show as 0% since no reference */
+                rate = 0.0;
+            }
+            
+            printf("%-8u %-12" PRIu64 " %-12" PRIu64 " %-10.1f %-10.1f %-8.1f\n",
+                lcore_id,
+                lcore_stats[lcore_id].rx_packets,
+                lcore_stats[lcore_id].tx_packets,
+                rx_rate / 1000000.0,  /* Convert to Mpps */
+                tx_rate / 1000000.0,
+                rate);
+            
+            total_rx += lcore_stats[lcore_id].rx_packets;
+            total_tx += lcore_stats[lcore_id].tx_packets;
+        }
+    }
+    
+    /* Calculate loss/amplification rate properly */
+    int64_t difference = (int64_t)total_tx - (int64_t)total_rx;  /* TX - RX */
+    double rate = 0.0;
+    const char *rate_type = "";
+    
+    if (total_rx > 0) {
+        if (difference > 0) {
+            /* More TX than RX - amplification */
+            rate = (double)difference * 100.0 / total_rx;
+            rate_type = "amplification";
+        } else if (difference < 0) {
+            /* More RX than TX - loss */
+            rate = (double)(-difference) * 100.0 / total_rx;
+            rate_type = "loss";
+        } else {
+            /* Perfect match */
+            rate = 0.0;
+            rate_type = "perfect";
+        }
+    }
+    
+    printf("%-8s %-12s %-12s %-10s %-10s %-8s\n", 
+        "-----", "----------", "----------", "--------", "--------", "------");
+    printf("%-8s %-12" PRIu64 " %-12" PRIu64 " %-10s %-10s %-8.1f\n", 
+        "Total", total_rx, total_tx, "", "", rate);
+    printf("=====================================\n");
+    printf("ANALYSIS: RX/TX difference = %+" PRId64 " packets (%.1f%% %s)\n", 
+        difference, rate, rate_type);
+    printf("=====================================\n");
+    
+    /* Print NIC hardware statistics */
+    print_all_nic_hw_stats();
+}
+
+/**
+ * print_nic_hw_stats - Print NIC hardware statistics for a specific port
+ *
+ * DESCRIPTION
+ * Print detailed NIC hardware statistics including drops, errors, and buffer states
+ *
+ * RETURNS: N/A
+ */
+void
+print_nic_hw_stats(uint16_t port_id)
+{
+    struct rte_eth_stats eth_stats;
+    struct rte_eth_xstat *xstats = NULL;
+    struct rte_eth_xstat_name *xstat_names = NULL;
+    int cnt_xstats, ret, i;
+
+    printf("\n=== NIC Hardware Statistics (Port %u) ===\n", port_id);
+    
+    /* Get basic ethernet statistics */
+    ret = rte_eth_stats_get(port_id, &eth_stats);
+    if (ret == 0) {
+        printf("Hardware RX Packets:     %"PRIu64"\n", eth_stats.ipackets);
+        printf("Hardware TX Packets:     %"PRIu64"\n", eth_stats.opackets);
+        printf("Hardware RX Bytes:       %"PRIu64"\n", eth_stats.ibytes);
+        printf("Hardware TX Bytes:       %"PRIu64"\n", eth_stats.obytes);
+        printf("Hardware RX Errors:      %"PRIu64"\n", eth_stats.ierrors);
+        printf("Hardware TX Errors:      %"PRIu64"\n", eth_stats.oerrors);
+        printf("Hardware RX Missed:      %"PRIu64" (packets dropped by HW)\n", eth_stats.imissed);
+        printf("Hardware RX No MBuf:     %"PRIu64" (mbuf allocation failed)\n", eth_stats.rx_nombuf);
+        
+        /* Print per-queue statistics if available */
+        bool has_queue_stats = false;
+        for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS && i < 8; i++) {
+            if (eth_stats.q_ipackets[i] > 0 || eth_stats.q_opackets[i] > 0 || eth_stats.q_errors[i] > 0) {
+                if (!has_queue_stats) {
+                    printf("\nPer-Queue Statistics:\n");
+                    has_queue_stats = true;
+                }
+                printf("  Queue %d: RX=%"PRIu64", TX=%"PRIu64", Errors=%"PRIu64"\n",
+                    i, eth_stats.q_ipackets[i], eth_stats.q_opackets[i], eth_stats.q_errors[i]);
+            }
+        }
+        
+        /* Calculate packet loss if any */
+        if (eth_stats.ipackets > 0) {
+            uint64_t total_drops = eth_stats.imissed + eth_stats.rx_nombuf + eth_stats.ierrors;
+            if (total_drops > 0) {
+                double drop_rate = (double)total_drops * 100.0 / (eth_stats.ipackets + total_drops);
+                printf("\nPacket Loss Analysis:\n");
+                printf("  Total Drops:           %"PRIu64"\n", total_drops);
+                printf("  Drop Rate:             %.2f%%\n", drop_rate);
+                printf("  Primary Drop Cause:    ");
+                if (eth_stats.imissed > eth_stats.rx_nombuf && eth_stats.imissed > eth_stats.ierrors) {
+                    printf("HW Ring Full (imissed)\n");
+                } else if (eth_stats.rx_nombuf > eth_stats.ierrors) {
+                    printf("No MBuf Available\n");
+                } else if (eth_stats.ierrors > 0) {
+                    printf("HW Errors\n");
+                } else {
+                    printf("Unknown\n");
+                }
+            }
+        }
+    } else {
+        printf("Failed to get basic statistics for port %u\n", port_id);
+    }
+    
+    /* Get extended statistics for detailed drop analysis */
+    cnt_xstats = rte_eth_xstats_get_names(port_id, NULL, 0);
+    if (cnt_xstats > 0) {
+        xstat_names = malloc(sizeof(struct rte_eth_xstat_name) * cnt_xstats);
+        xstats = malloc(sizeof(struct rte_eth_xstat) * cnt_xstats);
+        
+        if (xstat_names && xstats) {
+            ret = rte_eth_xstats_get_names(port_id, xstat_names, cnt_xstats);
+            if (ret == cnt_xstats) {
+                ret = rte_eth_xstats_get(port_id, xstats, cnt_xstats);
+                if (ret == cnt_xstats) {
+                    printf("\nDetailed Drop/Error Statistics:\n");
+                    bool found_drops = false;
+                    for (i = 0; i < cnt_xstats; i++) {
+                        const char *name = xstat_names[i].name;
+                        uint64_t value = xstats[i].value;
+                        
+                        /* Filter for drop/error related statistics */
+                        if (value > 0 && (strstr(name, "drop") || strstr(name, "discard") || 
+                                         strstr(name, "error") || strstr(name, "miss") ||
+                                         strstr(name, "full") || strstr(name, "overflow") ||
+                                         strstr(name, "underrun") || strstr(name, "crc") ||
+                                         strstr(name, "fragment") || strstr(name, "jabber"))) {
+                            printf("  %-30s: %"PRIu64"\n", name, value);
+                            found_drops = true;
+                        }
+                    }
+                    if (!found_drops) {
+                        printf("  No drop/error statistics found\n");
+                    }
+                }
+            }
+        }
+        
+        free(xstat_names);
+        free(xstats);
+    }
+    printf("==========================================\n");
+}
+
+/**
+ * print_all_nic_hw_stats - Print NIC hardware statistics for all active ports
+ *
+ * DESCRIPTION
+ * Print NIC hardware statistics for all ports currently in use by pktgen
+ *
+ * RETURNS: N/A
+ */
+void
+print_all_nic_hw_stats(void)
+{
+    uint16_t port_id;
+    port_info_t *pinfo;
+    
+    printf("\n");
+    printf("########################################\n");
+    printf("# NIC HARDWARE STATISTICS ANALYSIS\n");
+    printf("########################################\n");
+    
+    RTE_ETH_FOREACH_DEV(port_id) {
+        pinfo = l2p_get_port_pinfo(port_id);
+        if (pinfo && pinfo->seq_pkt) {
+            print_nic_hw_stats(port_id);
+        }
+    }
+    
+    printf("########################################\n");
+}
diff --git a/app/pktgen.h b/app/pktgen.h
index 5349a31..9315768 100644
--- a/app/pktgen.h
+++ b/app/pktgen.h
@@ -351,6 +351,7 @@ void pktgen_input_start(void);
 void stat_timer_dump(void);
 void stat_timer_clear(void);
 void pktgen_timer_setup(void);
+void print_pktgen_stats_summary(void);
 double next_poisson_time(double rateParameter);
 
 void pktgen_setup_packets(uint16_t pid);
diff --git a/scripts/measure-rx-tx-rate.lua b/scripts/measure-rx-tx-rate.lua
new file mode 100644
index 0000000..351bbc2
--- /dev/null
+++ b/scripts/measure-rx-tx-rate.lua
@@ -0,0 +1,133 @@
+-- RX/TX Rate Measurement Script (based on measure-tx-rate.lua)
+
+-- Since we run from Pktgen-DPDK directory, just add current directory to path
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = tonumber(os.getenv("PKTGEN_DURATION")) or 10
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Configuration (same as measure-tx-rate.lua)
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 100)  -- Maximum rate
+pktgen.set(port, "count", 0)   -- Continuous transmission
+
+-- Set MAC addresses (same as measure-tx-rate.lua)
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+
+-- Set IP addresses (same as measure-tx-rate.lua)
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+-- Set up Range configuration for TCP (same as measure-tx-rate.lua)
+pktgen.range.ip_proto("all", "tcp")
+
+-- Set MAC addresses in range (same as measure-tx-rate.lua)
+pktgen.range.src_mac(port, "start", "08:c0:eb:b6:cd:5d")
+pktgen.range.dst_mac(port, "start", "08:c0:eb:b6:e8:05")
+
+-- Set source IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.src_ip(port, "start", "10.0.1.7")
+pktgen.range.src_ip(port, "inc", "0.0.0.0")
+pktgen.range.src_ip(port, "min", "10.0.1.7")
+pktgen.range.src_ip(port, "max", "10.0.1.7")
+
+-- Set destination IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.dst_ip(port, "start", "10.0.1.8")
+pktgen.range.dst_ip(port, "inc", "0.0.0.0")
+pktgen.range.dst_ip(port, "min", "10.0.1.8")
+pktgen.range.dst_ip(port, "max", "10.0.1.8")
+
+-- Set source TCP port (20000-20255, increment by 1, same as measure-tx-rate.lua)
+pktgen.range.src_port(port, "start", 20000)
+pktgen.range.src_port(port, "inc", 1)
+pktgen.range.src_port(port, "min", 10000)
+pktgen.range.src_port(port, "max", 60000)
+
+-- Set destination TCP port (fixed at 20000, same as measure-tx-rate.lua)
+pktgen.range.dst_port(port, "start", 20000)
+pktgen.range.dst_port(port, "inc", 0)
+pktgen.range.dst_port(port, "min", 20000)
+pktgen.range.dst_port(port, "max", 20000)
+
+-- Set TTL (same as measure-tx-rate.lua)
+pktgen.range.ttl(port, "start", 64)
+pktgen.range.ttl(port, "inc", 0)
+pktgen.range.ttl(port, "min", 64)
+pktgen.range.ttl(port, "max", 64)
+
+-- Enable range mode (same as measure-tx-rate.lua)
+pktgen.set_range(port, "on")
+
+pktgen.delay(100)
+
+print("=== Starting RX/TX Rate Measurement ===")
+print("Configuration:")
+print("  Port: " .. port)
+print("  Packet Size: 64 bytes")
+print("  Protocol: TCP")
+print("  Test Duration: " .. sleeptime .. " seconds")
+print("  Rate: 100% (maximum)")
+print("  Range Mode: Enabled (Port 10000-60000)")
+print("==========================================")
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+-- Record initial statistics
+pktgen.delay(1000)  -- Wait 1 second for transmission to stabilize
+local initial_stats = pktgen.portStats("all", "port")[port]
+local initial_tx_pkts = initial_stats.opackets
+local initial_rx_pkts = initial_stats.ipackets
+
+-- Wait for test duration
+pktgen.delay(sleeptime * 1000)
+
+-- Stop transmission and get final statistics
+pktgen.stop(port)
+local final_stats = pktgen.portStats("all", "port")[port]
+local final_tx_pkts = final_stats.opackets
+local final_rx_pkts = final_stats.ipackets
+
+-- Calculate average rates in Mpps
+local total_tx_packets = final_tx_pkts - initial_tx_pkts
+local total_rx_packets = final_rx_pkts - initial_rx_pkts
+local avg_tx_rate_mpps = total_tx_packets / (sleeptime * 1000000)
+local avg_rx_rate_mpps = total_rx_packets / (sleeptime * 1000000)
+
+-- Calculate packet loss percentage
+local packet_loss_pct = 0
+if total_tx_packets > 0 then
+    packet_loss_pct = (1 - total_rx_packets/total_tx_packets) * 100
+end
+
+-- Display results
+print("\n=== RX/TX Rate Measurement Results ===")
+print("Test Duration: " .. sleeptime .. " seconds")
+print("Packet Size: 64 bytes")
+print("Protocol: TCP with ranges")
+print("Total Packets Transmitted: " .. total_tx_packets)
+print("Total Packets Received: " .. total_rx_packets)
+print("Average TX Rate: " .. string.format("%.3f", avg_tx_rate_mpps) .. " Mpps")
+print("Average RX Rate: " .. string.format("%.3f", avg_rx_rate_mpps) .. " Mpps")
+print("Packet Loss: " .. string.format("%.2f", packet_loss_pct) .. "%")
+print("=====================================")
+
+-- Print results in parseable format for automation
+print("RESULT_TX_RATE_MPPS:" .. string.format("%.3f", avg_tx_rate_mpps))
+print("RESULT_RX_RATE_MPPS:" .. string.format("%.3f", avg_rx_rate_mpps))
+print("RESULT_TX_PACKETS:" .. total_tx_packets)
+print("RESULT_RX_PACKETS:" .. total_rx_packets)
+
+-- Auto quit to prevent interactive mode - use os.exit instead of pktgen.quit()
+print("Auto-quitting pktgen...")
+pktgen.delay(1000)  -- Wait 1 second before quitting
+os.exit(0)
diff --git a/scripts/measure-tx-rate.lua b/scripts/measure-tx-rate.lua
new file mode 100644
index 0000000..d86e02a
--- /dev/null
+++ b/scripts/measure-tx-rate.lua
@@ -0,0 +1,99 @@
+-- TX Rate Measurement Script
+
+-- Since we run from Pktgen-DPDK directory, just add current directory to path
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = tonumber(os.getenv("PKTGEN_DURATION")) or 10
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Configuration
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 100)  -- Maximum rate
+pktgen.set(port, "count", 0)   -- Continuous transmission
+
+-- Set MAC addresses
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+
+-- Set IP addresses
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+-- Set up Range configuration for TCP
+pktgen.range.ip_proto("all", "tcp")
+
+-- Set MAC addresses in range
+pktgen.range.src_mac(port, "start", "08:c0:eb:b6:cd:5d")
+pktgen.range.dst_mac(port, "start", "08:c0:eb:b6:e8:05")
+
+-- Set source IP (fixed)
+pktgen.range.src_ip(port, "start", "10.0.1.7")
+pktgen.range.src_ip(port, "inc", "0.0.0.0")
+pktgen.range.src_ip(port, "min", "10.0.1.7")
+pktgen.range.src_ip(port, "max", "10.0.1.7")
+
+-- Set destination IP (fixed)
+pktgen.range.dst_ip(port, "start", "10.0.1.8")
+pktgen.range.dst_ip(port, "inc", "0.0.0.0")
+pktgen.range.dst_ip(port, "min", "10.0.1.8")
+pktgen.range.dst_ip(port, "max", "10.0.1.8")
+
+-- Set source TCP port (20000-20255, increment by 1)
+pktgen.range.src_port(port, "start", 20000)
+pktgen.range.src_port(port, "inc", 1)
+pktgen.range.src_port(port, "min", 20000)
+pktgen.range.src_port(port, "max", 20255)
+
+-- Set destination TCP port (fixed at 20000)
+pktgen.range.dst_port(port, "start", 20000)
+pktgen.range.dst_port(port, "inc", 0)
+pktgen.range.dst_port(port, "min", 20000)
+pktgen.range.dst_port(port, "max", 20000)
+
+-- Set TTL
+pktgen.range.ttl(port, "start", 64)
+pktgen.range.ttl(port, "inc", 0)
+pktgen.range.ttl(port, "min", 64)
+pktgen.range.ttl(port, "max", 64)
+
+-- Enable range mode
+pktgen.set_range(port, "on")
+
+pktgen.delay(100)
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+-- Record initial statistics
+pktgen.delay(1000)  -- Wait 1 second for transmission to stabilize
+local initial_stats = pktgen.portStats("all", "port")[port]
+local initial_tx_pkts = initial_stats.opackets
+
+-- Wait for test duration
+pktgen.delay(sleeptime * 1000)
+
+-- Stop transmission and get final statistics
+pktgen.stop(port)
+local final_stats = pktgen.portStats("all", "port")[port]
+local final_tx_pkts = final_stats.opackets
+
+-- Calculate average TX rate in Mpps
+local total_packets = final_tx_pkts - initial_tx_pkts
+local avg_tx_rate_mpps = total_packets / (sleeptime * 1000000)
+
+-- Display results
+print("\n=== TX Rate Measurement Results ===")
+print("Test Duration: " .. sleeptime .. " seconds")
+print("Packet Size: 64 bytes")
+print("Protocol: TCP")
+print("Total Packets Transmitted: " .. total_packets)
+print("Average TX Rate: " .. string.format("%.3f", avg_tx_rate_mpps) .. " Mpps")
+print("=====================================\n")
\ No newline at end of file
diff --git a/scripts/simple-test.lua b/scripts/simple-test.lua
new file mode 100644
index 0000000..e2a02c8
--- /dev/null
+++ b/scripts/simple-test.lua
@@ -0,0 +1,16 @@
+-- Simple test script to check if lua execution works
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+
+print("Simple test script loaded successfully")
+print("Stopping and clearing port " .. port)
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+print("Test completed successfully")
diff --git a/scripts/simple-tx-rate.lua b/scripts/simple-tx-rate.lua
new file mode 100644
index 0000000..86cde97
--- /dev/null
+++ b/scripts/simple-tx-rate.lua
@@ -0,0 +1,55 @@
+-- Simplified TX Rate Measurement Script
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = 3  -- Reduced to 3 seconds for testing
+
+print("Starting simplified TX rate measurement...")
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Basic configuration
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 100)  -- Maximum rate
+pktgen.set(port, "count", 0)   -- Continuous transmission
+
+-- Simple MAC and IP addresses (no range)
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+pktgen.delay(100)
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+-- Record initial statistics
+pktgen.delay(1000)  -- Wait 1 second for transmission to stabilize
+local initial_stats = pktgen.portStats("all", "port")[port]
+local initial_tx_pkts = initial_stats.opackets
+
+-- Wait for test duration
+pktgen.delay(sleeptime * 1000)
+
+-- Stop transmission and get final statistics
+pktgen.stop(port)
+local final_stats = pktgen.portStats("all", "port")[port]
+local final_tx_pkts = final_stats.opackets
+
+-- Calculate average TX rate in Mpps
+local total_packets = final_tx_pkts - initial_tx_pkts
+local avg_tx_rate_mpps = total_packets / (sleeptime * 1000000)
+
+-- Display results
+print("\n=== Simplified TX Rate Results ===")
+print("Test Duration: " .. sleeptime .. " seconds")
+print("Total Packets Transmitted: " .. total_packets)
+print("Average TX Rate: " .. string.format("%.3f", avg_tx_rate_mpps) .. " Mpps")
+print("====================================\n")
diff --git a/scripts/simple-tx-test.lua b/scripts/simple-tx-test.lua
new file mode 100644
index 0000000..0003adb
--- /dev/null
+++ b/scripts/simple-tx-test.lua
@@ -0,0 +1,81 @@
+-- RX/TX Rate Measurement Script (based on measure-tx-rate.lua)
+
+-- Since we run from Pktgen-DPDK directory, just add current directory to path
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = tonumber(os.getenv("PKTGEN_DURATION")) or 10
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Configuration (same as measure-tx-rate.lua)
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 100)  -- 100% rate to utilize multiple cores
+pktgen.set(port, "count", 0)   -- Continuous transmission (0 = infinite)
+
+-- Set MAC addresses (same as measure-tx-rate.lua)
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+
+-- Set IP addresses (same as measure-tx-rate.lua)
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+-- Set up Range configuration for TCP (same as measure-tx-rate.lua)
+pktgen.range.ip_proto("all", "tcp")
+
+-- Set MAC addresses in range (same as measure-tx-rate.lua)
+pktgen.range.src_mac(port, "start", "08:c0:eb:b6:cd:5d")
+pktgen.range.dst_mac(port, "start", "08:c0:eb:b6:e8:05")
+
+-- Set source IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.src_ip(port, "start", "10.0.1.7")
+pktgen.range.src_ip(port, "inc", "0.0.0.0")
+pktgen.range.src_ip(port, "min", "10.0.1.7")
+pktgen.range.src_ip(port, "max", "10.0.1.7")
+
+-- Set destination IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.dst_ip(port, "start", "10.0.1.8")
+pktgen.range.dst_ip(port, "inc", "0.0.0.0")
+pktgen.range.dst_ip(port, "min", "10.0.1.8")
+pktgen.range.dst_ip(port, "max", "10.0.1.8")
+
+-- Set source TCP port (20000-20255, increment by 1, same as measure-tx-rate.lua)
+pktgen.range.src_port(port, "start", 20000)
+pktgen.range.src_port(port, "inc", 1)
+pktgen.range.src_port(port, "min", 10000)
+pktgen.range.src_port(port, "max", 60000)
+
+-- Set destination TCP port (fixed at 20000, same as measure-tx-rate.lua)
+pktgen.range.dst_port(port, "start", 20000)
+pktgen.range.dst_port(port, "inc", 0)
+pktgen.range.dst_port(port, "min", 20000)
+pktgen.range.dst_port(port, "max", 20000)
+
+-- Set TTL (same as measure-tx-rate.lua)
+pktgen.range.ttl(port, "start", 64)
+pktgen.range.ttl(port, "inc", 0)
+pktgen.range.ttl(port, "min", 64)
+pktgen.range.ttl(port, "max", 64)
+
+-- Enable range mode (same as measure-tx-rate.lua)
+pktgen.set_range(port, "on")
+
+pktgen.delay(100)
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+pktgen.delay(1000)  -- Wait 1 second before quitting
+
+-- Print packet statistics summary before exit
+print("\nPrinting packet statistics summary...")
+pktgen.print_stats()
+
+os.exit(0)
