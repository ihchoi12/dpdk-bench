diff --git a/app/lpktgenlib.c b/app/lpktgenlib.c
index 37136c7..2f45de7 100644
--- a/app/lpktgenlib.c
+++ b/app/lpktgenlib.c
@@ -53,6 +53,13 @@ pktgen_exit(lua_State *L __rte_unused)
     return 0;
 }
 
+static int
+pktgen_print_stats_summary(lua_State *L __rte_unused)
+{
+    print_pktgen_stats_summary();
+    return 0;
+}
+
 static inline double
 cycles_to_us(uint64_t cycles)
 {
@@ -3994,6 +4001,7 @@ static const luaL_Reg pktgenlib_range[] = {
 
 static const luaL_Reg pktgenlib[] = {
     {"quit", pktgen_exit},
+    {"print_stats", pktgen_print_stats_summary},
     {"set", pktgen_set}, /* Set a number of options */
 
     {"start", pktgen_start}, /* Start a set of ports sending packets */
diff --git a/app/meson.build b/app/meson.build
index eb0682f..3aac132 100644
--- a/app/meson.build
+++ b/app/meson.build
@@ -1,3 +1,23 @@
+# Add C++ compiler support for PCM wrapper
+add_languages('cpp', required: true)
+
+# Import filesystem module
+fs = import('fs')
+
+# PCM library configuration for static linking
+pcm_base_path = meson.current_source_dir() / '..' / '..' / 'pcm'
+pcm_lib_path = pcm_base_path / 'build' / 'src'
+pcm_inc_path = pcm_base_path / 'src'
+
+# Check for PCM static library
+pcm_static_lib = pcm_lib_path / 'libpcm.a'
+pcm_found = false
+
+if fs.is_file(pcm_static_lib)
+    pcm_found = true
+    message('Found PCM static library: ' + pcm_static_lib)
+endif
+
 sources = files(
 	'cli-functions.c',
     'l2p.c',
@@ -27,15 +47,34 @@ sources = files(
 	'pktgen-vlan.c',
 	'pktgen-workq.c',
 	'pktgen.c',
+	'pktgen_pcm.c',
 	'xorshift64star.c',
 )
 
+# Add PCM wrapper if library found
+if pcm_found
+    sources += files('pktgen_pcm_wrapper.cpp')
+    message('PCM integration enabled with static linking')
+endif
+
 if get_option('enable_lua')
     sources += files('lpktgenlib.c')
 endif
 
 cflags = ['-D__PROJECT_VERSION="' + meson.project_version() + '"']
 
+# Initialize ldflags and includes
+ldflags = []
+includes = []
+cpp_args = []
+
+# Add PCM support if available
+if pcm_found
+    # Only add PCM includes to C++ files, not C files to avoid conflicts
+    cpp_args += ['-I../../pcm/src']
+    ldflags += [pcm_static_lib, '-static-libstdc++', '-static-libgcc', '-lpthread', '-ldl', '-lnuma']
+endif
+
 deps = [dpdk, common, utils, vec, plugin, cli, lua, hmap]
 
 if fgen_dep.found()
@@ -48,7 +87,7 @@ deps += [cc.find_library('rte_net_ice', dirs: [dpdk_libs_path], required: false)
 deps += [cc.find_library('rte_bus_vdev', dirs: [dpdk_libs_path], required: false)]
 
 deps += [dependency('threads')]
-deps += [dependency('numa', required: true)]
+deps += [dependency('numa', required: false)]
 deps += [dependency('pcap', required: true)]
 deps += [cc.find_library('dl', required: false)]
 deps += [cc.find_library('m', required: false)]
@@ -57,5 +96,8 @@ deps += [cc.find_library('bsd', required: true)]
 pktgen = executable('pktgen',
 		sources,
 		c_args: cflags,
+		cpp_args: cpp_args,
+		link_args: ldflags,
+		include_directories: includes,
 		install: true,
 		dependencies: [deps, lua_dep, dpdk_bond])
diff --git a/app/pktgen-cmds.c b/app/pktgen-cmds.c
index 086ac5a..95eaa6d 100644
--- a/app/pktgen-cmds.c
+++ b/app/pktgen-cmds.c
@@ -3895,6 +3895,9 @@ pktgen_set_vxlan_seq(port_info_t *pinfo, uint32_t seqnum, uint32_t flag, uint32_
 void
 pktgen_quit(void)
 {
+    /* Print packet statistics summary before quitting */
+    print_pktgen_stats_summary();
+
     cli_quit();
 }
 
diff --git a/app/pktgen-main.c b/app/pktgen-main.c
index b9ea903..6ff4dc7 100644
--- a/app/pktgen-main.c
+++ b/app/pktgen-main.c
@@ -28,6 +28,7 @@
 #include "pktgen-display.h"
 #include "pktgen-log.h"
 #include "cli-functions.h"
+#include "pktgen_pcm.h"
 
 #ifdef LUA_ENABLED
 /**
@@ -327,6 +328,31 @@ sig_handler(int v __rte_unused)
 
     free(strings);
 
+    /* Print packet statistics summary before cleanup */
+    print_pktgen_stats_summary();
+
+    /* Print PCM monitoring statistics when stats_enabled is true */
+    extern volatile bool stats_enabled;
+    printf("DEBUG: sig_handler - stats_enabled = %s\n", stats_enabled ? "true" : "false");
+    if (stats_enabled) {
+        extern int pcm_monitoring_stop_all(void);
+        extern int pcm_monitoring_measure_all(void);
+        extern void pcm_print_core_statistics(void);
+        extern void pcm_print_memory_statistics(void);
+        extern void pcm_print_io_statistics(void);
+        extern void pcm_print_system_statistics(void);
+        printf("DEBUG: Signal handler - Stopping PCM monitoring...\n");
+        pcm_monitoring_stop_all();
+        printf("DEBUG: Signal handler - Measuring PCM stats...\n");
+        pcm_monitoring_measure_all();
+        printf("=== PCM Statistics ===\n");
+        pcm_print_core_statistics();
+        pcm_print_memory_statistics();
+        pcm_print_io_statistics();
+        pcm_print_system_statistics();
+        printf("=== End PCM Statistics ===\n");
+    }
+
     cli_destroy();
     scrn_destroy();
 
@@ -345,6 +371,34 @@ pktgen_lua_dofile(void *ld, const char *filename)
 }
 #endif
 
+/**
+ * PCM statistics atexit handler
+ */
+static void
+pcm_atexit_handler(void)
+{
+    extern volatile bool stats_enabled;
+    printf("DEBUG: atexit handler - stats_enabled = %s\n", stats_enabled ? "true" : "false");
+    if (stats_enabled) {
+        extern int pcm_monitoring_stop_all(void);
+        extern int pcm_monitoring_measure_all(void);
+        extern void pcm_print_core_statistics(void);
+        extern void pcm_print_memory_statistics(void);
+        extern void pcm_print_io_statistics(void);
+        extern void pcm_print_system_statistics(void);
+        printf("DEBUG: atexit handler - Stopping PCM monitoring...\n");
+        pcm_monitoring_stop_all();
+        printf("DEBUG: atexit handler - Measuring PCM stats...\n");
+        pcm_monitoring_measure_all();
+        printf("=== PCM Statistics ===\n");
+        pcm_print_core_statistics();
+        pcm_print_memory_statistics();
+        pcm_print_io_statistics();
+        pcm_print_system_statistics();
+        printf("=== End PCM Statistics ===\n");
+    }
+}
+
 /**
  *
  * main - Main routine to setup pktgen.
@@ -514,6 +568,27 @@ main(int argc, char **argv)
     sigaddset(&set, SIGWINCH);
     pthread_sigmask(SIG_UNBLOCK, &set, NULL);
 
+    /* Initialize PCM monitoring when stats_enabled is true */
+    extern volatile bool stats_enabled;
+    printf("DEBUG: stats_enabled = %s\n", stats_enabled ? "true" : "false");
+    if (stats_enabled) {
+        extern int pcm_monitoring_init(void);
+        extern int pcm_monitoring_start_all(void);
+        printf("DEBUG: Attempting PCM initialization...\n");
+        int pcm_init_result = pcm_monitoring_init();
+        printf("DEBUG: PCM init result = %d\n", pcm_init_result);
+        if (pcm_init_result == 0) {
+            printf("PCM monitoring initialized successfully\n");
+            int pcm_start_result = pcm_monitoring_start_all();
+            printf("DEBUG: PCM start result = %d\n", pcm_start_result);
+
+            /* Register atexit handler for PCM statistics */
+            atexit(pcm_atexit_handler);
+        } else {
+            printf("PCM monitoring initialization failed or disabled\n");
+        }
+    }
+
     /* execute the command files if present */
     scrn_pause();
     cli_execute_cmdfiles();
@@ -559,10 +634,33 @@ main(int argc, char **argv)
 void
 pktgen_stop_running(void)
 {
+
 #ifdef LUA_ENABLED
     lua_execute_close(pktgen.ld);
 #endif
 
     pktgen.timer_running = 0;
     pktgen.force_quit    = 1;
+
+    /* Print PCM monitoring statistics when stats_enabled is true */
+    extern volatile bool stats_enabled;
+    printf("DEBUG: pktgen_stop_running - stats_enabled = %s\n", stats_enabled ? "true" : "false");
+    if (stats_enabled) {
+        extern int pcm_monitoring_stop_all(void);
+        extern int pcm_monitoring_measure_all(void);
+        extern void pcm_print_core_statistics(void);
+        extern void pcm_print_memory_statistics(void);
+        extern void pcm_print_io_statistics(void);
+        extern void pcm_print_system_statistics(void);
+        printf("DEBUG: Stopping PCM monitoring...\n");
+        pcm_monitoring_stop_all();
+        printf("DEBUG: Measuring PCM stats...\n");
+        pcm_monitoring_measure_all();
+        printf("=== PCM Statistics ===\n");
+        pcm_print_core_statistics();
+        pcm_print_memory_statistics();
+        pcm_print_io_statistics();
+        pcm_print_system_statistics();
+        printf("=== End PCM Statistics ===\n");
+    }
 }
diff --git a/app/pktgen-packet-loss.h b/app/pktgen-packet-loss.h
new file mode 100644
index 0000000..e69de29
diff --git a/app/pktgen-port-cfg.c b/app/pktgen-port-cfg.c
index 1e4042a..894b612 100644
--- a/app/pktgen-port-cfg.c
+++ b/app/pktgen-port-cfg.c
@@ -180,13 +180,33 @@ allocate_port_info(uint16_t pid)
         goto leave;
     }
 
-    pinfo->rx_pkts = rte_calloc_socket("RxMbufs", MAX_PKT_RX_BURST, sizeof(struct rte_mbuf *),
-                                       RTE_CACHE_LINE_SIZE, sid);
-    pinfo->tx_pkts = rte_calloc_socket("TxMbufs", MAX_PKT_TX_BURST, sizeof(struct rte_mbuf *),
-                                       RTE_CACHE_LINE_SIZE, sid);
-    if (pinfo->rx_pkts == NULL || pinfo->tx_pkts == NULL) {
-        pktgen_log_error("Cannot allocate RX/TX burst for port %u", pid);
-        goto leave;
+    /* Allocate RX packet buffers for each queue */
+    for (int q = 0; q < 16; q++) {
+        pinfo->rx_pkts[q] = rte_calloc_socket("RxMbufs", MAX_PKT_RX_BURST, sizeof(struct rte_mbuf *),
+                                               RTE_CACHE_LINE_SIZE, sid);
+        if (pinfo->rx_pkts[q] == NULL) {
+            pktgen_log_error("Cannot allocate RX burst for port %u queue %d", pid, q);
+            /* Free previously allocated queues */
+            for (int i = 0; i < q; i++)
+                rte_free(pinfo->rx_pkts[i]);
+            goto leave;
+        }
+    }
+
+    /* Allocate TX burst for each queue */
+    for (int q = 0; q < 16; q++) {
+        pinfo->tx_pkts[q] = rte_calloc_socket("TxMbufs", MAX_PKT_TX_BURST, sizeof(struct rte_mbuf *),
+                                           RTE_CACHE_LINE_SIZE, sid);
+        if (pinfo->tx_pkts[q] == NULL) {
+            pktgen_log_error("Cannot allocate TX burst for port %u queue %d", pid, q);
+            /* Free all RX queues */
+            for (int i = 0; i < 16; i++)
+                rte_free(pinfo->rx_pkts[i]);
+            /* Free allocated TX queues */
+            for (int i = 0; i < q; i++)
+                rte_free(pinfo->tx_pkts[i]);
+            goto leave;
+        }
     }
 
     if (l2p_set_port_pinfo(pid, pinfo)) {
@@ -227,8 +247,10 @@ allocate_port_info(uint16_t pid)
     return pinfo;
 leave:
     if (pinfo) {
-        rte_free(pinfo->rx_pkts);
-        rte_free(pinfo->tx_pkts);
+        for (int q = 0; q < 16; q++) {
+            rte_free(pinfo->rx_pkts[q]);
+            rte_free(pinfo->tx_pkts[q]);
+        }
         rte_free(pinfo);
         l2p_set_port_pinfo(pid, NULL);
     }
diff --git a/app/pktgen-port-cfg.h b/app/pktgen-port-cfg.h
index d2b54a6..ef6f7d8 100644
--- a/app/pktgen-port-cfg.h
+++ b/app/pktgen-port-cfg.h
@@ -133,8 +133,8 @@ typedef struct {
 typedef struct port_info_s {
     struct rte_eth_dev_info dev_info; /**< Device information */
     struct rte_eth_conf conf;         /**< Configuration settings */
-    struct rte_mbuf **rx_pkts;        /**< Array of pointers to packet buffers for RX */
-    struct rte_mbuf **tx_pkts;        /**< Array of pointers to packet buffers for TX */
+    struct rte_mbuf **rx_pkts[16];    /**< Array of pointers to packet buffers for RX per queue */
+    struct rte_mbuf **tx_pkts[16];    /**< Array of pointers to packet buffers for TX per queue */
 
     rte_atomic64_t port_flags;       /**< Special send flags for ARP and other */
     rte_atomic64_t transmit_count;   /**< Packets to transmit loaded into current_tx_count */
diff --git a/app/pktgen-stats.c b/app/pktgen-stats.c
index ac33b51..f6206cd 100644
--- a/app/pktgen-stats.c
+++ b/app/pktgen-stats.c
@@ -266,6 +266,11 @@ pktgen_page_stats(void)
     char buff[32];
     int display_cnt;
 
+    /* Only display stats if enabled */
+    if (!stats_enabled) {
+        return;
+    }
+
     if (pktgen.flags & PRINT_LABELS_FLAG)
         pktgen_print_static_data();
 
@@ -456,6 +461,11 @@ pktgen_process_stats(void)
     port_info_t *pinfo;
     static unsigned int counter = 0;
 
+    /* Only process stats if enabled */
+    if (!stats_enabled) {
+        return;
+    }
+
     counter++;
     if (pktgen.flags & BLINK_PORTS_FLAG) {
         RTE_ETH_FOREACH_DEV(pid)
diff --git a/app/pktgen.c b/app/pktgen.c
index 627034d..7d4841c 100644
--- a/app/pktgen.c
+++ b/app/pktgen.c
@@ -18,6 +18,9 @@ TXlib */
 #include <rte_arp.h>
 #include <rte_cycles.h>
 #include <rte_hexdump.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
 
 #include "pktgen.h"
 #include "pktgen-gre.h"
@@ -34,15 +37,170 @@ TXlib */
 #include "pktgen-gtpu.h"
 #include "pktgen-sys.h"
 #include "pktgen-workq.h"
+#include "pktgen_pcm.h"
 
 #include <pthread.h>
 #include <sched.h>
-
 #define FAST_TX_MODE 0
 
+/* Core statistics structure for summary reporting */
+typedef struct {
+    uint64_t rx_packets;
+    uint64_t tx_packets;
+    uint64_t filtered_rx_packets;   /* RX packets excluding unwanted traffic like DHCP */
+    uint64_t filtered_tx_packets;   /* TX packets excluding unwanted traffic like DHCP */
+    uint64_t start_time;
+    uint16_t port_id;
+} lcore_stats_t;
+
+/* Global array to store per-lcore statistics */
+static lcore_stats_t lcore_stats[RTE_MAX_LCORE];
+
+/* RX Drop Analysis Structure */
+typedef struct {
+    uint64_t total_rx_attempts;     /* Total rte_eth_rx_burst calls */
+    uint64_t zero_rx_count;         /* Times rx_burst returned 0 */
+    uint64_t small_rx_count;        /* Times rx_burst returned < expected */
+    uint64_t full_rx_count;         /* Times rx_burst returned max burst */
+    uint64_t hw_drops_last;         /* Last HW drop count */
+    uint64_t hw_drops_delta;        /* HW drop increase since last check */
+    uint64_t mbuf_fail_count;       /* mbuf allocation failures */
+    uint64_t ring_full_count;       /* Ring full incidents */
+    uint64_t last_check_time;       /* Last analysis timestamp */
+    uint64_t analysis_interval;     /* Analysis interval in cycles */
+} rx_drop_analysis_t;
+
+/* Per-core RX drop analysis */
+static rx_drop_analysis_t rx_analysis[RTE_MAX_LCORE];
+
+/* Function to print packet statistics summary */
+void print_pktgen_stats_summary(void);
+
+/* Function to print NIC hardware statistics */
+void print_nic_hw_stats(uint16_t port_id);
+void print_all_nic_hw_stats(void);
+
+/* RX Drop Analysis Functions */
+void init_rx_drop_analysis(unsigned int lcore_id);
+void analyze_rx_performance(unsigned int lcore_id, uint16_t port_id, uint16_t nb_rx, uint16_t expected_rx);
+void print_rx_drop_analysis(void);
+
 /* Allocated the pktgen structure for global use */
 pktgen_t pktgen;
 
+/* Workqueue setup synchronization */
+static volatile uint16_t workq_setup_done[RTE_MAX_ETHPORTS][2]; /* [port][WORKQ_RX/WORKQ_TX] */
+
+/* Check if a packet is a DHCP packet (UDP ports 67/68) */
+static inline int
+is_dhcp_packet(struct rte_mbuf *pkt)
+{
+    struct rte_ether_hdr *eth_hdr;
+    struct rte_ipv4_hdr *ipv4_hdr;
+    struct rte_udp_hdr *udp_hdr;
+    uint16_t src_port, dst_port;
+
+    /* Check if packet is large enough and is IPv4 */
+    if (rte_pktmbuf_data_len(pkt) < sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*udp_hdr))
+        return 0;
+
+    eth_hdr = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
+    if (rte_be_to_cpu_16(eth_hdr->ether_type) != RTE_ETHER_TYPE_IPV4)
+        return 0;
+
+    ipv4_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);
+    if (ipv4_hdr->next_proto_id != IPPROTO_UDP)
+        return 0;
+
+    udp_hdr = (struct rte_udp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+    src_port = rte_be_to_cpu_16(udp_hdr->src_port);
+    dst_port = rte_be_to_cpu_16(udp_hdr->dst_port);
+
+    /* DHCP uses ports 67 (server) and 68 (client) */
+    return (src_port == 67 || src_port == 68 || dst_port == 67 || dst_port == 68);
+}
+
+#ifdef RTE_LIBRTE_ETHDEV_DEBUG
+/* Analyze and log packet details */
+static void
+analyze_packet(struct rte_mbuf *pkt, unsigned int lcore_id, uint16_t port_id, const char *direction)
+{
+    struct rte_ether_hdr *eth_hdr;
+    struct rte_ipv4_hdr *ipv4_hdr;
+    struct rte_tcp_hdr *tcp_hdr;
+    struct rte_udp_hdr *udp_hdr;
+    uint32_t src_ip, dst_ip;
+    uint16_t src_port = 0, dst_port = 0;
+    uint8_t proto;
+    char src_ip_str[INET_ADDRSTRLEN];
+    char dst_ip_str[INET_ADDRSTRLEN];
+    char src_mac_str[18];
+    char dst_mac_str[18];
+
+    eth_hdr = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
+    uint16_t ether_type = rte_be_to_cpu_16(eth_hdr->ether_type);
+
+    /* Convert MAC addresses to string format */
+    snprintf(src_mac_str, sizeof(src_mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+             eth_hdr->src_addr.addr_bytes[0], eth_hdr->src_addr.addr_bytes[1],
+             eth_hdr->src_addr.addr_bytes[2], eth_hdr->src_addr.addr_bytes[3],
+             eth_hdr->src_addr.addr_bytes[4], eth_hdr->src_addr.addr_bytes[5]);
+    snprintf(dst_mac_str, sizeof(dst_mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+             eth_hdr->dst_addr.addr_bytes[0], eth_hdr->dst_addr.addr_bytes[1],
+             eth_hdr->dst_addr.addr_bytes[2], eth_hdr->dst_addr.addr_bytes[3],
+             eth_hdr->dst_addr.addr_bytes[4], eth_hdr->dst_addr.addr_bytes[5]);
+
+    if (ether_type == RTE_ETHER_TYPE_IPV4) {
+        ipv4_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);
+        src_ip = rte_be_to_cpu_32(ipv4_hdr->src_addr);
+        dst_ip = rte_be_to_cpu_32(ipv4_hdr->dst_addr);
+        proto = ipv4_hdr->next_proto_id;
+
+        /* Convert IPs to string format */
+        struct in_addr addr;
+        addr.s_addr = rte_cpu_to_be_32(src_ip);
+        inet_ntop(AF_INET, &addr, src_ip_str, INET_ADDRSTRLEN);
+        addr.s_addr = rte_cpu_to_be_32(dst_ip);
+        inet_ntop(AF_INET, &addr, dst_ip_str, INET_ADDRSTRLEN);
+
+        /* Extract port numbers for TCP/UDP */
+        if (proto == IPPROTO_TCP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*tcp_hdr)) {
+            tcp_hdr = (struct rte_tcp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+            src_port = rte_be_to_cpu_16(tcp_hdr->src_port);
+            dst_port = rte_be_to_cpu_16(tcp_hdr->dst_port);
+            uint16_t eth_hdr_size = sizeof(*eth_hdr);
+            uint16_t ipv4_hdr_size = sizeof(*ipv4_hdr);
+            uint16_t tcp_hdr_size = (tcp_hdr->data_off >> 4) * 4;
+            uint16_t payload_size = pkt->pkt_len - eth_hdr_size - ipv4_hdr_size - tcp_hdr_size;
+
+            AK_DEBUG_LOG_PKTGEN("PKTGEN: [%s] lcore=%u port=%u TCP %s:%u -> %s:%u (MAC %s -> %s) (RSS=0x%08x) pkt_len=%u eth=%u ipv4=%u tcp=%u payload=%u",
+                direction, lcore_id, port_id, src_ip_str, src_port, dst_ip_str, dst_port, src_mac_str, dst_mac_str, pkt->hash.rss, pkt->pkt_len, eth_hdr_size, ipv4_hdr_size, tcp_hdr_size, payload_size);
+        } else if (proto == IPPROTO_UDP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*udp_hdr)) {
+            udp_hdr = (struct rte_udp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+            src_port = rte_be_to_cpu_16(udp_hdr->src_port);
+            dst_port = rte_be_to_cpu_16(udp_hdr->dst_port);
+            uint16_t eth_hdr_size = sizeof(*eth_hdr);
+            uint16_t ipv4_hdr_size = sizeof(*ipv4_hdr);
+            uint16_t udp_hdr_size = sizeof(*udp_hdr);
+            uint16_t payload_size = pkt->pkt_len - eth_hdr_size - ipv4_hdr_size - udp_hdr_size;
+            AK_DEBUG_LOG_PKTGEN("PKTGEN: [%s] lcore=%u port=%u UDP %s:%u -> %s:%u (MAC %s -> %s) (RSS=0x%08x) pkt_len=%u eth=%u ipv4=%u udp=%u payload=%u",
+                direction, lcore_id, port_id, src_ip_str, src_port, dst_ip_str, dst_port, src_mac_str, dst_mac_str, pkt->hash.rss, pkt->pkt_len, eth_hdr_size, ipv4_hdr_size, udp_hdr_size, payload_size);
+        } else {
+            uint16_t payload_size = pkt->pkt_len - sizeof(*eth_hdr) - (ipv4_hdr->version_ihl & 0x0F) * 4;
+            AK_DEBUG_LOG_PKTGEN("PKTGEN: [%s] lcore=%u port=%u IP proto=%u %s -> %s (MAC %s -> %s) (RSS=0x%08x) payload=%u",
+                direction, lcore_id, port_id, proto, src_ip_str, dst_ip_str, src_mac_str, dst_mac_str, pkt->hash.rss, payload_size);
+        }
+    } else if (ether_type == RTE_ETHER_TYPE_IPV6) {
+        uint16_t payload_size = pkt->pkt_len - sizeof(*eth_hdr) - 40; /* IPv6 header is 40 bytes */
+        AK_DEBUG_LOG_PKTGEN("PKTGEN: [%s] lcore=%u port=%u IPv6 packet (MAC %s -> %s) payload=%u",
+            direction, lcore_id, port_id, src_mac_str, dst_mac_str, payload_size);
+    } else {
+        uint16_t payload_size = pkt->pkt_len - sizeof(*eth_hdr);
+        AK_DEBUG_LOG_PKTGEN("PKTGEN: [%s] lcore=%u port=%u Non-IP packet (type=0x%04x) (MAC %s -> %s) payload=%u",
+            direction, lcore_id, port_id, ether_type, src_mac_str, dst_mac_str, payload_size);
+    }
+}
+#endif
 double
 next_poisson_time(double rateParameter)
 {
@@ -280,20 +438,107 @@ tx_send_packets(port_info_t *pinfo, uint16_t qid, struct rte_mbuf **pkts, uint16
 {
     if (nb_pkts) {
         uint16_t sent, to_send = nb_pkts;
+        unsigned int lcore_id = rte_lcore_id();
+        uint64_t filtered_count = 0;
 
-        pinfo->queue_stats.q_opackets[qid] += nb_pkts;
-        for (int i = 0; i < nb_pkts; i++)
+        /* Single iteration through all TX packets */
+        for (int i = 0; i < nb_pkts; i++) {
+            /* Calculate packet bytes for queue statistics */
             pinfo->queue_stats.q_obytes[qid] += rte_pktmbuf_pkt_len(pkts[i]);
 
+            /* Filter out unwanted packets (DHCP etc.) for statistics */
+            if (stats_enabled && !is_dhcp_packet(pkts[i])) {
+                filtered_count++;
+            }
+
+#ifdef RTE_LIBRTE_ETHDEV_DEBUG
+            /* Analyze packet for debugging */
+            analyze_packet(pkts[i], lcore_id, pinfo->pid, "TX");
+#endif
+        }
+
+        /* Update statistics */
+        pinfo->queue_stats.q_opackets[qid] += nb_pkts;
+        if (stats_enabled) {
+            lcore_stats[lcore_id].tx_packets += nb_pkts;
+            lcore_stats[lcore_id].filtered_tx_packets += filtered_count;
+            lcore_stats[lcore_id].port_id = pinfo->pid;
+            if (lcore_stats[lcore_id].start_time == 0)
+                lcore_stats[lcore_id].start_time = rte_rdtsc();
+        } else {
+            lcore_stats[lcore_id].tx_packets += nb_pkts;
+        }
         if (pktgen_tst_port_flags(pinfo, SEND_RANDOM_PKTS))
             pktgen_rnd_bits_apply(pinfo, pkts, to_send, NULL);
 
+        /* PCIe byte tracking for hardware-level measurement using Intel PCM */
+        uint64_t pcie_read_before = 0, pcie_write_before = 0;
+        uint64_t pcie_read_after = 0, pcie_write_after = 0;
+        uint32_t socket_id = 1;
+        int pcm_available = pcm_monitoring_is_available();
+        static __thread int pcm_debug_logged = 0;
+
+        /* Get PCIe counters BEFORE transmission (instant snapshot) */
+        if (pcm_available) {
+            extern int pcm_wrapper_get_instant_pcie_bytes(uint32_t socket_id, uint64_t *read, uint64_t *write);
+            int ret = pcm_wrapper_get_instant_pcie_bytes(socket_id, &pcie_read_before, &pcie_write_before);
+            if (ret != 0) {
+                if (!pcm_debug_logged) {
+                    printf("[PCM TX BURST DEBUG] pcm_wrapper_get_instant_pcie_bytes failed with ret=%d on lcore=%u socket=%u\n",
+                           ret, lcore_id, socket_id);
+                    pcm_debug_logged = 1;
+                }
+                pcm_available = 0;  /* Disable if failed */
+            } else if (!pcm_debug_logged) {
+                printf("[PCM TX BURST DEBUG] First call succeeded: lcore=%u socket=%u, read_before=%lu, write_before=%lu\n",
+                       lcore_id, socket_id, pcie_read_before, pcie_write_before);
+                printf("[PCM TX BURST DEBUG] Monitoring socket-specific PCIe traffic (socket %u only)\n", socket_id);
+                pcm_debug_logged = 1;
+            }
+        } else if (!pcm_debug_logged) {
+            printf("[PCM TX BURST DEBUG] PCM not available on lcore=%u\n", lcore_id);
+            pcm_debug_logged = 1;
+        }
+
         do {
+            AK_DEBUG_LOG_PKTGEN("[1] rte_eth_tx_burst()");
             sent = rte_eth_tx_burst(pinfo->pid, qid, pkts, to_send);
             to_send -= sent;
             pkts += sent;
         } while (to_send > 0);
 
+        /* Get PCIe counters AFTER transmission (instant snapshot) */
+        if (pcm_available) {
+            extern int pcm_wrapper_get_instant_pcie_bytes(uint32_t socket_id, uint64_t *read, uint64_t *write);
+            if (pcm_wrapper_get_instant_pcie_bytes(socket_id, &pcie_read_after, &pcie_write_after) == 0) {
+                /* Calculate PCIe bytes consumed for this transmission */
+                uint64_t pcie_read_delta = pcie_read_after - pcie_read_before;
+                uint64_t pcie_write_delta = pcie_write_after - pcie_write_before;
+
+                /* Log first 10 bursts, then every 100 bursts up to 1000, then every 10000 */
+                static __thread uint64_t log_counter = 0;
+                log_counter++;
+                printf("log_counter: %lu", log_counter);
+                int should_log = (log_counter <= 10) ||
+                                (log_counter <= 1000 && log_counter % 100 == 0) ||
+                                (log_counter % 10000 == 0);
+
+                if (should_log) {
+                    printf("[PCM TX BURST] lcore=%u socket=%u port=%u qid=%u nb_pkts=%u burst#%lu | "
+                           "PCIe Read: %lu bytes (%lu->%lu), PCIe Write: %lu bytes (%lu->%lu) | "
+                           "Avg per pkt: Read=%.1f B, Write=%.1f B\n",
+                           lcore_id, socket_id, pinfo->pid, qid, nb_pkts, log_counter,
+                           pcie_read_delta, pcie_read_before, pcie_read_after,
+                           pcie_write_delta, pcie_write_before, pcie_write_after,
+                           (double)pcie_read_delta / nb_pkts,
+                           (double)pcie_write_delta / nb_pkts);
+                }
+            }
+            else{
+                printf("[PCM TX BURST] pcm_wrapper_get_instant_pcie_bytes failed");
+            }
+        }
+
         if (qid == 0 && pktgen_tst_port_flags(pinfo, SEND_LATENCY_PKTS))
             pktgen_tstamp_inject(pinfo, qid);
     }
@@ -973,7 +1218,7 @@ void
 pktgen_send_pkts(port_info_t *pinfo, uint16_t qid, struct rte_mempool *mp)
 {
     uint64_t txCnt;
-    struct rte_mbuf **pkts = pinfo->tx_pkts;
+    struct rte_mbuf **pkts = pinfo->tx_pkts[qid];
 
     if (!pktgen_tst_port_flags(pinfo, SEND_FOREVER)) {
         txCnt = pkt_atomic64_tx_count(&pinfo->current_tx_count, pinfo->tx_burst);
@@ -1027,7 +1272,7 @@ fast_main_transmit(port_info_t *pinfo, uint16_t qid)
 {
     if (pktgen_tst_port_flags(pinfo, SENDING_PACKETS)) {
         struct rte_mempool *mp = l2p_get_tx_mp(pinfo->pid);
-        struct rte_mbuf **pkts = pinfo->tx_pkts;
+        struct rte_mbuf **pkts = pinfo->tx_pkts[qid];
 
         /* Use mempool routines instead of pktmbuf to make sure the mbufs is not altered */
         if (rte_mempool_get_bulk(mp, (void **)pkts, pinfo->tx_burst) == 0) {
@@ -1057,25 +1302,61 @@ static inline void
 pktgen_main_receive(port_info_t *pinfo, uint16_t qid)
 {
     uint16_t nb_rx, nb_pkts = pinfo->rx_burst, pid;
-    struct rte_mbuf **pkts = pinfo->rx_pkts;
+    struct rte_mbuf **pkts = pinfo->rx_pkts[qid];
 
     if (unlikely(pktgen_tst_port_flags(pinfo, STOP_RECEIVING_PACKETS)))
         return;
 
     pid = pinfo->pid;
+    unsigned int lcore_id = rte_lcore_id();
+
+    /* Initialize RX analysis if not done */
+    if (stats_enabled && rx_analysis[lcore_id].analysis_interval == 0) {
+        init_rx_drop_analysis(lcore_id);
+    }
 
     /* Read packets from RX queues and free the mbufs */
-    if (likely((nb_rx = rte_eth_rx_burst(pid, qid, pkts, nb_pkts)) > 0)) {
+    nb_rx = rte_eth_rx_burst(pid, qid, pkts, nb_pkts);
+
+    /* Analyze RX performance */
+    if (stats_enabled) {
+        analyze_rx_performance(lcore_id, pid, nb_rx, nb_pkts);
+    }
+
+    if (likely(nb_rx > 0)) {
         struct rte_eth_stats *qstats = &pinfo->queue_stats;
+        unsigned int lcore_id = rte_lcore_id();
+        uint64_t filtered_count = 0;
 
-        qstats->q_ipackets[qid] += nb_rx;
-        for (int i = 0; i < nb_rx; i++)
+        /* Single iteration through all received packets */
+        for (int i = 0; i < nb_rx; i++) {
+            /* Calculate packet bytes for queue statistics */
             qstats->q_ibytes[qid] += rte_pktmbuf_pkt_len(pkts[i]);
 
+            /* Filter out unwanted packets (DHCP etc.) for statistics */
+            if (stats_enabled && !is_dhcp_packet(pkts[i])) {
+                filtered_count++;
+            }
+
+#ifdef RTE_LIBRTE_ETHDEV_DEBUG
+            /* Analyze packet for debugging */
+            analyze_packet(pkts[i], lcore_id, pid, "RX");
+#endif
+        }
+
+        /* Update statistics */
+        qstats->q_ipackets[qid] += nb_rx;
+        if (stats_enabled) {
+            lcore_stats[lcore_id].rx_packets += nb_rx;
+            lcore_stats[lcore_id].filtered_rx_packets += filtered_count;
+            lcore_stats[lcore_id].port_id = pid;
+            if (lcore_stats[lcore_id].start_time == 0)
+                lcore_stats[lcore_id].start_time = rte_rdtsc();
+        }
         pktgen_tstamp_check(pinfo, pkts, nb_rx);
 
-        /* classify the packets for the counters */
-        pktgen_packet_classify_bulk(pkts, nb_rx, pid, qid);
+        /* Skip packet classification in high-performance mode */
+        // pktgen_packet_classify_bulk(pkts, nb_rx, pid, qid);
 
         if (unlikely(pinfo->dump_count > 0))
             pktgen_packet_dump_bulk(pkts, nb_rx, pid);
@@ -1122,12 +1403,52 @@ pktgen_tx_workq_setup(uint16_t pid)
 }
 
 static int
-pktgen_workq_setup(workq_type_t wqt, uint16_t pid, void *arg)
+pktgen_workq_setup_once(workq_type_t wqt, uint16_t pid, void *arg)
 {
-    if (workq_port_arg_set(pid, arg))
-        return -1;
+    uint16_t wqt_idx = (wqt == WORKQ_RX) ? 0 : 1;
+
+    /* Check if this workqueue type for this port is already set up */
+    if (__atomic_compare_exchange_n(&workq_setup_done[pid][wqt_idx],
+                                    &(uint16_t){0}, 1,
+                                    false, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) {
+        /* This core won the race - perform the actual setup */
+        AK_DEBUG_LOG_LINE(DEBUG, "Core %d: Setting up %s workqueue for port %d",
+                          rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+
+        if (workq_port_arg_set(pid, arg)) {
+            __atomic_store_n(&workq_setup_done[pid][wqt_idx], 0, __ATOMIC_RELEASE);
+            return -1;
+        }
+
+        int ret = (wqt == WORKQ_RX) ? pktgen_rx_workq_setup(pid) : pktgen_tx_workq_setup(pid);
+        if (ret != 0) {
+            /* Reset on failure */
+            __atomic_store_n(&workq_setup_done[pid][wqt_idx], 0, __ATOMIC_RELEASE);
+            return ret;
+        }
+
+        AK_DEBUG_LOG_LINE(DEBUG, "Core %d: Successfully set up %s workqueue for port %d",
+                          rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+    } else {
+        /* Another core is setting it up - wait for completion */
+        AK_DEBUG_LOG_LINE(DEBUG, "Core %d: Waiting for %s workqueue setup for port %d",
+                          rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
 
-    return (wqt == WORKQ_RX) ? pktgen_rx_workq_setup(pid) : pktgen_tx_workq_setup(pid);
+        while (__atomic_load_n(&workq_setup_done[pid][wqt_idx], __ATOMIC_ACQUIRE) != 1) {
+            rte_pause();
+        }
+
+        AK_DEBUG_LOG_LINE(DEBUG, "Core %d: %s workqueue for port %d is ready",
+                          rte_lcore_id(), (wqt == WORKQ_RX) ? "RX" : "TX", pid);
+    }
+
+    return 0;
+}
+
+static int
+pktgen_workq_setup(workq_type_t wqt, uint16_t pid, void *arg)
+{
+    return pktgen_workq_setup_once(wqt, pid, arg);
 }
 
 /**
@@ -1280,7 +1601,7 @@ pktgen_main_rx_loop(void)
 
     pinfo  = l2p_get_pinfo_by_lcore(lid);
     rx_qid = l2p_get_rxqid(lid);
-
+    AK_DEBUG_LOG_LINE(DEBUG, "RX Core Info: lid %3d, rx_qid %2d, cpu_id %2d, pinfo %p", lid, rx_qid, sched_getcpu(), pinfo);
     printf("RX lid %3d, pid %2d, qid %2d, Mempool %-16s @ %p\n", lid, pinfo->pid, rx_qid,
            l2p_get_rx_mp(pinfo->pid)->name, l2p_get_rx_mp(pinfo->pid));
 
@@ -1479,3 +1800,400 @@ pktgen_timer_setup(void)
     CPU_SET(rte_get_main_lcore(), cpuset);
     pthread_setaffinity_np(tid, sizeof(cpuset), cpuset);
 }
+
+/**
+ * print_pktgen_stats_summary - Print per-lcore packet statistics summary
+ *
+ * DESCRIPTION
+ * Print a summary table of RX/TX packet statistics for each lcore,
+ * similar to L3FWD's statistics output format.
+ *
+ * RETURNS: N/A
+ */
+void
+print_pktgen_stats_summary(void)
+{
+    unsigned int lcore_id;
+    uint64_t total_rx = 0, total_tx = 0;
+    uint64_t current_time = rte_rdtsc();
+    uint64_t tsc_hz = rte_get_tsc_hz();
+
+    /* Only print statistics if enabled */
+    if (!stats_enabled) {
+        return;
+    }
+
+    printf("\n");
+    printf("=====================================\n");
+    printf("PKTGEN Packet Statistics Summary\n");
+    printf("=====================================\n");
+    printf("%-8s %-12s %-12s %-10s %-10s %-8s\n",
+        "Lcore", "RX Packets", "TX Packets", "RX Rate", "TX Rate", "Diff%");
+    printf("%-8s %-12s %-12s %-10s %-10s %-8s\n",
+        "-----", "----------", "----------", "--------", "--------", "------");
+
+    RTE_LCORE_FOREACH(lcore_id) {
+        if (lcore_stats[lcore_id].start_time > 0) {
+            uint64_t duration = current_time - lcore_stats[lcore_id].start_time;
+            double elapsed_sec = (double)duration / tsc_hz;
+            double rx_rate = elapsed_sec > 0 ? lcore_stats[lcore_id].filtered_rx_packets / elapsed_sec : 0;
+            double tx_rate = elapsed_sec > 0 ? lcore_stats[lcore_id].filtered_tx_packets / elapsed_sec : 0;
+
+            /* Calculate proper rate for individual lcore using filtered counts */
+            double rate = 0.0;
+            uint64_t filtered_rx = lcore_stats[lcore_id].filtered_rx_packets;
+            uint64_t filtered_tx = lcore_stats[lcore_id].filtered_tx_packets;
+
+            if (filtered_rx > 0) {
+                if (filtered_tx > filtered_rx) {
+                    /* Amplification case: more filtered TX than filtered RX */
+                    rate = (double)(filtered_tx - filtered_rx) * 100.0 / filtered_rx;
+                } else {
+                    /* Loss case: less filtered TX than filtered RX */
+                    rate = (double)(filtered_rx - filtered_tx) * 100.0 / filtered_rx;
+                }
+            } else if (filtered_tx > 0) {
+                /* Only filtered TX, no filtered RX - show as 0% since no reference */
+                rate = 0.0;
+            }
+
+            printf("%-8u %-12" PRIu64 " %-12" PRIu64 " %-10.1f %-10.1f %-8.1f\n",
+                lcore_id,
+                lcore_stats[lcore_id].filtered_rx_packets,
+                lcore_stats[lcore_id].filtered_tx_packets,
+                rx_rate / 1000000.0,  /* Convert to Mpps */
+                tx_rate / 1000000.0,
+                rate);
+
+            total_rx += lcore_stats[lcore_id].filtered_rx_packets;
+            total_tx += lcore_stats[lcore_id].filtered_tx_packets;
+        }
+    }
+
+    /* Calculate total excluded packets (unwanted traffic like DHCP) */
+    uint64_t total_raw_rx = 0, total_raw_tx = 0, total_excluded_rx = 0, total_excluded_tx = 0;
+    RTE_LCORE_FOREACH(lcore_id) {
+        if (lcore_stats[lcore_id].start_time > 0) {
+            total_raw_rx += lcore_stats[lcore_id].rx_packets;
+            total_raw_tx += lcore_stats[lcore_id].tx_packets;
+        }
+    }
+    total_excluded_rx = total_raw_rx - total_rx;
+    total_excluded_tx = total_raw_tx - total_tx;
+
+    /* Calculate loss/amplification rate properly */
+    int64_t difference = (int64_t)total_tx - (int64_t)total_rx;  /* TX - RX */
+    double rate = 0.0;
+    const char *rate_type = "";
+
+    if (total_rx > 0) {
+        if (difference > 0) {
+            /* More TX than RX - amplification */
+            rate = (double)difference * 100.0 / total_rx;
+            rate_type = "amplification";
+        } else if (difference < 0) {
+            /* More RX than TX - loss */
+            rate = (double)(-difference) * 100.0 / total_rx;
+            rate_type = "loss";
+        } else {
+            /* Perfect match */
+            rate = 0.0;
+            rate_type = "perfect";
+        }
+    }
+
+    printf("%-8s %-12s %-12s %-10s %-10s %-8s\n",
+        "-----", "----------", "----------", "--------", "--------", "------");
+    printf("%-8s %-12" PRIu64 " %-12" PRIu64 " %-10s %-10s %-8.1f\n",
+        "Total", total_rx, total_tx, "", "", rate);
+    printf("=====================================\n");
+    printf("ANALYSIS: RX/TX difference = %+" PRId64 " packets (%.1f%% %s)\n",
+        difference, rate, rate_type);
+
+    printf("FILTERING: %" PRIu64 " RX + %" PRIu64 " TX unwanted packets excluded from counting\n",
+        total_excluded_rx, total_excluded_tx);
+    // if (total_raw_rx > 0 && total_raw_tx > 0) {
+    //     printf("           (%.1f%% of total RX, %.1f%% of total TX)\n",
+    //         (double)total_excluded_rx * 100.0 / total_raw_rx,
+    //         (double)total_excluded_tx * 100.0 / total_raw_tx);
+    // }
+    printf("=====================================\n");
+
+    /* Print NIC hardware statistics */
+    print_all_nic_hw_stats();
+
+    /* Print RX drop analysis */
+    print_rx_drop_analysis();
+}
+
+/**
+ * print_nic_hw_stats - Print NIC hardware statistics for a specific port
+ *
+ * DESCRIPTION
+ * Print detailed NIC hardware statistics including drops, errors, and buffer states
+ *
+ * RETURNS: N/A
+ */
+void
+print_nic_hw_stats(uint16_t port_id)
+{
+    struct rte_eth_stats eth_stats;
+    struct rte_eth_xstat *xstats = NULL;
+    struct rte_eth_xstat_name *xstat_names = NULL;
+    int cnt_xstats, ret, i;
+
+    printf("\n=== NIC Hardware Statistics (Port %u) ===\n", port_id);
+
+    /* Get basic ethernet statistics */
+    ret = rte_eth_stats_get(port_id, &eth_stats);
+    if (ret == 0) {
+        printf("Hardware RX Packets:     %"PRIu64"\n", eth_stats.ipackets);
+        printf("Hardware TX Packets:     %"PRIu64"\n", eth_stats.opackets);
+        printf("Hardware RX Bytes:       %"PRIu64"\n", eth_stats.ibytes);
+        printf("Hardware TX Bytes:       %"PRIu64"\n", eth_stats.obytes);
+        printf("Hardware RX Errors:      %"PRIu64"\n", eth_stats.ierrors);
+        printf("Hardware TX Errors:      %"PRIu64"\n", eth_stats.oerrors);
+        printf("Hardware RX Missed:      %"PRIu64" (packets dropped by HW)\n", eth_stats.imissed);
+        printf("Hardware RX No MBuf:     %"PRIu64" (mbuf allocation failed)\n", eth_stats.rx_nombuf);
+
+        /* Print per-queue statistics if available */
+        bool has_queue_stats = false;
+        for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS && i < 8; i++) {
+            if (eth_stats.q_ipackets[i] > 0 || eth_stats.q_opackets[i] > 0 || eth_stats.q_errors[i] > 0) {
+                if (!has_queue_stats) {
+                    printf("\nPer-Queue Statistics:\n");
+                    has_queue_stats = true;
+                }
+                printf("  Queue %d: RX=%"PRIu64", TX=%"PRIu64", Errors=%"PRIu64"\n",
+                    i, eth_stats.q_ipackets[i], eth_stats.q_opackets[i], eth_stats.q_errors[i]);
+            }
+        }
+
+        /* Calculate packet loss if any */
+        if (eth_stats.ipackets > 0) {
+            uint64_t total_drops = eth_stats.imissed + eth_stats.rx_nombuf + eth_stats.ierrors;
+            if (total_drops > 0) {
+                double drop_rate = (double)total_drops * 100.0 / (eth_stats.ipackets + total_drops);
+                printf("\nPacket Loss Analysis:\n");
+                printf("  Total Drops:           %"PRIu64"\n", total_drops);
+                printf("  Drop Rate:             %.2f%%\n", drop_rate);
+                printf("  Primary Drop Cause:    ");
+                if (eth_stats.imissed > eth_stats.rx_nombuf && eth_stats.imissed > eth_stats.ierrors) {
+                    printf("HW Ring Full (imissed)\n");
+                } else if (eth_stats.rx_nombuf > eth_stats.ierrors) {
+                    printf("No MBuf Available\n");
+                } else if (eth_stats.ierrors > 0) {
+                    printf("HW Errors\n");
+                } else {
+                    printf("Unknown\n");
+                }
+            }
+        }
+    } else {
+        printf("Failed to get basic statistics for port %u\n", port_id);
+    }
+
+    /* Get extended statistics for detailed drop analysis */
+    cnt_xstats = rte_eth_xstats_get_names(port_id, NULL, 0);
+    if (cnt_xstats > 0) {
+        xstat_names = malloc(sizeof(struct rte_eth_xstat_name) * cnt_xstats);
+        xstats = malloc(sizeof(struct rte_eth_xstat) * cnt_xstats);
+
+        if (xstat_names && xstats) {
+            ret = rte_eth_xstats_get_names(port_id, xstat_names, cnt_xstats);
+            if (ret == cnt_xstats) {
+                ret = rte_eth_xstats_get(port_id, xstats, cnt_xstats);
+                if (ret == cnt_xstats) {
+                    printf("\nDetailed Drop/Error Statistics:\n");
+                    bool found_drops = false;
+                    for (i = 0; i < cnt_xstats; i++) {
+                        const char *name = xstat_names[i].name;
+                        uint64_t value = xstats[i].value;
+
+                        /* Filter for drop/error related statistics */
+                        if (value > 0 && (strstr(name, "drop") || strstr(name, "discard") ||
+                                         strstr(name, "error") || strstr(name, "miss") ||
+                                         strstr(name, "full") || strstr(name, "overflow") ||
+                                         strstr(name, "underrun") || strstr(name, "crc") ||
+                                         strstr(name, "fragment") || strstr(name, "jabber"))) {
+                            printf("  %-30s: %"PRIu64"\n", name, value);
+                            found_drops = true;
+                        }
+                    }
+                    if (!found_drops) {
+                        printf("  No drop/error statistics found\n");
+                    }
+                }
+            }
+        }
+
+        free(xstat_names);
+        free(xstats);
+    }
+    printf("==========================================\n");
+}
+
+/**
+ * print_all_nic_hw_stats - Print NIC hardware statistics for all active ports
+ *
+ * DESCRIPTION
+ * Print NIC hardware statistics for all ports currently in use by pktgen
+ *
+ * RETURNS: N/A
+ */
+void
+print_all_nic_hw_stats(void)
+{
+    uint16_t port_id;
+    port_info_t *pinfo;
+
+    printf("\n");
+    printf("########################################\n");
+    printf("# NIC HARDWARE STATISTICS ANALYSIS\n");
+    printf("########################################\n");
+
+    RTE_ETH_FOREACH_DEV(port_id) {
+        pinfo = l2p_get_port_pinfo(port_id);
+        if (pinfo && pinfo->seq_pkt) {
+            print_nic_hw_stats(port_id);
+        }
+    }
+
+    printf("########################################\n");
+}
+
+/**
+ * init_rx_drop_analysis - Initialize RX drop analysis for a core
+ */
+void
+init_rx_drop_analysis(unsigned int lcore_id)
+{
+    rx_drop_analysis_t *analysis = &rx_analysis[lcore_id];
+
+    memset(analysis, 0, sizeof(rx_drop_analysis_t));
+    analysis->analysis_interval = rte_get_tsc_hz(); /* 1 second interval */
+    analysis->last_check_time = rte_rdtsc();
+
+    AK_DEBUG_LOG_LINE(DEBUG, "RX Drop Analysis initialized for lcore %u", lcore_id);
+}
+
+/**
+ * analyze_rx_performance - Analyze RX performance and detect issues
+ */
+void
+analyze_rx_performance(unsigned int lcore_id, uint16_t port_id, uint16_t nb_rx, uint16_t expected_rx)
+{
+    rx_drop_analysis_t *analysis = &rx_analysis[lcore_id];
+    uint64_t current_time = rte_rdtsc();
+
+    /* Update counters */
+    analysis->total_rx_attempts++;
+
+    if (nb_rx == 0) {
+        analysis->zero_rx_count++;
+        /* Log frequent zero RX events */
+#ifdef RTE_LIBRTE_ETHDEV_DEBUG
+        // if (analysis->zero_rx_count % 10000 == 0) {
+        //     printf("DEBUG: Lcore %u - %lu consecutive zero RX events\n",
+        //            lcore_id, analysis->zero_rx_count);
+        // }
+#endif
+    } else if (nb_rx < expected_rx / 2) {
+        analysis->small_rx_count++;
+    } else if (nb_rx == expected_rx) {
+        analysis->full_rx_count++;
+    }
+
+    /* Periodic detailed analysis */
+    if (current_time - analysis->last_check_time > analysis->analysis_interval) {
+        struct rte_eth_stats eth_stats;
+
+        if (rte_eth_stats_get(port_id, &eth_stats) == 0) {
+            /* Use port-level HW drops but only show on first RX core to avoid duplication */
+            static uint64_t initial_port_hw_drops = 0;
+            static unsigned int first_rx_core = RTE_MAX_LCORE;
+            static bool first_measurement = true;
+
+            /* Determine the first RX core for this port */
+            if (first_rx_core == RTE_MAX_LCORE) {
+                first_rx_core = lcore_id;
+            }
+
+            if (lcore_id == first_rx_core) {
+                /* Only the first RX core tracks port-level HW drops */
+                uint64_t hw_drops_current = eth_stats.imissed + eth_stats.rx_nombuf + eth_stats.ierrors;
+
+                if (first_measurement) {
+                    initial_port_hw_drops = hw_drops_current;
+                    analysis->hw_drops_delta = 0;
+                    first_measurement = false;
+                } else {
+                    /* Show total drops since test started */
+                    analysis->hw_drops_delta = hw_drops_current - initial_port_hw_drops;
+                }
+            } else {
+                /* Other cores show 0 to avoid duplication */
+                analysis->hw_drops_delta = 0;
+            }
+
+#ifdef RTE_LIBRTE_ETHDEV_DEBUG
+            /* Log significant drop events */
+            if (analysis->hw_drops_delta > 1000) {
+                AK_DEBUG_LOG_LINE(DEBUG, "Lcore %u Port %u - %lu total HW drops since start!",
+                                 lcore_id, port_id, analysis->hw_drops_delta);
+                AK_DEBUG_LOG_LINE(DEBUG, "  Zero RX: %lu, Small RX: %lu, Full RX: %lu",
+                                 analysis->zero_rx_count, analysis->small_rx_count, analysis->full_rx_count);
+                AK_DEBUG_LOG_LINE(DEBUG, "  RX Missed: %lu, No MBuf: %lu, Errors: %lu",
+                                 eth_stats.imissed, eth_stats.rx_nombuf, eth_stats.ierrors);
+            }
+#endif
+        }
+
+        analysis->last_check_time = current_time;
+        /* Reset counters for next interval */
+        analysis->zero_rx_count = 0;
+        analysis->small_rx_count = 0;
+        analysis->full_rx_count = 0;
+    }
+}
+
+/**
+ * print_rx_drop_analysis - Print comprehensive RX drop analysis
+ */
+void
+print_rx_drop_analysis(void)
+{
+    unsigned int lcore_id;
+
+    printf("\n");
+    printf("########################################\n");
+    printf("# RX DROP ANALYSIS REPORT\n");
+    printf("########################################\n");
+
+    printf("%-8s %-12s %-12s %-12s %-12s\n",
+           "Lcore", "RX Attempts", "Zero RX", "Small RX", "Full RX");
+    printf("%-8s %-12s %-12s %-12s %-12s\n",
+           "-----", "-----------", "--------", "---------", "--------");
+
+    /* Get current HW drops for accurate final measurement */
+    struct rte_eth_stats eth_stats;
+
+    if (rte_eth_stats_get(0, &eth_stats) == 0) {
+        /* HW stats available but not displayed in this table */
+    }
+
+    RTE_LCORE_FOREACH(lcore_id) {
+        rx_drop_analysis_t *analysis = &rx_analysis[lcore_id];
+
+        if (analysis->total_rx_attempts > 0) {
+            printf("%-8u %-12lu %-12lu %-12lu %-12lu\n",
+                   lcore_id,
+                   analysis->total_rx_attempts,
+                   analysis->zero_rx_count,
+                   analysis->small_rx_count,
+                   analysis->full_rx_count);
+        }
+    }
+
+    printf("########################################\n");
+}
diff --git a/app/pktgen.h b/app/pktgen.h
index 5349a31..cac8ecb 100644
--- a/app/pktgen.h
+++ b/app/pktgen.h
@@ -41,6 +41,7 @@
 
 #include <rte_errno.h>
 #include <rte_log.h>
+#include "../../ak_debug_log.h"
 #include <rte_tailq.h>
 #include <rte_common.h>
 #include <rte_memory.h>
@@ -103,6 +104,9 @@
 extern "C" {
 #endif
 
+static volatile bool stats_enabled = true;
+
+
 #define MAX_MATRIX_ENTRIES 128
 #define MAX_STRING         256
 #define Million            (uint64_t)(1000000UL)
@@ -351,6 +355,7 @@ void pktgen_input_start(void);
 void stat_timer_dump(void);
 void stat_timer_clear(void);
 void pktgen_timer_setup(void);
+void print_pktgen_stats_summary(void);
 double next_poisson_time(double rateParameter);
 
 void pktgen_setup_packets(uint16_t pid);
diff --git a/app/pktgen_pcm.c b/app/pktgen_pcm.c
new file mode 100644
index 0000000..f7f981c
--- /dev/null
+++ b/app/pktgen_pcm.c
@@ -0,0 +1,583 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2010-2025 Intel Corporation
+ */
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#include "pktgen_pcm.h"
+#include "pktgen_pcm_wrapper.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <math.h>
+#include <dlfcn.h>
+#include <rte_common.h>
+#include <rte_lcore.h>
+#include <rte_cycles.h>
+#include <rte_log.h>
+
+/* Global PCM state */
+static struct pcm_global_state {
+    bool pcm_initialized;
+    bool monitoring_enabled;
+    bool use_static_wrapper;
+    uint32_t num_lcores;
+    double sampling_interval;
+    struct pcm_lcore_state lcore_states[PCM_MAX_LCORES];
+    struct pcm_core_metrics core_metrics[PCM_MAX_LCORES];
+    struct pcm_memory_metrics memory_metrics[PCM_MAX_SOCKETS];
+    struct pcm_io_metrics io_metrics[PCM_MAX_SOCKETS];
+    struct pcm_system_metrics system_metrics;
+    uint64_t start_timestamp;
+    uint64_t last_measurement_timestamp;
+} g_pcm_state = {0};
+
+/* Helper macros */
+#define PCM_LOG(level, fmt, args...) \
+    rte_log(RTE_LOG_ ## level, RTE_LOGTYPE_USER1, "[PCM] " fmt "\n", ##args)
+
+#define NSEC_PER_SEC 1000000000ULL
+#define USEC_PER_SEC 1000000ULL
+
+/* Utility functions */
+static uint64_t get_timestamp_ns(void)
+{
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    return ts.tv_sec * NSEC_PER_SEC + ts.tv_nsec;
+}
+
+/* Core PCM monitoring functions */
+int pcm_monitoring_init(void)
+{
+    if (g_pcm_state.pcm_initialized) {
+        PCM_LOG(WARNING, "PCM monitoring already initialized");
+        return 0;
+    }
+
+    /* Check if PCM is disabled via environment variable */
+    if (getenv("PCM_DISABLED")) {
+        printf("DEBUG: PCM monitoring disabled by PCM_DISABLED environment variable\n");
+        return -1;
+    }
+
+    /* Try static PCM wrapper */
+    if (pcm_wrapper_is_available()) {
+        if (pcm_wrapper_init() == 0) {
+
+            /* Initialize global state for static wrapper */
+            memset(&g_pcm_state, 0, sizeof(g_pcm_state));
+            g_pcm_state.pcm_initialized = true;
+            g_pcm_state.monitoring_enabled = true;
+            g_pcm_state.num_lcores = rte_lcore_count();
+            g_pcm_state.sampling_interval = 1.0;
+            g_pcm_state.use_static_wrapper = true; /* Flag to indicate static wrapper usage */
+
+            /* Validate initialization parameters */
+            if (g_pcm_state.num_lcores == 0 || g_pcm_state.num_lcores > RTE_MAX_LCORE) {
+                printf("DEBUG: WARNING - Suspicious lcore count %u detected\n", g_pcm_state.num_lcores);
+            }
+
+            /* Initialize per-lcore states */
+            uint32_t lcore_id;
+            RTE_LCORE_FOREACH(lcore_id) {
+                struct pcm_lcore_state *state = &g_pcm_state.lcore_states[lcore_id];
+                state->lcore_id = lcore_id;
+                state->socket_id = rte_lcore_to_socket_id(lcore_id);
+                state->initialized = true;
+                state->monitoring_active = false;
+            }
+
+            /* Get and display system information */
+            char sys_info[1024];
+            if (pcm_wrapper_get_system_info(sys_info, sizeof(sys_info)) == 0) {
+                printf("=== PCM System Information ===\n%s=== End PCM System Info ===\n", sys_info);
+            }
+
+            PCM_LOG(INFO, "PCM monitoring initialized successfully with static wrapper for %u lcores",
+                    g_pcm_state.num_lcores);
+            return 0;
+        } else {
+            printf("ERROR: Static PCM wrapper initialization failed\n");
+        }
+    } else {
+        printf("ERROR: Static PCM wrapper not available\n");
+    }
+
+    /* If static wrapper failed, return error (no fallback to dynamic loading to avoid GLIBCXX issues) */
+    PCM_LOG(ERR, "Failed to initialize PCM monitoring (static wrapper not available or failed)");
+    return -1;
+}
+
+void pcm_monitoring_cleanup(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    /* Stop monitoring on all active lcores */
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        if (g_pcm_state.lcore_states[lcore_id].monitoring_active) {
+            pcm_monitoring_stop_lcore(lcore_id);
+        }
+    }
+
+    /* Cleanup PCM */
+    if (g_pcm_state.use_static_wrapper) {
+        pcm_wrapper_cleanup();
+    }
+
+    /* Reset global state */
+    memset(&g_pcm_state, 0, sizeof(g_pcm_state));
+
+    PCM_LOG(INFO, "PCM monitoring cleanup completed");
+}
+
+int pcm_monitoring_start_all(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        PCM_LOG(ERR, "PCM not initialized");
+        return -1;
+    }
+
+    /* Start measurement period in PCM wrapper */
+    if (g_pcm_state.use_static_wrapper) {
+        if (pcm_wrapper_start_measurement() != 0) {
+            PCM_LOG(ERR, "Failed to start PCM measurement");
+            return -1;
+        }
+    }
+
+    g_pcm_state.start_timestamp = get_timestamp_ns();
+
+    /* Start monitoring on all available lcores */
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        pcm_monitoring_start_lcore(lcore_id);
+    }
+
+    printf("Starting PCM monitoring on all lcores...\n");
+    return 0;
+}
+
+int pcm_monitoring_stop_all(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return -1;
+    }
+
+    /* Stop measurement period in PCM wrapper */
+    if (g_pcm_state.use_static_wrapper) {
+        if (pcm_wrapper_stop_measurement() != 0) {
+            PCM_LOG(ERR, "Failed to stop PCM measurement");
+            return -1;
+        }
+    }
+
+    /* Stop monitoring on all lcores */
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        pcm_monitoring_stop_lcore(lcore_id);
+    }
+
+    printf("Stopped PCM monitoring on all lcores\n");
+    return 0;
+}
+
+int pcm_monitoring_start_lcore(uint32_t lcore_id)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return -1;
+    }
+
+    if (lcore_id >= RTE_MAX_LCORE) {
+        PCM_LOG(ERR, "Invalid lcore ID: %u", lcore_id);
+        return -1;
+    }
+
+    struct pcm_lcore_state *state = &g_pcm_state.lcore_states[lcore_id];
+
+    if (!state->initialized) {
+        PCM_LOG(ERR, "Lcore %u not initialized", lcore_id);
+        return -1;
+    }
+
+    if (state->monitoring_active) {
+        PCM_LOG(WARNING, "Monitoring already active on lcore %u", lcore_id);
+        return 0;
+    }
+
+    state->monitoring_active = true;
+    PCM_LOG(INFO, "Started monitoring on lcore %u", lcore_id);
+    return 0;
+}
+
+int pcm_monitoring_stop_lcore(uint32_t lcore_id)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return -1;
+    }
+
+    if (lcore_id >= RTE_MAX_LCORE) {
+        return -1;
+    }
+
+    struct pcm_lcore_state *state = &g_pcm_state.lcore_states[lcore_id];
+
+    if (!state->monitoring_active) {
+        return 0;
+    }
+
+    state->monitoring_active = false;
+    PCM_LOG(INFO, "Stopped monitoring on lcore %u", lcore_id);
+    return 0;
+}
+
+int pcm_monitoring_measure_all(void)
+{
+    if (!g_pcm_state.pcm_initialized || !g_pcm_state.use_static_wrapper) {
+        return -1;
+    }
+
+    uint64_t timestamp = get_timestamp_ns();
+    uint32_t lcore_id;
+
+    /* Collect core metrics for all active lcores */
+    RTE_LCORE_FOREACH(lcore_id) {
+        /* Always collect metrics for all lcores that were initialized,
+         * regardless of monitoring_active flag since stop_all() resets it */
+        if (g_pcm_state.lcore_states[lcore_id].initialized) {
+            struct pcm_core_metrics *metrics = &g_pcm_state.core_metrics[lcore_id];
+            pcm_core_counters_t counters;
+
+            if (pcm_wrapper_get_core_counters(lcore_id, &counters) == 0) {
+                metrics->cycles = counters.cycles;
+                metrics->instructions = counters.instructions;
+                metrics->l2_cache_hits = counters.l2_cache_hits;
+                metrics->l2_cache_misses = counters.l2_cache_misses;
+                metrics->l3_cache_hits = counters.l3_cache_hits;
+                metrics->l3_cache_misses = counters.l3_cache_misses;
+                metrics->ipc = counters.ipc;
+                metrics->l2_cache_hit_ratio = counters.l2_cache_hit_ratio;
+                metrics->l3_cache_hit_ratio = counters.l3_cache_hit_ratio;
+                metrics->frequency_ghz = counters.frequency_ghz;
+                metrics->cpu_utilization = counters.cpu_utilization;
+                metrics->energy_joules = counters.energy_joules;
+                metrics->timestamp = timestamp;
+
+                /* Check for measurement anomalies */
+                if (counters.ipc > 5.0) {
+                    printf("DEBUG: WARNING - Very high IPC %.2f detected on lcore %u\n", counters.ipc, lcore_id);
+                }
+                if (counters.cycles > 0 && counters.instructions == 0) {
+                    printf("DEBUG: WARNING - Zero instructions with non-zero cycles on lcore %u\n", lcore_id);
+                }
+            } else {
+                printf("WARNING: Failed to get counters for lcore %u\n", lcore_id);
+            }
+        }
+    }
+
+    /* Collect memory metrics for all sockets */
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_memory_metrics *metrics = &g_pcm_state.memory_metrics[socket];
+        pcm_memory_counters_t counters;
+
+        if (pcm_wrapper_get_memory_counters(socket, &counters) == 0) {
+            metrics->dram_read_bytes = counters.dram_read_bytes;
+            metrics->dram_write_bytes = counters.dram_write_bytes;
+            metrics->memory_controller_read_bw_mbps = counters.memory_controller_read_bw_mbps;
+            metrics->memory_controller_write_bw_mbps = counters.memory_controller_write_bw_mbps;
+            metrics->memory_controller_bw_mbps = counters.memory_controller_bw_mbps;
+            metrics->timestamp = timestamp;
+        }
+    }
+
+    /* Collect I/O metrics for all sockets */
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_io_metrics *metrics = &g_pcm_state.io_metrics[socket];
+        pcm_io_counters_t counters;
+
+        if (pcm_wrapper_get_io_counters(socket, &counters) == 0) {
+            metrics->pcie_read_bytes = counters.pcie_read_bytes;
+            metrics->pcie_write_bytes = counters.pcie_write_bytes;
+            metrics->pcie_read_bandwidth_mbps = counters.pcie_read_bandwidth_mbps;
+            metrics->pcie_write_bandwidth_mbps = counters.pcie_write_bandwidth_mbps;
+            metrics->qpi_upi_data_bytes = counters.qpi_upi_data_bytes;
+            metrics->qpi_upi_utilization = counters.qpi_upi_utilization;
+            metrics->uncore_freq_ghz = counters.uncore_freq_ghz;
+            metrics->imc_reads_gbps = counters.imc_reads_gbps;
+            metrics->imc_writes_gbps = counters.imc_writes_gbps;
+            metrics->timestamp = timestamp;
+        }
+    }
+
+    /* Collect system-wide metrics */
+    pcm_system_counters_t sys_counters;
+    if (pcm_wrapper_get_system_counters(&sys_counters) == 0) {
+        struct pcm_system_metrics *metrics = &g_pcm_state.system_metrics;
+        metrics->active_cores = sys_counters.active_cores;
+        metrics->total_energy_joules = sys_counters.total_energy_joules;
+        metrics->package_energy_joules = sys_counters.package_energy_joules;
+        metrics->dram_energy_joules = sys_counters.dram_energy_joules;
+        metrics->total_ipc = sys_counters.total_ipc;
+        metrics->memory_bandwidth_utilization = sys_counters.memory_bandwidth_utilization;
+        metrics->thermal_throttle_ratio = sys_counters.thermal_throttle_ratio;
+        metrics->timestamp = timestamp;
+    }
+
+    g_pcm_state.last_measurement_timestamp = timestamp;
+    return 0;
+}
+
+/* Enhanced statistics display functions */
+void pcm_print_core_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    /* Calculate measurement duration in microseconds */
+    uint64_t duration_us = 0;
+    if (g_pcm_state.last_measurement_timestamp > g_pcm_state.start_timestamp) {
+        duration_us = (g_pcm_state.last_measurement_timestamp - g_pcm_state.start_timestamp) / 1000;
+    }
+
+    printf("\n=====================================\n");
+    printf("Intel PCM Core Performance Statistics (%lu us)\n", duration_us);
+    printf("=====================================\n");
+    printf("%-5s %-12s %-12s %-6s %-10s %-8s %-8s %-6s %-6s %-8s\n",
+           "Core", "Cycles", "Instructions", "IPC", "L3 Misses", "L2 Hit%", "L3 Hit%", "Freq", "CPU%", "Energy");
+    printf("%-5s %-12s %-12s %-6s %-10s %-8s %-8s %-6s %-6s %-8s\n",
+           "----", "----------", "----------", "----", "---------", "------", "------", "----", "----", "------");
+
+    uint64_t total_cycles = 0, total_instructions = 0, total_l3_misses = 0;
+    double total_energy = 0.0;
+    uint32_t active_cores = 0;
+
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        /* Check if lcore was initialized and has valid metrics */
+        if (g_pcm_state.lcore_states[lcore_id].initialized &&
+            (g_pcm_state.core_metrics[lcore_id].cycles > 0 || g_pcm_state.core_metrics[lcore_id].instructions > 0)) {
+            struct pcm_core_metrics *metrics = &g_pcm_state.core_metrics[lcore_id];
+
+            printf("%-5u %-12lu %-12lu %-6.2f %-10lu %-8.1f %-8.1f %-6.2f %-6.1f %-8.2f\n",
+                   lcore_id,
+                   metrics->cycles,
+                   metrics->instructions,
+                   metrics->ipc,
+                   metrics->l3_cache_misses,
+                   metrics->l2_cache_hit_ratio * 100.0,
+                   metrics->l3_cache_hit_ratio * 100.0,
+                   metrics->frequency_ghz,
+                   metrics->cpu_utilization * 100.0,
+                   metrics->energy_joules);
+
+            total_cycles += metrics->cycles;
+            total_instructions += metrics->instructions;
+            total_l3_misses += metrics->l3_cache_misses;
+            total_energy += metrics->energy_joules;
+            active_cores++;
+        }
+    }
+
+    printf("%-5s %-12s %-12s %-6s %-10s %-8s %-8s %-6s %-6s %-8s\n",
+           "----", "----------", "----------", "----", "---------", "------", "------", "----", "----", "------");
+
+    double avg_ipc = total_cycles > 0 ? (double)total_instructions / total_cycles : 0.0;
+    printf("%-5s %-12lu %-12lu %-6.2f %-10lu %-8s %-8s %-6s %-6s %-8.2f\n",
+           "Total", total_cycles, total_instructions, avg_ipc, total_l3_misses,
+           "-", "-", "-", "-", total_energy);
+
+    printf("Active Cores: %u\n", active_cores);
+    printf("=====================================\n");
+}
+
+void pcm_print_memory_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    /* Calculate measurement duration in microseconds */
+    uint64_t duration_us = 0;
+    if (g_pcm_state.last_measurement_timestamp > g_pcm_state.start_timestamp) {
+        duration_us = (g_pcm_state.last_measurement_timestamp - g_pcm_state.start_timestamp) / 1000;
+    }
+
+    printf("\n=====================================\n");
+    printf("Intel PCM Memory Performance Statistics (%lu us)\n", duration_us);
+    printf("=====================================\n");
+    printf("%-6s %-12s %-12s %-12s %-12s %-12s\n",
+           "Socket", "DRAM Read", "DRAM Write", "MC Read BW", "MC Write BW", "MC Total BW");
+    printf("%-6s %-12s %-12s %-12s %-12s %-12s\n",
+           "------", "----------", "-----------", "----------", "-----------", "-----------");
+
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_memory_metrics *metrics = &g_pcm_state.memory_metrics[socket];
+
+        if (metrics->timestamp > 0) {
+            printf("%-6u %-12lu %-12lu %-12.1f %-12.1f %-12.1f\n",
+                   socket,
+                   metrics->dram_read_bytes,
+                   metrics->dram_write_bytes,
+                   metrics->memory_controller_read_bw_mbps,
+                   metrics->memory_controller_write_bw_mbps,
+                   metrics->memory_controller_bw_mbps);
+        }
+    }
+    printf("=====================================\n");
+}
+
+void pcm_print_io_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    /* Calculate measurement duration in microseconds */
+    uint64_t duration_us = 0;
+    if (g_pcm_state.last_measurement_timestamp > g_pcm_state.start_timestamp) {
+        duration_us = (g_pcm_state.last_measurement_timestamp - g_pcm_state.start_timestamp) / 1000;
+    }
+
+    printf("\n=====================================\n");
+    printf("Intel PCM I/O Performance Statistics (%lu us)\n", duration_us);
+    printf("=====================================\n");
+    printf("%-6s %-12s %-12s %-10s %-10s %-8s\n",
+           "Socket", "PCIe Read", "PCIe Write", "PCIe R BW", "PCIe W BW", "UPI Util%");
+    printf("%-6s %-12s %-12s %-10s %-10s %-8s\n",
+           "------", "----------", "-----------", "---------", "---------", "---------");
+
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_io_metrics *metrics = &g_pcm_state.io_metrics[socket];
+
+        if (metrics->timestamp > 0) {
+            printf("%-6u %-12lu %-12lu %-10.1f %-10.1f %-9.1f\n",
+                   socket,
+                   metrics->pcie_read_bytes,
+                   metrics->pcie_write_bytes,
+                   metrics->pcie_read_bandwidth_mbps,
+                   metrics->pcie_write_bandwidth_mbps,
+                   metrics->qpi_upi_utilization * 100.0);
+        }
+    }
+    printf("=====================================\n");
+}
+
+void pcm_print_system_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    struct pcm_system_metrics *metrics = &g_pcm_state.system_metrics;
+
+    /* Calculate measurement duration in microseconds */
+    uint64_t duration_us = 0;
+    if (g_pcm_state.last_measurement_timestamp > g_pcm_state.start_timestamp) {
+        duration_us = (g_pcm_state.last_measurement_timestamp - g_pcm_state.start_timestamp) / 1000;
+    }
+
+    printf("\n=====================================\n");
+    printf("Intel PCM System-Wide Statistics (%lu us)\n", duration_us);
+    printf("=====================================\n");
+    printf("Active Cores: %u\n", metrics->active_cores);
+    printf("Total IPC: %.2f\n", metrics->total_ipc);
+    printf("Total Energy: %.2f J\n", metrics->total_energy_joules);
+    printf("Package Energy: %.2f J\n", metrics->package_energy_joules);
+    printf("DRAM Energy: %.2f J\n", metrics->dram_energy_joules);
+    printf("Memory BW Utilization: %.1f%%\n", metrics->memory_bandwidth_utilization * 100.0);
+    printf("Thermal Throttle Ratio: %.1f%%\n", metrics->thermal_throttle_ratio * 100.0);
+    printf("=====================================\n");
+}
+
+/* Additional utility functions */
+
+bool pcm_monitoring_is_available(void)
+{
+    return g_pcm_state.pcm_initialized;
+}
+
+int pcm_monitoring_get_lcore_metrics(uint32_t lcore_id, struct pcm_core_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics || lcore_id >= RTE_MAX_LCORE) {
+        return -1;
+    }
+
+    if (!g_pcm_state.lcore_states[lcore_id].monitoring_active) {
+        return -1;
+    }
+
+    *metrics = g_pcm_state.core_metrics[lcore_id];
+    return 0;
+}
+
+int pcm_monitoring_get_memory_metrics(uint32_t socket_id, struct pcm_memory_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics || socket_id >= PCM_MAX_SOCKETS) {
+        return -1;
+    }
+
+    *metrics = g_pcm_state.memory_metrics[socket_id];
+    return 0;
+}
+
+int pcm_monitoring_get_io_metrics(uint32_t socket_id, struct pcm_io_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics || socket_id >= PCM_MAX_SOCKETS) {
+        return -1;
+    }
+
+    *metrics = g_pcm_state.io_metrics[socket_id];
+    return 0;
+}
+
+int pcm_monitoring_get_system_metrics(struct pcm_system_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics) {
+        return -1;
+    }
+
+    *metrics = g_pcm_state.system_metrics;
+    return 0;
+}
+
+void pcm_monitoring_print_summary(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        printf("PCM monitoring not available\n");
+        return;
+    }
+
+    printf("\n=== COMPREHENSIVE PCM PERFORMANCE SUMMARY ===\n");
+    pcm_print_core_statistics();
+    pcm_print_memory_statistics();
+    pcm_print_io_statistics();
+    pcm_print_system_statistics();
+    printf("=== END PCM PERFORMANCE SUMMARY ===\n");
+}
+
+int pcm_monitoring_get_info(char *info_buffer, size_t buffer_size)
+{
+    if (!info_buffer || buffer_size == 0) {
+        return -1;
+    }
+
+    if (!g_pcm_state.pcm_initialized) {
+        snprintf(info_buffer, buffer_size, "PCM monitoring not initialized");
+        return -1;
+    }
+
+    if (g_pcm_state.use_static_wrapper) {
+        return pcm_wrapper_get_system_info(info_buffer, buffer_size);
+    } else {
+        snprintf(info_buffer, buffer_size, "PCM monitoring active (fallback mode)");
+        return 0;
+    }
+}
diff --git a/app/pktgen_pcm.h b/app/pktgen_pcm.h
new file mode 100644
index 0000000..3e29a94
--- /dev/null
+++ b/app/pktgen_pcm.h
@@ -0,0 +1,195 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2010-2025 Intel Corporation
+ */
+
+#ifndef __PKTGEN_PCM_H__
+#define __PKTGEN_PCM_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <rte_common.h>
+#include <rte_lcore.h>
+#include "pktgen_pcm_wrapper.h"
+
+/* Maximum number of performance events to track */
+#define PCM_MAX_EVENTS 16
+#define PCM_MAX_LCORES RTE_MAX_LCORE
+#define PCM_MAX_SOCKETS 8
+
+/* Enhanced performance metrics structure */
+struct pcm_core_metrics {
+    uint64_t instructions;          /* Instructions retired */
+    uint64_t cycles;                /* CPU cycles */
+    uint64_t l2_cache_hits;        /* L2 cache hits */
+    uint64_t l2_cache_misses;      /* L2 cache misses */
+    uint64_t l3_cache_hits;        /* L3 cache hits */
+    uint64_t l3_cache_misses;      /* L3 cache misses (LLC) */
+    double ipc;                    /* Instructions per cycle */
+    double l2_cache_hit_ratio;     /* L2 cache hit ratio */
+    double l3_cache_hit_ratio;     /* L3 cache hit ratio */
+    double frequency_ghz;          /* Core frequency in GHz */
+    double cpu_utilization;        /* CPU utilization percentage */
+    double energy_joules;          /* Energy consumption in Joules */
+    uint64_t timestamp;            /* Timestamp of measurement */
+};
+
+/* Memory performance metrics structure */
+struct pcm_memory_metrics {
+    uint64_t dram_read_bytes;      /* DRAM read bytes */
+    uint64_t dram_write_bytes;     /* DRAM write bytes */
+    double memory_controller_read_bw_mbps;  /* Memory controller read bandwidth MB/s */
+    double memory_controller_write_bw_mbps; /* Memory controller write bandwidth MB/s */
+    double memory_controller_bw_mbps;       /* Memory controller total bandwidth MB/s */
+    uint64_t timestamp;
+};
+
+/* I/O and uncore performance metrics structure */
+struct pcm_io_metrics {
+    uint64_t pcie_read_bytes;      /* PCIe read bytes */
+    uint64_t pcie_write_bytes;     /* PCIe write bytes */
+    double pcie_read_bandwidth_mbps;    /* PCIe read bandwidth MB/s */
+    double pcie_write_bandwidth_mbps;   /* PCIe write bandwidth MB/s */
+    uint64_t qpi_upi_data_bytes;       /* QPI/UPI data bytes */
+    double qpi_upi_utilization;        /* QPI/UPI utilization percentage */
+    uint64_t uncore_freq_ghz;          /* Uncore frequency GHz */
+    double imc_reads_gbps;             /* IMC reads GB/s */
+    double imc_writes_gbps;            /* IMC writes GB/s */
+    uint64_t timestamp;
+};
+
+/* System-wide PCM metrics */
+struct pcm_system_metrics {
+    uint32_t active_cores;              /* Number of active cores */
+    double total_energy_joules;         /* Total energy consumption */
+    double package_energy_joules;       /* Package energy consumption */
+    double dram_energy_joules;          /* DRAM energy consumption */
+    double total_ipc;                   /* System-wide IPC */
+    double memory_bandwidth_utilization; /* Memory bandwidth utilization % */
+    double thermal_throttle_ratio;      /* Thermal throttling ratio */
+    uint64_t timestamp;
+};
+
+/* Per-lcore PCM state */
+struct pcm_lcore_state {
+    uint32_t lcore_id;
+    uint32_t socket_id;
+    bool initialized;
+    bool monitoring_active;
+};
+
+/* Function declarations */
+
+/**
+ * Initialize PCM monitoring system
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_init(void);
+
+/**
+ * Cleanup PCM monitoring system
+ */
+void pcm_monitoring_cleanup(void);
+
+/**
+ * Start monitoring on a specific lcore
+ * @param lcore_id: The lcore to start monitoring
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_start_lcore(uint32_t lcore_id);
+
+/**
+ * Stop monitoring on a specific lcore
+ * @param lcore_id: The lcore to stop monitoring
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_stop_lcore(uint32_t lcore_id);
+
+/**
+ * Start monitoring on all active lcores
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_start_all(void);
+
+/**
+ * Stop monitoring on all active lcores
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_stop_all(void);
+
+/**
+ * Take measurements on all active lcores and collect comprehensive statistics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_measure_all(void);
+
+/**
+ * Check if PCM monitoring is available and initialized
+ * @return true if available, false otherwise
+ */
+bool pcm_monitoring_is_available(void);
+
+/**
+ * Get current core metrics for a specific lcore
+ * @param lcore_id: The lcore to query
+ * @param metrics: Pointer to store the core metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_lcore_metrics(uint32_t lcore_id, struct pcm_core_metrics *metrics);
+
+/**
+ * Get memory metrics for a specific socket
+ * @param socket_id: The socket to query
+ * @param metrics: Pointer to store the memory metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_memory_metrics(uint32_t socket_id, struct pcm_memory_metrics *metrics);
+
+/**
+ * Get I/O metrics for a specific socket
+ * @param socket_id: The socket to query
+ * @param metrics: Pointer to store the I/O metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_io_metrics(uint32_t socket_id, struct pcm_io_metrics *metrics);
+
+/**
+ * Get system-wide metrics
+ * @param metrics: Pointer to store the system metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_system_metrics(struct pcm_system_metrics *metrics);
+
+/**
+ * Print core performance statistics for all lcores
+ */
+void pcm_print_core_statistics(void);
+
+/**
+ * Print memory performance statistics for all sockets
+ */
+void pcm_print_memory_statistics(void);
+
+/**
+ * Print I/O performance statistics for all sockets
+ */
+void pcm_print_io_statistics(void);
+
+/**
+ * Print system-wide performance statistics
+ */
+void pcm_print_system_statistics(void);
+
+/**
+ * Print comprehensive performance summary (all categories)
+ */
+void pcm_monitoring_print_summary(void);
+
+/**
+ * Get PCM system information
+ * @param info_buffer: Buffer to store system info
+ * @param buffer_size: Size of the buffer
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_info(char *info_buffer, size_t buffer_size);
+
+#endif /* __PKTGEN_PCM_H__ */
diff --git a/app/pktgen_pcm_wrapper.cpp b/app/pktgen_pcm_wrapper.cpp
new file mode 100644
index 0000000..ebca0c0
--- /dev/null
+++ b/app/pktgen_pcm_wrapper.cpp
@@ -0,0 +1,750 @@
+// C++ wrapper for PCM that will be statically linked
+#include "pktgen_pcm_wrapper.h"
+#include <iostream>
+#include <memory>
+#include <cstdlib>
+#include <cstdio>
+#include <cstring>
+#include <unistd.h>
+
+// Intel PCM includes
+#include "cpucounters.h"
+
+using namespace pcm;
+
+extern "C" {
+
+// Global PCM state
+static PCM* g_pcm_instance = nullptr;
+static bool g_initialized = false;
+static bool g_measurement_active = false;
+
+// Counter state storage
+static std::vector<CoreCounterState> g_before_core_states;
+static std::vector<CoreCounterState> g_after_core_states;
+static std::vector<SocketCounterState> g_before_socket_states;
+static std::vector<SocketCounterState> g_after_socket_states;
+static SystemCounterState g_before_system_state;
+static SystemCounterState g_after_system_state;
+
+int pcm_wrapper_is_available(void) {
+    // Always return 1 for now, as PCM is statically linked
+    return 1;
+}
+
+int pcm_wrapper_init(void) {
+    if (g_initialized) {
+        return 0;  // Already initialized
+    }
+
+    g_pcm_instance = PCM::getInstance();
+    if (!g_pcm_instance) {
+        printf("ERROR: Failed to get PCM instance\n");
+        return -1;
+    }
+
+    // Check access permissions
+    printf("*** Attempting to program Intel PCM counters... ***\n");
+    auto status = g_pcm_instance->program();
+
+    if (status == PCM::Success) {
+        printf("*** SUCCESS: Intel PCM counters programmed successfully! ***\n");
+        g_initialized = true;
+
+        // Initialize state vectors
+        uint32_t num_cores = g_pcm_instance->getNumCores();
+        uint32_t num_sockets = g_pcm_instance->getNumSockets();
+
+        g_before_core_states.resize(num_cores);
+        g_after_core_states.resize(num_cores);
+        g_before_socket_states.resize(num_sockets);
+        g_after_socket_states.resize(num_sockets);
+
+        return 0;
+    } else if (status == PCM::MSRAccessDenied) {
+        printf("WARNING: MSR access denied, trying without MSR\n");
+        // Try programming with reduced privileges
+        status = g_pcm_instance->program(PCM::DEFAULT_EVENTS, nullptr, false, -1);
+        if (status == PCM::Success) {
+            printf("*** SUCCESS: Intel PCM counters programmed successfully (no MSR mode)! ***\n");
+            g_initialized = true;
+            return 0;
+        }
+    } else if (status == PCM::PMUBusy) {
+        printf("WARNING: PMU busy, trying to reset and retry\n");
+        g_pcm_instance->resetPMU();
+        status = g_pcm_instance->program();
+        if (status == PCM::Success) {
+            printf("*** SUCCESS: Intel PCM counters programmed successfully after reset! ***\n");
+            g_initialized = true;
+
+            // Initialize state vectors
+            uint32_t num_cores = g_pcm_instance->getNumCores();
+            uint32_t num_sockets = g_pcm_instance->getNumSockets();
+
+            g_before_core_states.resize(num_cores);
+            g_after_core_states.resize(num_cores);
+            g_before_socket_states.resize(num_sockets);
+            g_after_socket_states.resize(num_sockets);
+
+            return 0;
+        }
+    }
+
+    // Print detailed error information
+    printf("ERROR: Failed to program PCM counters. Status: %d\n", (int)status);
+    switch (status) {
+        case PCM::MSRAccessDenied:
+            printf("  - MSR access denied. Try running with sudo or check permissions.\n");
+            break;
+        case PCM::PMUBusy:
+            printf("  - PMU is busy. Another profiling tool might be running.\n");
+            break;
+        case PCM::UnknownError:
+            printf("  - Unknown error occurred.\n");
+            break;
+        default:
+            printf("  - Unhandled error code: %d\n", (int)status);
+            break;
+    }
+
+    return -1;
+}
+
+void pcm_wrapper_cleanup(void) {
+    if (g_pcm_instance) {
+        g_pcm_instance->cleanup();
+        g_pcm_instance = nullptr;
+    }
+    g_initialized = false;
+    g_measurement_active = false;
+
+    // Clear state vectors
+    g_before_core_states.clear();
+    g_after_core_states.clear();
+    g_before_socket_states.clear();
+    g_after_socket_states.clear();
+}
+
+int pcm_wrapper_start_measurement(void) {
+    if (!g_initialized || !g_pcm_instance) {
+        printf("ERROR: PCM not initialized when trying to start measurement\n");
+        return -1;
+    }
+
+    try {
+        // Wait a bit to ensure clean counter state
+        usleep(100000); // 100ms
+
+        g_before_system_state = getSystemCounterState();
+
+        uint32_t num_cores = g_pcm_instance->getNumCores();
+        if (num_cores == 0 || num_cores > 1024) {
+            printf("DEBUG: Suspicious core count %u, measurement may be unreliable\n", num_cores);
+        }
+
+        for (uint32_t i = 0; i < num_cores; ++i) {
+            g_before_core_states[i] = getCoreCounterState(i);
+        }
+
+        uint32_t num_sockets = g_pcm_instance->getNumSockets();
+        for (uint32_t i = 0; i < num_sockets; ++i) {
+            g_before_socket_states[i] = getSocketCounterState(i);
+        }
+
+        g_measurement_active = true;
+
+        printf("PCM measurement started, capturing states for %u cores and %u sockets\n",
+               num_cores, num_sockets);
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error capturing initial PCM states: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error capturing initial PCM states\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_stop_measurement(void) {
+    if (!g_initialized || !g_pcm_instance) {
+        printf("ERROR: PCM not initialized when trying to stop measurement\n");
+        return -1;
+    }
+
+    try {
+        // Always capture final states regardless of g_measurement_active
+        g_after_system_state = getSystemCounterState();
+
+        uint32_t num_cores = g_pcm_instance->getNumCores();
+        for (uint32_t i = 0; i < num_cores; ++i) {
+            g_after_core_states[i] = getCoreCounterState(i);
+        }
+
+        uint32_t num_sockets = g_pcm_instance->getNumSockets();
+        for (uint32_t i = 0; i < num_sockets; ++i) {
+            g_after_socket_states[i] = getSocketCounterState(i);
+        }
+
+        g_measurement_active = false;
+        printf("PCM measurement stopped, captured states for %u cores and %u sockets\n",
+               num_cores, num_sockets);
+
+        // Quick sanity check - test one core calculation
+        if (num_cores > 0) {
+            try {
+                double test_ipc = getIPC(g_before_core_states[0], g_after_core_states[0]);
+                uint64_t test_cycles = getCycles(g_before_core_states[0], g_after_core_states[0]);
+
+                // Check for suspicious values that indicate measurement problems
+                if (test_ipc <= 0.001 || test_ipc > 10.0) {
+                    printf("DEBUG: WARNING - Suspicious IPC value %.3f detected in measurement\n", test_ipc);
+                }
+                if (test_cycles < 1000 || test_cycles > 1000000000000ULL) {
+                    printf("DEBUG: WARNING - Suspicious cycle count %lu detected in measurement\n", test_cycles);
+                }
+            } catch (...) {
+                printf("DEBUG: ERROR - Failed to perform sanity check calculation\n");
+            }
+        }
+
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error capturing final PCM states: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error capturing final PCM states\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_basic_counters(uint32_t core_id, uint64_t* cycles, uint64_t* instructions) {
+    if (!g_initialized || !g_pcm_instance || !cycles || !instructions) {
+        return -1;
+    }
+
+    try {
+        if (core_id >= g_pcm_instance->getNumCores()) {
+            return -1;
+        }
+
+        *cycles = getCycles(g_before_core_states[core_id], g_after_core_states[core_id]);
+        *instructions = getInstructionsRetired(g_before_core_states[core_id], g_after_core_states[core_id]);
+        return 0;
+    } catch (...) {
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_core_counters(uint32_t core_id, pcm_core_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+
+    try {
+        uint32_t num_cores = g_pcm_instance->getNumCores();
+        uint32_t pcm_core_id = core_id;
+
+        // Map DPDK lcore to PCM core with bounds checking
+        if (pcm_core_id >= num_cores) {
+            printf("Warning: DPDK lcore %u exceeds PCM cores %u, using modulo mapping\n",
+                   core_id, num_cores);
+            pcm_core_id = core_id % num_cores;
+        }
+
+        // Make sure we have valid before/after states
+        if (g_before_core_states.size() <= pcm_core_id || g_after_core_states.size() <= pcm_core_id) {
+            printf("ERROR: Invalid core state vectors for core %u\n", pcm_core_id);
+            return -1;
+        }
+
+        // Use the stored before/after states to calculate metrics over the entire measurement period
+        const CoreCounterState& before = g_before_core_states[pcm_core_id];
+        const CoreCounterState& after = g_after_core_states[pcm_core_id];
+
+        // Calculate metrics using PCM's built-in functions with error checking
+        double ipc = 0.0;
+        double freq_ghz = 0.0;
+        double util = 0.0;
+        double l2_hit_ratio = 0.0;
+        double l3_hit_ratio = 0.0;
+        uint64_t cycles = 0;
+        uint64_t instructions = 0;
+        uint64_t l2_hits = 0;
+        uint64_t l2_misses = 0;
+        uint64_t l3_hits = 0;
+        uint64_t l3_misses = 0;
+
+        try {
+            ipc = getIPC(before, after);
+            if (std::isnan(ipc) || std::isinf(ipc) || ipc < 0 || ipc > 10) {
+                printf("WARNING: Invalid IPC value %.3f, setting to 0\n", ipc);
+                ipc = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate IPC\n");
+            ipc = 0.0;
+        }
+
+        try {
+            freq_ghz = getAverageFrequency(before, after) / 1e9;
+            if (std::isnan(freq_ghz) || std::isinf(freq_ghz) || freq_ghz < 0 || freq_ghz > 10) {
+                printf("WARNING: Invalid frequency %.3f, setting to 0\n", freq_ghz);
+                freq_ghz = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate frequency\n");
+            freq_ghz = 0.0;
+        }
+
+        try {
+            util = getActiveRelativeFrequency(before, after);
+            if (std::isnan(util) || std::isinf(util) || util < 0 || util > 2) {
+                printf("WARNING: Invalid utilization %.3f, setting to 0\n", util);
+                util = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate utilization\n");
+            util = 0.0;
+        }
+
+        try {
+            l2_hit_ratio = getL2CacheHitRatio(before, after);
+            if (std::isnan(l2_hit_ratio) || std::isinf(l2_hit_ratio) || l2_hit_ratio < 0 || l2_hit_ratio > 1) {
+                printf("WARNING: Invalid L2 hit ratio %.3f, setting to 0\n", l2_hit_ratio);
+                l2_hit_ratio = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate L2 hit ratio\n");
+            l2_hit_ratio = 0.0;
+        }
+
+        try {
+            l3_hit_ratio = getL3CacheHitRatio(before, after);
+            if (std::isnan(l3_hit_ratio) || std::isinf(l3_hit_ratio) || l3_hit_ratio < 0 || l3_hit_ratio > 1) {
+                printf("WARNING: Invalid L3 hit ratio %.3f, setting to 0\n", l3_hit_ratio);
+                l3_hit_ratio = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate L3 hit ratio\n");
+            l3_hit_ratio = 0.0;
+        }
+
+        // Get raw counter values with overflow protection
+        try {
+            cycles = getCycles(before, after);
+            // Check for reasonable cycle count - allow much higher values for longer measurements
+            if (cycles > 1000000000000ULL) {  // 1T cycles (much higher threshold)
+                printf("WARNING: Suspicious cycle count %lu, setting to 0\n", cycles);
+                cycles = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get cycles\n");
+            cycles = 0;
+        }
+
+        try {
+            instructions = getInstructionsRetired(before, after);
+            // Adjust threshold for instructions - allow much higher values for longer measurements
+            if (instructions > 1000000000000ULL) {  // 1T instructions (much higher threshold)
+                printf("WARNING: Suspicious instruction count %lu, setting to 0\n", instructions);
+                instructions = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get instructions\n");
+            instructions = 0;
+        }
+
+        try {
+            l2_hits = getL2CacheHits(before, after);
+            if (l2_hits > 100000000000ULL) {  // 100B threshold
+                printf("WARNING: Suspicious L2 hit count %lu, setting to 0\n", l2_hits);
+                l2_hits = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get L2 hits\n");
+            l2_hits = 0;
+        }
+
+        try {
+            l2_misses = getL2CacheMisses(before, after);
+            if (l2_misses > 100000000000ULL) {  // 100B threshold
+                printf("WARNING: Suspicious L2 miss count %lu, setting to 0\n", l2_misses);
+                l2_misses = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get L2 misses\n");
+            l2_misses = 0;
+        }
+
+        try {
+            l3_hits = getL3CacheHits(before, after);
+            if (l3_hits > 100000000000ULL) {  // 100B threshold
+                printf("WARNING: Suspicious L3 hit count %lu, setting to 0\n", l3_hits);
+                l3_hits = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get L3 hits\n");
+            l3_hits = 0;
+        }
+
+        try {
+            l3_misses = getL3CacheMisses(before, after);
+            if (l3_misses > 100000000000ULL) {  // 100B threshold
+                printf("WARNING: Suspicious L3 miss count %lu, setting to 0\n", l3_misses);
+                l3_misses = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get L3 misses\n");
+            l3_misses = 0;
+        }
+
+        // Store all the calculated metrics
+        counters->cycles = cycles;
+        counters->instructions = instructions;
+        counters->l2_cache_hits = l2_hits;
+        counters->l2_cache_misses = l2_misses;
+        counters->l3_cache_hits = l3_hits;
+        counters->l3_cache_misses = l3_misses;
+        counters->ipc = ipc;
+        counters->l2_cache_hit_ratio = l2_hit_ratio;
+        counters->l3_cache_hit_ratio = l3_hit_ratio;
+        counters->frequency_ghz = freq_ghz;
+        counters->cpu_utilization = util;
+
+        // Check for completely zero metrics which might indicate measurement issues
+        if (cycles == 0 && instructions == 0 && ipc == 0.0) {
+            printf("DEBUG: WARNING - All core metrics are zero for core %u, check PCM measurement\n", core_id);
+        }
+
+        // Energy estimation (may need different approach depending on PCM version)
+        try {
+            // For core-level energy, we need to use system-level or socket-level energy
+            // Core-level energy might not be available in all PCM versions
+            counters->energy_joules = 0.0; // Default for core-level
+        } catch (...) {
+            counters->energy_joules = 0.0;
+        }
+
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error in PCM counter calculation: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error in PCM counter calculation\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_memory_counters(uint32_t socket_id, pcm_memory_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+
+    try {
+        if (socket_id >= g_pcm_instance->getNumSockets()) {
+            return -1;
+        }
+
+        // Use stored before/after states to calculate metrics over the entire measurement period
+        const SocketCounterState& before = g_before_socket_states[socket_id];
+        const SocketCounterState& after = g_after_socket_states[socket_id];
+
+        // Use PCM's built-in bandwidth calculation methods
+        uint64_t bytes_read = getBytesReadFromMC(before, after);
+        uint64_t bytes_written = getBytesWrittenToMC(before, after);
+
+        // Calculate elapsed time for the entire measurement period
+        double elapsed_time = getExecUsage(g_before_system_state, g_after_system_state);
+        if (elapsed_time <= 0) {
+            printf("ERROR: Invalid elapsed time %.6f seconds in memory counter calculation!\n", elapsed_time);
+            printf("ERROR: This indicates PCM measurement was not properly initialized or captured.\n");
+            return -1;
+        }
+
+        counters->dram_read_bytes = bytes_read;
+        counters->dram_write_bytes = bytes_written;
+        counters->memory_controller_read_bw_mbps = (double)bytes_read / (1024.0 * 1024.0) / elapsed_time;
+        counters->memory_controller_write_bw_mbps = (double)bytes_written / (1024.0 * 1024.0) / elapsed_time;
+        counters->memory_controller_bw_mbps = counters->memory_controller_read_bw_mbps + counters->memory_controller_write_bw_mbps;
+
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error in memory counter calculation: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error in memory counter calculation\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_io_counters(uint32_t socket_id, pcm_io_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+
+    try {
+        if (socket_id >= g_pcm_instance->getNumSockets()) {
+            return -1;
+        }
+
+        // Use stored before/after states to calculate metrics over the entire measurement period
+        const SocketCounterState& before = g_before_socket_states[socket_id];
+        const SocketCounterState& after = g_after_socket_states[socket_id];
+
+        // Try to get PCIe read/write bytes using PCM functions
+        uint64_t pcie_read_bytes = 0;
+        uint64_t pcie_write_bytes = 0;
+
+        // PCM might have specific PCIe counter functions - try memory controller as proxy
+        uint64_t mc_reads = getBytesReadFromMC(before, after);
+        uint64_t mc_writes = getBytesWrittenToMC(before, after);
+
+        // For network-intensive workloads, significant portion of memory traffic is PCIe-related
+        // Estimate PCIe traffic as a fraction of memory controller traffic
+        double pcie_fraction = 0.3; // Assume 30% of memory traffic is PCIe-related
+
+        if (mc_reads < 10000000000ULL && mc_writes < 10000000000ULL) { // Sanity check
+            pcie_read_bytes = (uint64_t)(mc_reads * pcie_fraction);
+            pcie_write_bytes = (uint64_t)(mc_writes * pcie_fraction);
+        }
+
+        // Calculate elapsed time for the entire measurement period
+        double elapsed_time = getExecUsage(g_before_system_state, g_after_system_state);
+        if (elapsed_time <= 0) {
+            printf("ERROR: Invalid elapsed time %.6f seconds in I/O counter calculation!\n", elapsed_time);
+            printf("ERROR: This indicates PCM measurement was not properly initialized or captured.\n");
+            return -1;
+        }
+
+        counters->pcie_read_bytes = pcie_read_bytes;
+        counters->pcie_write_bytes = pcie_write_bytes;
+        counters->pcie_read_bandwidth_mbps = (double)pcie_read_bytes / (1024.0 * 1024.0) / elapsed_time;
+        counters->pcie_write_bandwidth_mbps = (double)pcie_write_bytes / (1024.0 * 1024.0) / elapsed_time;
+
+        // Memory controller bandwidth (IMC)
+        counters->imc_reads_gbps = (double)mc_reads / (1024.0 * 1024.0 * 1024.0) / elapsed_time;
+        counters->imc_writes_gbps = (double)mc_writes / (1024.0 * 1024.0 * 1024.0) / elapsed_time;
+
+        // QPI/UPI data transfer and utilization
+        counters->qpi_upi_data_bytes = 0; // PCM might not support this directly
+        counters->qpi_upi_utilization = 0.0;
+        counters->uncore_freq_ghz = 0; // Could try to get uncore frequency if available
+
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error in I/O counter calculation: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error in I/O counter calculation\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_system_counters(pcm_system_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+
+    try {
+        // System-wide counters
+        counters->active_cores = g_pcm_instance->getNumOnlineCores();
+
+        // Energy measurements with overflow protection
+        double total_energy_raw = 0.0;
+        double dram_energy_raw = 0.0;
+
+        try {
+            total_energy_raw = getConsumedJoules(g_before_system_state, g_after_system_state);
+            if (std::isnan(total_energy_raw) || std::isinf(total_energy_raw) || total_energy_raw < 0 || total_energy_raw > 100000.0) {
+                printf("WARNING: Invalid total energy %.2f, setting to 0\n", total_energy_raw);
+                total_energy_raw = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate total energy\n");
+            total_energy_raw = 0.0;
+        }
+
+        try {
+            dram_energy_raw = getDRAMConsumedJoules(g_before_system_state, g_after_system_state);
+            if (std::isnan(dram_energy_raw) || std::isinf(dram_energy_raw) || dram_energy_raw < 0 || dram_energy_raw > 100000.0) {
+                printf("WARNING: Invalid DRAM energy %.2f, setting to 0\n", dram_energy_raw);
+                dram_energy_raw = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate DRAM energy\n");
+            dram_energy_raw = 0.0;
+        }
+
+        counters->total_energy_joules = total_energy_raw;
+        counters->package_energy_joules = total_energy_raw;
+        counters->dram_energy_joules = dram_energy_raw;
+
+        // Check if energy measurements seem reasonable
+        if (total_energy_raw > 10000.0) {  // More than 10kJ seems very high
+            printf("DEBUG: WARNING - Very high energy consumption detected: total=%.1f J, dram=%.1f J\n",
+                   total_energy_raw, dram_energy_raw);
+        } else if (total_energy_raw == 0.0 && dram_energy_raw == 0.0) {
+            printf("DEBUG: WARNING - Zero energy measurements detected, check PMU access\n");
+        }
+
+        // System-wide IPC with overflow protection
+        double system_ipc_raw = 0.0;
+        try {
+            system_ipc_raw = getIPC(g_before_system_state, g_after_system_state);
+            if (std::isnan(system_ipc_raw) || std::isinf(system_ipc_raw) || system_ipc_raw < 0.0 || system_ipc_raw > 10.0) {
+                printf("WARNING: Invalid system IPC %.3f, setting to 0\n", system_ipc_raw);
+                system_ipc_raw = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate system IPC\n");
+            system_ipc_raw = 0.0;
+        }
+        counters->total_ipc = system_ipc_raw;
+
+        // Memory bandwidth utilization
+        uint64_t total_mem_bytes_raw = 0;
+        double elapsed = 0.0;
+
+        try {
+            uint64_t read_bytes = getBytesReadFromMC(g_before_system_state, g_after_system_state);
+            uint64_t write_bytes = getBytesWrittenToMC(g_before_system_state, g_after_system_state);
+
+            if (read_bytes < 1000000000000000ULL && write_bytes < 1000000000000000ULL) {
+                total_mem_bytes_raw = read_bytes + write_bytes;
+            } else {
+                printf("WARNING: Suspicious memory byte counts: read=%lu, write=%lu\n", read_bytes, write_bytes);
+                total_mem_bytes_raw = 0;
+            }
+
+            elapsed = getExecUsage(g_before_system_state, g_after_system_state);
+            if (std::isnan(elapsed) || std::isinf(elapsed) || elapsed <= 0 || elapsed > 1000.0) {
+                printf("WARNING: Invalid elapsed time %.3f, setting memory BW to 0\n", elapsed);
+                elapsed = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate memory bandwidth\n");
+            total_mem_bytes_raw = 0;
+            elapsed = 0.0;
+        }
+
+        if (elapsed > 0 && total_mem_bytes_raw > 0) {
+            counters->memory_bandwidth_utilization = (double)total_mem_bytes_raw / (1024.0 * 1024.0 * 1024.0) / elapsed;  // GB/s
+
+            // Check for unreasonably high memory bandwidth
+            if (counters->memory_bandwidth_utilization > 1000.0) {  // More than 1TB/s seems suspicious
+                printf("DEBUG: WARNING - Very high memory bandwidth detected: %.1f GB/s\n",
+                       counters->memory_bandwidth_utilization);
+            }
+        } else {
+            counters->memory_bandwidth_utilization = 0.0;
+            if (elapsed <= 0) {
+                printf("DEBUG: WARNING - Invalid elapsed time %.3f for memory bandwidth calculation\n", elapsed);
+            }
+        }
+
+        // Thermal throttling (approximate) with bounds check
+        double rel_freq = 0.0;
+        try {
+            rel_freq = getRelativeFrequency(g_before_system_state, g_after_system_state);
+            if (std::isnan(rel_freq) || std::isinf(rel_freq) || rel_freq < 0.0 || rel_freq > 2.0) {
+                printf("WARNING: Invalid relative frequency %.3f, setting throttle to 0\n", rel_freq);
+                rel_freq = 1.0;  // assume no throttling
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate relative frequency\n");
+            rel_freq = 1.0;  // assume no throttling
+        }
+
+        counters->thermal_throttle_ratio = (rel_freq > 0) ? (1.0 - rel_freq) : 0.0;
+        if (counters->thermal_throttle_ratio < 0) {
+            counters->thermal_throttle_ratio = 0.0;
+        }
+
+        return 0;
+    } catch (...) {
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_system_info(char* info_buffer, size_t buffer_size) {
+    if (!g_initialized || !g_pcm_instance) {
+        return -1;
+    }
+
+    try {
+        snprintf(info_buffer, buffer_size,
+                "CPU Brand: %s\n"
+                "Cores: %u\n"
+                "Online Cores: %u\n"
+                "Sockets: %u\n"
+                "Threads per Core: %u\n",
+                g_pcm_instance->getCPUBrandString().c_str(),
+                g_pcm_instance->getNumCores(),
+                g_pcm_instance->getNumOnlineCores(),
+                g_pcm_instance->getNumSockets(),
+                g_pcm_instance->getThreadsPerCore());
+        return 0;
+    } catch (...) {
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_instant_pcie_bytes(uint32_t socket_id, uint64_t *pcie_read_bytes, uint64_t *pcie_write_bytes) {
+    if (!g_initialized || !g_pcm_instance) {
+        return -1;
+    }
+
+    if (!pcie_read_bytes || !pcie_write_bytes) {
+        return -1;
+    }
+
+    if (socket_id >= g_pcm_instance->getNumSockets()) {
+        return -1;
+    }
+
+    try {
+        // Get instant snapshot of system counter state
+        SystemCounterState current_state = getSystemCounterState();
+
+        // Sum up all QPI/PCIe links for this specific socket only
+        // Each socket can have multiple QPI/PCIe links
+        uint64_t total_incoming = 0;
+        uint64_t total_outgoing = 0;
+
+        // Get number of QPI ports for this socket
+        uint32_t num_qpi_ports = g_pcm_instance->getQPILinksPerSocket();
+
+        // Sum incoming bytes across all links for this socket
+        for (uint32_t link = 0; link < num_qpi_ports; ++link) {
+            total_incoming += getIncomingQPILinkBytes(socket_id, link, current_state);
+        }
+
+        // For outgoing bytes, we need before/after states
+        if (g_measurement_active) {
+            // Sum outgoing bytes across all links for this socket
+            for (uint32_t link = 0; link < num_qpi_ports; ++link) {
+                total_outgoing += getOutgoingQPILinkBytes(socket_id, link, g_before_system_state, current_state);
+            }
+        } else {
+            // If no measurement active, use zero baseline
+            SystemCounterState zero_state = SystemCounterState();
+            for (uint32_t link = 0; link < num_qpi_ports; ++link) {
+                total_outgoing += getOutgoingQPILinkBytes(socket_id, link, zero_state, current_state);
+            }
+        }
+
+        *pcie_read_bytes = total_incoming;
+        *pcie_write_bytes = total_outgoing;
+
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error getting instant PCIe bytes for socket %u: %s\n", socket_id, e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error getting instant PCIe bytes for socket %u\n", socket_id);
+        return -1;
+    }
+}
+
+} // extern "C"
diff --git a/app/pktgen_pcm_wrapper.h b/app/pktgen_pcm_wrapper.h
new file mode 100644
index 0000000..4989df4
--- /dev/null
+++ b/app/pktgen_pcm_wrapper.h
@@ -0,0 +1,152 @@
+#ifndef __PKTGEN_PCM_WRAPPER_H__
+#define __PKTGEN_PCM_WRAPPER_H__
+
+#include <stdint.h>
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* PCM wrapper functions for static linking */
+
+/* Core performance counters structure */
+typedef struct {
+    uint64_t cycles;
+    uint64_t instructions;
+    uint64_t l2_cache_hits;
+    uint64_t l2_cache_misses;
+    uint64_t l3_cache_hits;
+    uint64_t l3_cache_misses;
+    double ipc;
+    double l2_cache_hit_ratio;
+    double l3_cache_hit_ratio;
+    double frequency_ghz;
+    double cpu_utilization;
+    double energy_joules;
+} pcm_core_counters_t;
+
+/* Memory performance counters structure */
+typedef struct {
+    uint64_t dram_read_bytes;
+    uint64_t dram_write_bytes;
+    double memory_controller_read_bw_mbps;
+    double memory_controller_write_bw_mbps;
+    double memory_controller_bw_mbps;
+} pcm_memory_counters_t;
+
+/* I/O and Uncore performance counters structure */
+typedef struct {
+    uint64_t pcie_read_bytes;
+    uint64_t pcie_write_bytes;
+    double pcie_read_bandwidth_mbps;
+    double pcie_write_bandwidth_mbps;
+    uint64_t qpi_upi_data_bytes;
+    double qpi_upi_utilization;
+    uint64_t uncore_freq_ghz;
+    double imc_reads_gbps;
+    double imc_writes_gbps;
+} pcm_io_counters_t;
+
+/* System-wide performance counters structure */
+typedef struct {
+    uint32_t active_cores;
+    double total_energy_joules;
+    double package_energy_joules;
+    double dram_energy_joules;
+    double total_ipc;
+    double memory_bandwidth_utilization;
+    double thermal_throttle_ratio;
+} pcm_system_counters_t;
+
+/**
+ * Check if PCM wrapper is available
+ * @return 1 if available, 0 if not
+ */
+int pcm_wrapper_is_available(void);
+
+/**
+ * Initialize PCM wrapper
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_init(void);
+
+/**
+ * Cleanup PCM wrapper
+ */
+void pcm_wrapper_cleanup(void);
+
+/**
+ * Get basic performance counters
+ * @param core_id: Core ID to get counters for
+ * @param cycles: Pointer to store cycle count
+ * @param instructions: Pointer to store instruction count
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_basic_counters(uint32_t core_id, uint64_t *cycles, uint64_t *instructions);
+
+/**
+ * Get comprehensive core performance counters
+ * @param core_id: Core ID to get counters for
+ * @param counters: Pointer to store core counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_core_counters(uint32_t core_id, pcm_core_counters_t *counters);
+
+/**
+ * Get memory performance counters
+ * @param socket_id: Socket ID to get counters for
+ * @param counters: Pointer to store memory counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_memory_counters(uint32_t socket_id, pcm_memory_counters_t *counters);
+
+/**
+ * Get I/O and uncore performance counters
+ * @param socket_id: Socket ID to get counters for
+ * @param counters: Pointer to store I/O counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_io_counters(uint32_t socket_id, pcm_io_counters_t *counters);
+
+/**
+ * Get system-wide performance counters
+ * @param counters: Pointer to store system counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_system_counters(pcm_system_counters_t *counters);
+
+/**
+ * Start measurement period
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_start_measurement(void);
+
+/**
+ * Stop measurement period and calculate differences
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_stop_measurement(void);
+
+/**
+ * Get system information
+ * @param info_buffer Buffer to store system info
+ * @param buffer_size Size of the buffer
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_system_info(char* info_buffer, size_t buffer_size);
+
+/**
+ * Get instant PCIe byte counters (snapshot, not delta)
+ * @param socket_id Socket ID to get counters for
+ * @param pcie_read_bytes Pointer to store PCIe read bytes
+ * @param pcie_write_bytes Pointer to store PCIe write bytes
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_instant_pcie_bytes(uint32_t socket_id, uint64_t *pcie_read_bytes, uint64_t *pcie_write_bytes);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PKTGEN_PCM_WRAPPER_H__ */
diff --git a/scripts/measure-rx-tx-rate.lua b/scripts/measure-rx-tx-rate.lua
new file mode 100644
index 0000000..351bbc2
--- /dev/null
+++ b/scripts/measure-rx-tx-rate.lua
@@ -0,0 +1,133 @@
+-- RX/TX Rate Measurement Script (based on measure-tx-rate.lua)
+
+-- Since we run from Pktgen-DPDK directory, just add current directory to path
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = tonumber(os.getenv("PKTGEN_DURATION")) or 10
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Configuration (same as measure-tx-rate.lua)
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 100)  -- Maximum rate
+pktgen.set(port, "count", 0)   -- Continuous transmission
+
+-- Set MAC addresses (same as measure-tx-rate.lua)
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+
+-- Set IP addresses (same as measure-tx-rate.lua)
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+-- Set up Range configuration for TCP (same as measure-tx-rate.lua)
+pktgen.range.ip_proto("all", "tcp")
+
+-- Set MAC addresses in range (same as measure-tx-rate.lua)
+pktgen.range.src_mac(port, "start", "08:c0:eb:b6:cd:5d")
+pktgen.range.dst_mac(port, "start", "08:c0:eb:b6:e8:05")
+
+-- Set source IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.src_ip(port, "start", "10.0.1.7")
+pktgen.range.src_ip(port, "inc", "0.0.0.0")
+pktgen.range.src_ip(port, "min", "10.0.1.7")
+pktgen.range.src_ip(port, "max", "10.0.1.7")
+
+-- Set destination IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.dst_ip(port, "start", "10.0.1.8")
+pktgen.range.dst_ip(port, "inc", "0.0.0.0")
+pktgen.range.dst_ip(port, "min", "10.0.1.8")
+pktgen.range.dst_ip(port, "max", "10.0.1.8")
+
+-- Set source TCP port (20000-20255, increment by 1, same as measure-tx-rate.lua)
+pktgen.range.src_port(port, "start", 20000)
+pktgen.range.src_port(port, "inc", 1)
+pktgen.range.src_port(port, "min", 10000)
+pktgen.range.src_port(port, "max", 60000)
+
+-- Set destination TCP port (fixed at 20000, same as measure-tx-rate.lua)
+pktgen.range.dst_port(port, "start", 20000)
+pktgen.range.dst_port(port, "inc", 0)
+pktgen.range.dst_port(port, "min", 20000)
+pktgen.range.dst_port(port, "max", 20000)
+
+-- Set TTL (same as measure-tx-rate.lua)
+pktgen.range.ttl(port, "start", 64)
+pktgen.range.ttl(port, "inc", 0)
+pktgen.range.ttl(port, "min", 64)
+pktgen.range.ttl(port, "max", 64)
+
+-- Enable range mode (same as measure-tx-rate.lua)
+pktgen.set_range(port, "on")
+
+pktgen.delay(100)
+
+print("=== Starting RX/TX Rate Measurement ===")
+print("Configuration:")
+print("  Port: " .. port)
+print("  Packet Size: 64 bytes")
+print("  Protocol: TCP")
+print("  Test Duration: " .. sleeptime .. " seconds")
+print("  Rate: 100% (maximum)")
+print("  Range Mode: Enabled (Port 10000-60000)")
+print("==========================================")
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+-- Record initial statistics
+pktgen.delay(1000)  -- Wait 1 second for transmission to stabilize
+local initial_stats = pktgen.portStats("all", "port")[port]
+local initial_tx_pkts = initial_stats.opackets
+local initial_rx_pkts = initial_stats.ipackets
+
+-- Wait for test duration
+pktgen.delay(sleeptime * 1000)
+
+-- Stop transmission and get final statistics
+pktgen.stop(port)
+local final_stats = pktgen.portStats("all", "port")[port]
+local final_tx_pkts = final_stats.opackets
+local final_rx_pkts = final_stats.ipackets
+
+-- Calculate average rates in Mpps
+local total_tx_packets = final_tx_pkts - initial_tx_pkts
+local total_rx_packets = final_rx_pkts - initial_rx_pkts
+local avg_tx_rate_mpps = total_tx_packets / (sleeptime * 1000000)
+local avg_rx_rate_mpps = total_rx_packets / (sleeptime * 1000000)
+
+-- Calculate packet loss percentage
+local packet_loss_pct = 0
+if total_tx_packets > 0 then
+    packet_loss_pct = (1 - total_rx_packets/total_tx_packets) * 100
+end
+
+-- Display results
+print("\n=== RX/TX Rate Measurement Results ===")
+print("Test Duration: " .. sleeptime .. " seconds")
+print("Packet Size: 64 bytes")
+print("Protocol: TCP with ranges")
+print("Total Packets Transmitted: " .. total_tx_packets)
+print("Total Packets Received: " .. total_rx_packets)
+print("Average TX Rate: " .. string.format("%.3f", avg_tx_rate_mpps) .. " Mpps")
+print("Average RX Rate: " .. string.format("%.3f", avg_rx_rate_mpps) .. " Mpps")
+print("Packet Loss: " .. string.format("%.2f", packet_loss_pct) .. "%")
+print("=====================================")
+
+-- Print results in parseable format for automation
+print("RESULT_TX_RATE_MPPS:" .. string.format("%.3f", avg_tx_rate_mpps))
+print("RESULT_RX_RATE_MPPS:" .. string.format("%.3f", avg_rx_rate_mpps))
+print("RESULT_TX_PACKETS:" .. total_tx_packets)
+print("RESULT_RX_PACKETS:" .. total_rx_packets)
+
+-- Auto quit to prevent interactive mode - use os.exit instead of pktgen.quit()
+print("Auto-quitting pktgen...")
+pktgen.delay(1000)  -- Wait 1 second before quitting
+os.exit(0)
diff --git a/scripts/measure-tx-rate.lua b/scripts/measure-tx-rate.lua
new file mode 100644
index 0000000..d86e02a
--- /dev/null
+++ b/scripts/measure-tx-rate.lua
@@ -0,0 +1,99 @@
+-- TX Rate Measurement Script
+
+-- Since we run from Pktgen-DPDK directory, just add current directory to path
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = tonumber(os.getenv("PKTGEN_DURATION")) or 10
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Configuration
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 100)  -- Maximum rate
+pktgen.set(port, "count", 0)   -- Continuous transmission
+
+-- Set MAC addresses
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+
+-- Set IP addresses
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+-- Set up Range configuration for TCP
+pktgen.range.ip_proto("all", "tcp")
+
+-- Set MAC addresses in range
+pktgen.range.src_mac(port, "start", "08:c0:eb:b6:cd:5d")
+pktgen.range.dst_mac(port, "start", "08:c0:eb:b6:e8:05")
+
+-- Set source IP (fixed)
+pktgen.range.src_ip(port, "start", "10.0.1.7")
+pktgen.range.src_ip(port, "inc", "0.0.0.0")
+pktgen.range.src_ip(port, "min", "10.0.1.7")
+pktgen.range.src_ip(port, "max", "10.0.1.7")
+
+-- Set destination IP (fixed)
+pktgen.range.dst_ip(port, "start", "10.0.1.8")
+pktgen.range.dst_ip(port, "inc", "0.0.0.0")
+pktgen.range.dst_ip(port, "min", "10.0.1.8")
+pktgen.range.dst_ip(port, "max", "10.0.1.8")
+
+-- Set source TCP port (20000-20255, increment by 1)
+pktgen.range.src_port(port, "start", 20000)
+pktgen.range.src_port(port, "inc", 1)
+pktgen.range.src_port(port, "min", 20000)
+pktgen.range.src_port(port, "max", 20255)
+
+-- Set destination TCP port (fixed at 20000)
+pktgen.range.dst_port(port, "start", 20000)
+pktgen.range.dst_port(port, "inc", 0)
+pktgen.range.dst_port(port, "min", 20000)
+pktgen.range.dst_port(port, "max", 20000)
+
+-- Set TTL
+pktgen.range.ttl(port, "start", 64)
+pktgen.range.ttl(port, "inc", 0)
+pktgen.range.ttl(port, "min", 64)
+pktgen.range.ttl(port, "max", 64)
+
+-- Enable range mode
+pktgen.set_range(port, "on")
+
+pktgen.delay(100)
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+-- Record initial statistics
+pktgen.delay(1000)  -- Wait 1 second for transmission to stabilize
+local initial_stats = pktgen.portStats("all", "port")[port]
+local initial_tx_pkts = initial_stats.opackets
+
+-- Wait for test duration
+pktgen.delay(sleeptime * 1000)
+
+-- Stop transmission and get final statistics
+pktgen.stop(port)
+local final_stats = pktgen.portStats("all", "port")[port]
+local final_tx_pkts = final_stats.opackets
+
+-- Calculate average TX rate in Mpps
+local total_packets = final_tx_pkts - initial_tx_pkts
+local avg_tx_rate_mpps = total_packets / (sleeptime * 1000000)
+
+-- Display results
+print("\n=== TX Rate Measurement Results ===")
+print("Test Duration: " .. sleeptime .. " seconds")
+print("Packet Size: 64 bytes")
+print("Protocol: TCP")
+print("Total Packets Transmitted: " .. total_packets)
+print("Average TX Rate: " .. string.format("%.3f", avg_tx_rate_mpps) .. " Mpps")
+print("=====================================\n")
\ No newline at end of file
diff --git a/scripts/simple-test.lua b/scripts/simple-test.lua
new file mode 100644
index 0000000..e2a02c8
--- /dev/null
+++ b/scripts/simple-test.lua
@@ -0,0 +1,16 @@
+-- Simple test script to check if lua execution works
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+
+print("Simple test script loaded successfully")
+print("Stopping and clearing port " .. port)
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+print("Test completed successfully")
diff --git a/scripts/simple-tx-rate.lua b/scripts/simple-tx-rate.lua
new file mode 100644
index 0000000..86cde97
--- /dev/null
+++ b/scripts/simple-tx-rate.lua
@@ -0,0 +1,55 @@
+-- Simplified TX Rate Measurement Script
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = 3  -- Reduced to 3 seconds for testing
+
+print("Starting simplified TX rate measurement...")
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Basic configuration
+pktgen.set(port, "size", 64)
+pktgen.set(port, "rate", 100)  -- Maximum rate
+pktgen.set(port, "count", 0)   -- Continuous transmission
+
+-- Simple MAC and IP addresses (no range)
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+pktgen.delay(100)
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+-- Record initial statistics
+pktgen.delay(1000)  -- Wait 1 second for transmission to stabilize
+local initial_stats = pktgen.portStats("all", "port")[port]
+local initial_tx_pkts = initial_stats.opackets
+
+-- Wait for test duration
+pktgen.delay(sleeptime * 1000)
+
+-- Stop transmission and get final statistics
+pktgen.stop(port)
+local final_stats = pktgen.portStats("all", "port")[port]
+local final_tx_pkts = final_stats.opackets
+
+-- Calculate average TX rate in Mpps
+local total_packets = final_tx_pkts - initial_tx_pkts
+local avg_tx_rate_mpps = total_packets / (sleeptime * 1000000)
+
+-- Display results
+print("\n=== Simplified TX Rate Results ===")
+print("Test Duration: " .. sleeptime .. " seconds")
+print("Total Packets Transmitted: " .. total_packets)
+print("Average TX Rate: " .. string.format("%.3f", avg_tx_rate_mpps) .. " Mpps")
+print("====================================\n")
diff --git a/scripts/simple-tx-test.lua b/scripts/simple-tx-test.lua
new file mode 100644
index 0000000..fc81586
--- /dev/null
+++ b/scripts/simple-tx-test.lua
@@ -0,0 +1,91 @@
+-- RX/TX Rate Measurement Script (based on measure-tx-rate.lua)
+
+-- Since we run from Pktgen-DPDK directory, just add current directory to path
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = tonumber(os.getenv("PKTGEN_DURATION")) or 5
+local packet_size = tonumber(os.getenv("PKTGEN_PACKET_SIZE")) or 64
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Configuration (same as measure-tx-rate.lua)
+pktgen.set(port, "size", packet_size)
+pktgen.set(port, "rate", 100)  -- 100% rate to utilize multiple cores
+pktgen.set(port, "count", 0)   -- Continuous transmission (0 = infinite)
+
+-- Set MAC addresses (same as measure-tx-rate.lua)
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+
+-- Set IP addresses (same as measure-tx-rate.lua)
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+-- Set up Range configuration for TCP (same as measure-tx-rate.lua)
+pktgen.range.ip_proto("all", "tcp")
+
+-- Set MAC addresses in range (same as measure-tx-rate.lua)
+pktgen.range.src_mac(port, "start", "08:c0:eb:b6:cd:5d")
+pktgen.range.dst_mac(port, "start", "08:c0:eb:b6:e8:05")
+
+-- Set source IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.src_ip(port, "start", "10.0.1.7")
+pktgen.range.src_ip(port, "inc", "0.0.0.0")
+pktgen.range.src_ip(port, "min", "10.0.1.7")
+pktgen.range.src_ip(port, "max", "10.0.1.7")
+
+-- Set destination IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.dst_ip(port, "start", "10.0.1.8")
+pktgen.range.dst_ip(port, "inc", "0.0.0.0")
+pktgen.range.dst_ip(port, "min", "10.0.1.8")
+pktgen.range.dst_ip(port, "max", "10.0.1.8")
+
+-- Set source TCP port (20000-20255, increment by 1, same as measure-tx-rate.lua)
+pktgen.range.src_port(port, "start", 20000)
+pktgen.range.src_port(port, "inc", 1)
+pktgen.range.src_port(port, "min", 10000)
+pktgen.range.src_port(port, "max", 60000)
+
+-- Set destination TCP port (fixed at 20000, same as measure-tx-rate.lua)
+pktgen.range.dst_port(port, "start", 20000)
+pktgen.range.dst_port(port, "inc", 0)
+pktgen.range.dst_port(port, "min", 20000)
+pktgen.range.dst_port(port, "max", 20000)
+
+-- Set TTL (same as measure-tx-rate.lua)
+pktgen.range.ttl(port, "start", 64)
+pktgen.range.ttl(port, "inc", 0)
+pktgen.range.ttl(port, "min", 64)
+pktgen.range.ttl(port, "max", 64)
+
+-- Enable range mode (same as measure-tx-rate.lua)
+pktgen.set_range(port, "on")
+
+pktgen.delay(100)
+
+-- Start transmission
+print("Starting packet transmission for " .. sleeptime .. " seconds...")
+pktgen.start(port)
+
+-- Convert sleeptime from seconds to milliseconds for pktgen.delay()
+local delay_ms = sleeptime * 1000
+pktgen.delay(delay_ms)
+
+-- Stop transmission BEFORE reading statistics
+print("Stopping packet transmission...")
+pktgen.stop(port)
+
+-- Wait a bit for any remaining packets to be transmitted by hardware
+pktgen.delay(100)
+
+-- Print packet statistics summary after stopping
+print("\nPrinting packet statistics summary...")
+pktgen.print_stats()
+
+os.exit(0)
diff --git a/scripts/tx-pkts.lua b/scripts/tx-pkts.lua
new file mode 100644
index 0000000..c13b188
--- /dev/null
+++ b/scripts/tx-pkts.lua
@@ -0,0 +1,95 @@
+-- RX/TX Rate Measurement Script (based on measure-tx-rate.lua)
+
+-- Since we run from Pktgen-DPDK directory, just add current directory to path
+package.path = package.path .. ";./?.lua;?.lua;test/?.lua;app/?.lua;"
+
+require "Pktgen"
+
+local port = 0
+local sleeptime = tonumber(os.getenv("PKTGEN_DURATION")) or 5
+local packet_size = tonumber(os.getenv("PKTGEN_PACKET_SIZE")) or 1024
+
+pktgen.stop(port)
+pktgen.clear(port)
+pktgen.clr()
+pktgen.delay(100)
+
+-- Configuration (same as measure-tx-rate.lua)
+pktgen.set(port, "size", packet_size)
+pktgen.set(port, "rate", 100)  -- 100% rate to utilize multiple cores
+pktgen.set(port, "count", 1)   -- Continuous transmission (0 = infinite)
+
+-- Set MAC addresses (same as measure-tx-rate.lua)
+pktgen.set_mac(port, "src", "08:c0:eb:b6:cd:5d")
+pktgen.set_mac(port, "dst", "08:c0:eb:b6:e8:05")
+
+-- Set IP addresses (same as measure-tx-rate.lua)
+pktgen.set_ipaddr(port, "src", "10.0.1.7")
+pktgen.set_ipaddr(port, "dst", "10.0.1.8/24")
+
+-- Set up Range configuration for TCP (same as measure-tx-rate.lua)
+pktgen.range.ip_proto("all", "tcp")
+
+-- Set MAC addresses in range (same as measure-tx-rate.lua)
+pktgen.range.src_mac(port, "start", "08:c0:eb:b6:cd:5d")
+pktgen.range.dst_mac(port, "start", "08:c0:eb:b6:e8:05")
+
+-- Set source IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.src_ip(port, "start", "10.0.1.7")
+pktgen.range.src_ip(port, "inc", "0.0.0.0")
+pktgen.range.src_ip(port, "min", "10.0.1.7")
+pktgen.range.src_ip(port, "max", "10.0.1.7")
+
+-- Set destination IP (fixed, same as measure-tx-rate.lua)
+pktgen.range.dst_ip(port, "start", "10.0.1.8")
+pktgen.range.dst_ip(port, "inc", "0.0.0.0")
+pktgen.range.dst_ip(port, "min", "10.0.1.8")
+pktgen.range.dst_ip(port, "max", "10.0.1.8")
+
+-- Set source TCP port (20000-20255, increment by 1, same as measure-tx-rate.lua)
+pktgen.range.src_port(port, "start", 20000)
+pktgen.range.src_port(port, "inc", 1)
+pktgen.range.src_port(port, "min", 10000)
+pktgen.range.src_port(port, "max", 60000)
+
+-- Set destination TCP port (fixed at 20000, same as measure-tx-rate.lua)
+pktgen.range.dst_port(port, "start", 20000)
+pktgen.range.dst_port(port, "inc", 0)
+pktgen.range.dst_port(port, "min", 20000)
+pktgen.range.dst_port(port, "max", 20000)
+
+-- Set TTL (same as measure-tx-rate.lua)
+pktgen.range.ttl(port, "start", 64)
+pktgen.range.ttl(port, "inc", 0)
+pktgen.range.ttl(port, "min", 64)
+pktgen.range.ttl(port, "max", 64)
+
+-- Set packet size for range mode
+pktgen.range.pkt_size(port, "start", packet_size)
+pktgen.range.pkt_size(port, "inc", 0)
+pktgen.range.pkt_size(port, "min", packet_size)
+pktgen.range.pkt_size(port, "max", packet_size)
+
+-- Enable range mode (same as measure-tx-rate.lua)
+pktgen.set_range(port, "on")
+
+pktgen.delay(100)
+
+-- Start transmission
+print("Starting packet transmission for")
+pktgen.start(port)
+
+pktgen.delay(100) -- sleep time in milliseconds
+
+-- Stop transmission BEFORE reading statistics
+print("Stopping packet transmission...")
+pktgen.stop(port)
+
+-- Wait a bit for any remaining packets to be transmitted by hardware
+pktgen.delay(100)
+
+-- Print packet statistics summary after stopping
+print("\nPrinting packet statistics summary...")
+pktgen.print_stats()
+
+os.exit(0)
