diff --git a/examples/l3fwd/l3fwd.h b/examples/l3fwd/l3fwd.h
index 0cce3406ee..ef65225622 100644
--- a/examples/l3fwd/l3fwd.h
+++ b/examples/l3fwd/l3fwd.h
@@ -9,6 +9,13 @@
 #include <rte_vect.h>
 #include <rte_acl.h>
 
+/* Debug logging control - MAIN CONFIGURATION */
+/* Set to 1 to enable debug logs, 0 to disable for better performance */
+#ifndef L3FWD_DEBUG_LOGS
+#define L3FWD_DEBUG_LOGS 0  /* 0 = disabled, 1 = enabled */
+#endif
+static volatile bool stats_enabled = true;
+
 #define DO_RFC_1812_CHECKS
 
 #define RTE_LOGTYPE_L3FWD RTE_LOGTYPE_USER1
@@ -119,6 +126,24 @@ extern uint32_t max_pkt_len;
 extern uint32_t nb_pkt_per_burst;
 extern uint32_t mb_mempool_cache_size;
 
+/* Packet statistics per lcore */
+struct lcore_packet_stats {
+	uint64_t rx_packets;
+	uint64_t tx_packets;
+	uint64_t start_time;
+	/* Drop counters */
+	uint64_t dropped_invalid_ipv4;
+	uint64_t dropped_no_route;
+	uint64_t dropped_tx_failed;
+	uint64_t dropped_non_ip;
+	uint64_t dropped_unknown;
+};
+
+extern struct lcore_packet_stats lcore_stats[RTE_MAX_LCORE];
+
+/* Function declarations */
+void analyze_packet(struct rte_mbuf *pkt, unsigned int lcore_id, const char *direction);
+
 /* Send burst of packets on an output interface */
 static inline int
 send_burst(struct lcore_conf *qconf, uint16_t n, uint16_t port)
@@ -126,12 +151,33 @@ send_burst(struct lcore_conf *qconf, uint16_t n, uint16_t port)
 	struct rte_mbuf **m_table;
 	int ret;
 	uint16_t queueid;
+	unsigned int lcore_id = rte_lcore_id();
 
 	queueid = qconf->tx_queue_id[port];
 	m_table = (struct rte_mbuf **)qconf->tx_mbufs[port].m_table;
 
+#if L3FWD_DEBUG_LOGS
+	/* Analyze TX packets for debugging only when debug is enabled */
+	for (int i = 0; i < n; i++) {
+		analyze_packet(m_table[i], lcore_id, "TX");
+	}
+#endif
+
 	ret = rte_eth_tx_burst(port, queueid, m_table, n);
+	
+	/* Update TX statistics */
+	lcore_stats[lcore_id].tx_packets += ret;
+	
 	if (unlikely(ret < n)) {
+		/* Count failed TX packets */
+		lcore_stats[lcore_id].dropped_tx_failed += (n - ret);
+		
+		/* Log TX congestion for debugging */
+		if (L3FWD_DEBUG_LOGS && (lcore_stats[lcore_id].dropped_tx_failed % 1000 == 0)) {
+			RTE_LOG(WARNING, L3FWD, "TX congestion on port %u: tried %u, sent %d, failed %u (total failed: %" PRIu64 ")\n",
+				port, n, ret, (n - ret), lcore_stats[lcore_id].dropped_tx_failed);
+		}
+		
 		do {
 			rte_pktmbuf_free(m_table[ret]);
 		} while (++ret < n);
diff --git a/examples/l3fwd/l3fwd_lpm.c b/examples/l3fwd/l3fwd_lpm.c
index fec0aeb79c..e6387a03cd 100644
--- a/examples/l3fwd/l3fwd_lpm.c
+++ b/examples/l3fwd/l3fwd_lpm.c
@@ -15,6 +15,8 @@
 #include <stdbool.h>
 #include <sys/socket.h>
 #include <arpa/inet.h>
+#include <signal.h>
+#include <netinet/in.h>
 
 #include <rte_debug.h>
 #include <rte_ether.h>
@@ -33,6 +35,12 @@
 
 #include "lpm_route_parse.c"
 
+#if L3FWD_DEBUG_LOGS
+#define L3FWD_DEBUG_LOG(fmt, args...) RTE_LOG(INFO, L3FWD, fmt, ##args)
+#else
+#define L3FWD_DEBUG_LOG(fmt, args...) do {} while(0)
+#endif
+
 #define IPV4_L3FWD_LPM_MAX_RULES         1024
 #define IPV4_L3FWD_LPM_NUMBER_TBL8S (1 << 8)
 #define IPV6_L3FWD_LPM_MAX_RULES         1024
@@ -41,6 +49,200 @@
 static struct rte_lpm *ipv4_l3fwd_lpm_lookup_struct[NB_SOCKETS];
 static struct rte_lpm6 *ipv6_l3fwd_lpm_lookup_struct[NB_SOCKETS];
 
+/* Global array of packet statistics per lcore */
+struct lcore_packet_stats lcore_stats[RTE_MAX_LCORE];
+
+/* Analyze and log packet details */
+void
+analyze_packet(struct rte_mbuf *pkt, unsigned int lcore_id, const char *direction)
+{
+#if L3FWD_DEBUG_LOGS
+	struct rte_ether_hdr *eth_hdr;
+	struct rte_ipv4_hdr *ipv4_hdr;
+	struct rte_tcp_hdr *tcp_hdr;
+	struct rte_udp_hdr *udp_hdr;
+	uint32_t src_ip, dst_ip;
+	uint16_t src_port = 0, dst_port = 0;
+	uint8_t proto;
+	char src_ip_str[INET_ADDRSTRLEN];
+	char dst_ip_str[INET_ADDRSTRLEN];
+	char src_mac_str[18];
+	char dst_mac_str[18];
+
+	eth_hdr = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
+	
+	/* Convert MAC addresses to string format */
+	snprintf(src_mac_str, sizeof(src_mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+		 eth_hdr->src_addr.addr_bytes[0], eth_hdr->src_addr.addr_bytes[1],
+		 eth_hdr->src_addr.addr_bytes[2], eth_hdr->src_addr.addr_bytes[3],
+		 eth_hdr->src_addr.addr_bytes[4], eth_hdr->src_addr.addr_bytes[5]);
+	snprintf(dst_mac_str, sizeof(dst_mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+		 eth_hdr->dst_addr.addr_bytes[0], eth_hdr->dst_addr.addr_bytes[1],
+		 eth_hdr->dst_addr.addr_bytes[2], eth_hdr->dst_addr.addr_bytes[3],
+		 eth_hdr->dst_addr.addr_bytes[4], eth_hdr->dst_addr.addr_bytes[5]);
+	
+	if (RTE_ETH_IS_IPV4_HDR(pkt->packet_type)) {
+		ipv4_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);
+		src_ip = rte_be_to_cpu_32(ipv4_hdr->src_addr);
+		dst_ip = rte_be_to_cpu_32(ipv4_hdr->dst_addr);
+		proto = ipv4_hdr->next_proto_id;
+
+		/* Convert IPs to string format */
+		struct in_addr addr;
+		addr.s_addr = rte_cpu_to_be_32(src_ip);
+		inet_ntop(AF_INET, &addr, src_ip_str, INET_ADDRSTRLEN);
+		addr.s_addr = rte_cpu_to_be_32(dst_ip);
+		inet_ntop(AF_INET, &addr, dst_ip_str, INET_ADDRSTRLEN);
+
+		/* Extract port numbers for TCP/UDP */
+		if (proto == IPPROTO_TCP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*tcp_hdr)) {
+			tcp_hdr = (struct rte_tcp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+			src_port = rte_be_to_cpu_16(tcp_hdr->src_port);
+			dst_port = rte_be_to_cpu_16(tcp_hdr->dst_port);
+			L3FWD_DEBUG_LOG("[%s] lcore=%u TCP %s:%u -> %s:%u (MAC %s -> %s) (RSS=0x%08x)\n", 
+				direction, lcore_id, src_ip_str, src_port, dst_ip_str, dst_port, src_mac_str, dst_mac_str, pkt->hash.rss);
+		} else if (proto == IPPROTO_UDP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*udp_hdr)) {
+			udp_hdr = (struct rte_udp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+			src_port = rte_be_to_cpu_16(udp_hdr->src_port);
+			dst_port = rte_be_to_cpu_16(udp_hdr->dst_port);
+			L3FWD_DEBUG_LOG("[%s] lcore=%u UDP %s:%u -> %s:%u (MAC %s -> %s) (RSS=0x%08x)\n", 
+				direction, lcore_id, src_ip_str, src_port, dst_ip_str, dst_port, src_mac_str, dst_mac_str, pkt->hash.rss);
+		} else {
+			L3FWD_DEBUG_LOG("[%s] lcore=%u IP proto=%u %s -> %s (MAC %s -> %s) (RSS=0x%08x)\n", 
+				direction, lcore_id, proto, src_ip_str, dst_ip_str, src_mac_str, dst_mac_str, pkt->hash.rss);
+		}
+	} else if (RTE_ETH_IS_IPV6_HDR(pkt->packet_type)) {
+		L3FWD_DEBUG_LOG("[%s] lcore=%u IPv6 packet (MAC %s -> %s)\n", direction, lcore_id, src_mac_str, dst_mac_str);
+	} else {
+		L3FWD_DEBUG_LOG("[%s] lcore=%u Non-IP packet (type=0x%04x) (MAC %s -> %s)\n", 
+			direction, lcore_id, rte_be_to_cpu_16(eth_hdr->ether_type), src_mac_str, dst_mac_str);
+	}
+#else
+	/* Suppress unused parameter warnings when debug is disabled */
+	(void)pkt;
+	(void)lcore_id;
+	(void)direction;
+#endif
+}
+
+/* Print packet statistics when exiting */
+static void
+print_packet_stats(void)
+{
+	unsigned int lcore_id;
+	uint64_t total_rx = 0, total_tx = 0;
+	uint64_t current_time = rte_rdtsc();
+	uint64_t tsc_hz = rte_get_tsc_hz();
+	
+	printf("\n");
+	printf("=====================================\n");
+	printf("L3FWD Packet Statistics Summary\n");
+	printf("=====================================\n");
+	printf("%-8s %-12s %-12s %-10s %-10s %-8s\n", 
+		"Lcore", "RX Packets", "TX Packets", "RX Rate", "TX Rate", "Loss%");
+	printf("%-8s %-12s %-12s %-10s %-10s %-8s\n", 
+		"-----", "----------", "----------", "--------", "--------", "------");
+
+	uint64_t total_dropped_invalid_ipv4 = 0, total_dropped_no_route = 0;
+	uint64_t total_dropped_tx_failed = 0, total_dropped_non_ip = 0, total_dropped_unknown = 0;
+
+	RTE_LCORE_FOREACH(lcore_id) {
+		if (lcore_stats[lcore_id].start_time > 0) {
+			uint64_t duration = current_time - lcore_stats[lcore_id].start_time;
+			double elapsed_sec = (double)duration / tsc_hz;
+			double rx_rate = elapsed_sec > 0 ? lcore_stats[lcore_id].rx_packets / elapsed_sec : 0;
+			double tx_rate = elapsed_sec > 0 ? lcore_stats[lcore_id].tx_packets / elapsed_sec : 0;
+			double loss_rate = lcore_stats[lcore_id].rx_packets > 0 ? 
+				(double)(lcore_stats[lcore_id].rx_packets - lcore_stats[lcore_id].tx_packets) * 100.0 / lcore_stats[lcore_id].rx_packets : 0.0;
+			
+			printf("%-8u %-12" PRIu64 " %-12" PRIu64 " %-10.1f %-10.1f %-8.1f\n",
+				lcore_id,
+				lcore_stats[lcore_id].rx_packets,
+				lcore_stats[lcore_id].tx_packets,
+				rx_rate / 1000000.0,  /* Convert to Mpps */
+				tx_rate / 1000000.0,
+				loss_rate);
+			
+			total_rx += lcore_stats[lcore_id].rx_packets;
+			total_tx += lcore_stats[lcore_id].tx_packets;
+			total_dropped_invalid_ipv4 += lcore_stats[lcore_id].dropped_invalid_ipv4;
+			total_dropped_no_route += lcore_stats[lcore_id].dropped_no_route;
+			total_dropped_tx_failed += lcore_stats[lcore_id].dropped_tx_failed;
+			total_dropped_non_ip += lcore_stats[lcore_id].dropped_non_ip;
+			total_dropped_unknown += lcore_stats[lcore_id].dropped_unknown;
+		}
+	}
+	
+	double total_loss_rate = total_rx > 0 ? (double)(total_rx - total_tx) * 100.0 / total_rx : 0.0;
+	
+	printf("%-8s %-12s %-12s %-10s %-10s %-8s\n", 
+		"-----", "----------", "----------", "--------", "--------", "------");
+	printf("%-8s %-12" PRIu64 " %-12" PRIu64 " %-10s %-10s %-8.1f\n", 
+		"Total", total_rx, total_tx, "", "", total_loss_rate);
+	printf("=====================================\n");
+	printf("ANALYSIS: RX/TX difference = %" PRIu64 " packets (%.1f%% loss)\n", 
+		total_rx - total_tx, total_loss_rate);
+	
+	/* Print detailed drop analysis */
+	if (total_rx - total_tx > 0) {
+		printf("DROP ANALYSIS:\n");
+		printf("  Invalid IPv4 packets: %" PRIu64 "\n", total_dropped_invalid_ipv4);
+		printf("  No route found: %" PRIu64 "\n", total_dropped_no_route);
+		printf("  TX failed (queue full): %" PRIu64 " (%.1f%% of RX)\n", 
+			total_dropped_tx_failed, total_rx > 0 ? (double)total_dropped_tx_failed * 100.0 / total_rx : 0.0);
+		printf("  Non-IP packets: %" PRIu64 "\n", total_dropped_non_ip);
+		printf("  Unknown drops: %" PRIu64 "\n", total_dropped_unknown);
+		
+		if (total_dropped_tx_failed > 0) {
+			printf("\nTX CONGESTION ANALYSIS:\n");
+			printf("  - TX queue is overloaded (receiving faster than transmitting)\n");
+			printf("  - Consider: reducing RX rate, increasing TX queue size, or checking network bottleneck\n");
+			
+			printf("\nCURRENT CONFIGURATION:\n");
+			printf("  RX Descriptors: %u\n", nb_rxd);
+			printf("  TX Descriptors: %u\n", nb_txd);
+			printf("  Max PKT Burst: %u\n", MAX_PKT_BURST);
+			printf("  Default PKT Burst: %u\n", DEFAULT_PKT_BURST);
+			printf("  TX Drain Interval: %u us\n", BURST_TX_DRAIN_US);
+			printf("  Enabled Port Mask: 0x%x\n", enabled_port_mask);
+			
+			/* Get port info for first enabled port */
+			uint16_t portid;
+			for (portid = 0; portid < RTE_MAX_ETHPORTS; portid++) {
+				if ((enabled_port_mask & (1 << portid)) != 0) {
+					struct rte_eth_dev_info dev_info;
+					struct rte_eth_link link;
+					if (rte_eth_dev_info_get(portid, &dev_info) == 0) {
+						printf("  Port %u Driver: %s\n", portid, dev_info.driver_name);
+						printf("  Port %u Max TX Queues: %u\n", portid, dev_info.max_tx_queues);
+						printf("  Port %u Max RX Queues: %u\n", portid, dev_info.max_rx_queues);
+					}
+					if (rte_eth_link_get_nowait(portid, &link) == 0) {
+						printf("  Port %u Link Speed: %u Mbps, %s\n", portid, link.link_speed,
+							link.link_status ? "UP" : "DOWN");
+					}
+					break; /* Only show first enabled port */
+				}
+			}
+		}
+	}
+	printf("=====================================\n");
+}
+
+/* Signal handler for graceful shutdown */
+static void
+signal_handler(int signum)
+{
+	if (signum == SIGINT || signum == SIGTERM) {
+		printf("\nReceived signal %d, shutting down...\n", signum);
+		if (stats_enabled) {
+			print_packet_stats();
+		}
+		stats_enabled = false;
+		force_quit = true;
+	}
+}
+
 /* Performing LPM-based lookups. 8< */
 static inline uint16_t
 lpm_get_ipv4_dst_port(const struct rte_ipv4_hdr *ipv4_hdr,
@@ -156,6 +358,17 @@ lpm_main_loop(__rte_unused void *dummy)
 	lcore_id = rte_lcore_id();
 	qconf = &lcore_conf[lcore_id];
 
+	/* Initialize packet statistics for this lcore */
+	lcore_stats[lcore_id].rx_packets = 0;
+	lcore_stats[lcore_id].tx_packets = 0;
+	lcore_stats[lcore_id].start_time = rte_rdtsc();
+
+	/* Install signal handlers only on master lcore */
+	if (rte_lcore_id() == rte_get_main_lcore()) {
+		signal(SIGINT, signal_handler);
+		signal(SIGTERM, signal_handler);
+	}
+
 	const uint16_t n_rx_q = qconf->n_rx_queue;
 	const uint16_t n_tx_p = qconf->n_tx_port;
 	if (n_rx_q == 0) {
@@ -163,7 +376,21 @@ lpm_main_loop(__rte_unused void *dummy)
 		return 0;
 	}
 
-	RTE_LOG(INFO, L3FWD, "entering main loop on lcore %u\n", lcore_id);
+	RTE_LOG(INFO, L3FWD, "[lpm] entering main loop on lcore %u\n", lcore_id);
+	for (i = 0; i < n_rx_q; i++) {
+		portid = qconf->rx_queue_list[i].port_id;
+		queueid = qconf->rx_queue_list[i].queue_id;
+		RTE_LOG(INFO, L3FWD,
+			" [RX] lcoreid=%u, port=%u rxq=%hhu\n",
+			lcore_id, portid, queueid);
+	}
+
+	for (i = 0; i < n_tx_p; i++) {
+		portid = qconf->tx_port_id[i];
+		RTE_LOG(INFO, L3FWD,
+			" [TX] lcoreid=%u, port=%u, txq=%hhu\n",
+			lcore_id, portid, qconf->tx_queue_id[portid]);
+	}
 
 	for (i = 0; i < n_rx_q; i++) {
 
@@ -189,6 +416,9 @@ lpm_main_loop(__rte_unused void *dummy)
 				portid = qconf->tx_port_id[i];
 				if (qconf->tx_mbufs[portid].len == 0)
 					continue;
+				
+				L3FWD_DEBUG_LOG("lcore %u sending %u packets to port %u queue %u\n", 
+					lcore_id, qconf->tx_mbufs[portid].len, portid, qconf->tx_queue_id[portid]);
 				send_burst(qconf,
 					qconf->tx_mbufs[portid].len,
 					portid);
@@ -208,7 +438,22 @@ lpm_main_loop(__rte_unused void *dummy)
 				nb_pkt_per_burst);
 			if (nb_rx == 0)
 				continue;
-
+			
+			/* Update RX packet statistics */
+			if (stats_enabled) {
+				lcore_stats[lcore_id].rx_packets += nb_rx;
+			}
+			
+			L3FWD_DEBUG_LOG("lcore %u received %d packets from port %u queue %u\n", lcore_id, nb_rx, portid, queueid);
+			
+			/* Analyze first few packets for debugging */
+			if (L3FWD_DEBUG_LOGS) {
+				/* Analyze only first 3 packets to reduce overhead */
+				// int analyze_count = nb_rx > 3 ? 3 : nb_rx;
+				for (int j = 0; j < nb_rx; j++) {
+					analyze_packet(pkts_burst[j], lcore_id, "RX");
+				}
+			}
 #if defined RTE_ARCH_X86 || defined __ARM_NEON \
 			 || defined RTE_ARCH_PPC_64
 			l3fwd_lpm_send_packets(nb_rx, pkts_burst,
@@ -222,6 +467,11 @@ lpm_main_loop(__rte_unused void *dummy)
 		cur_tsc = rte_rdtsc();
 	}
 
+	/* Print statistics when main loop exits */
+	if (rte_lcore_id() == rte_get_main_lcore() && stats_enabled) {
+		print_packet_stats();
+	}
+
 	return 0;
 }
 
diff --git a/examples/l3fwd/l3fwd_lpm.h b/examples/l3fwd/l3fwd_lpm.h
index 4ee61e8d88..b2f0682abb 100644
--- a/examples/l3fwd/l3fwd_lpm.h
+++ b/examples/l3fwd/l3fwd_lpm.h
@@ -12,6 +12,7 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 	struct rte_ether_hdr *eth_hdr;
 	struct rte_ipv4_hdr *ipv4_hdr;
 	uint16_t dst_port;
+	unsigned int lcore_id = rte_lcore_id();
 
 	eth_hdr = rte_pktmbuf_mtod(m, struct rte_ether_hdr *);
 
@@ -23,6 +24,7 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 #ifdef DO_RFC_1812_CHECKS
 		/* Check to make sure the packet is valid (RFC1812) */
 		if (is_valid_ipv4_pkt(ipv4_hdr, m->pkt_len, m->ol_flags) < 0) {
+			lcore_stats[lcore_id].dropped_invalid_ipv4++;
 			rte_pktmbuf_free(m);
 			return;
 		}
@@ -31,8 +33,11 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 						qconf->ipv4_lookup_struct);
 
 		if (dst_port >= RTE_MAX_ETHPORTS ||
-			(enabled_port_mask & 1 << dst_port) == 0)
-			dst_port = portid;
+			(enabled_port_mask & 1 << dst_port) == 0) {
+			lcore_stats[lcore_id].dropped_no_route++;
+			rte_pktmbuf_free(m);
+			return;
+		}
 
 #ifdef DO_RFC_1812_CHECKS
 		/* Update time to live and header checksum */
@@ -58,8 +63,11 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 					qconf->ipv6_lookup_struct);
 
 		if (dst_port >= RTE_MAX_ETHPORTS ||
-			(enabled_port_mask & 1 << dst_port) == 0)
-			dst_port = portid;
+			(enabled_port_mask & 1 << dst_port) == 0) {
+			lcore_stats[lcore_id].dropped_no_route++;
+			rte_pktmbuf_free(m);
+			return;
+		}
 
 		/* dst addr */
 		*(uint64_t *)&eth_hdr->dst_addr = dest_eth_addr[dst_port];
@@ -71,6 +79,7 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 		send_single_packet(qconf, m, dst_port);
 	} else {
 		/* Free the mbuf that contains non-IPV4/IPV6 packet */
+		lcore_stats[lcore_id].dropped_non_ip++;
 		rte_pktmbuf_free(m);
 	}
 }
diff --git a/examples/l3fwd/main.c b/examples/l3fwd/main.c
index ae3b4f6439..3ef2aa5151 100644
--- a/examples/l3fwd/main.c
+++ b/examples/l3fwd/main.c
@@ -131,7 +131,8 @@ static struct rte_eth_conf port_conf = {
 	.rx_adv_conf = {
 		.rss_conf = {
 			.rss_key = NULL,
-			.rss_hf = RTE_ETH_RSS_IP,
+			// .rss_hf = RTE_ETH_RSS_IP,
+			.rss_hf = RTE_ETH_RSS_IP | RTE_ETH_RSS_TCP | RTE_ETH_RSS_UDP,
 		},
 	},
 	.txmode = {
@@ -1065,10 +1066,11 @@ parse_args(int argc, char **argv)
 	}
 
 	/* For ACL, update port config rss hash filter */
-	if (lookup_mode == L3FWD_LOOKUP_ACL) {
-		port_conf.rx_adv_conf.rss_conf.rss_hf |=
-				RTE_ETH_RSS_UDP | RTE_ETH_RSS_TCP | RTE_ETH_RSS_SCTP;
-	}
+	// if (lookup_mode == L3FWD_LOOKUP_ACL) {
+	// 	port_conf.rx_adv_conf.rss_conf.rss_hf |=
+	// 			RTE_ETH_RSS_UDP | RTE_ETH_RSS_TCP | RTE_ETH_RSS_SCTP;
+	// }
+	/* RSS hash filter now includes TCP/UDP ports for all modes */
 
 	if (optind >= 0)
 		argv[optind-1] = prgname;
@@ -1448,7 +1450,7 @@ l3fwd_poll_resource_setup(void)
 			else
 				socketid = 0;
 
-			printf("txq=%u,%d,%d ", lcore_id, queueid, socketid);
+			printf("TXQ=%u,%d,%d ", lcore_id, queueid, socketid);
 			fflush(stdout);
 
 			txconf = &dev_info.default_txconf;
