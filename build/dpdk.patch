diff --git a/examples/l3fwd/l3fwd.h b/examples/l3fwd/l3fwd.h
index 0cce3406ee..5d933e661a 100644
--- a/examples/l3fwd/l3fwd.h
+++ b/examples/l3fwd/l3fwd.h
@@ -5,10 +5,18 @@
 #ifndef __L3_FWD_H__
 #define __L3_FWD_H__
 
+#include <stdlib.h>
 #include <rte_ethdev.h>
 #include <rte_vect.h>
 #include <rte_acl.h>
 
+/* Debug logging control - MAIN CONFIGURATION */
+/* Set to 1 to enable debug logs, 0 to disable for better performance */
+#ifndef L3FWD_DEBUG_LOGS
+#define L3FWD_DEBUG_LOGS 0  /* 0 = disabled, 1 = enabled */
+#endif
+static volatile bool stats_enabled = true;
+
 #define DO_RFC_1812_CHECKS
 
 #define RTE_LOGTYPE_L3FWD RTE_LOGTYPE_USER1
@@ -119,6 +127,24 @@ extern uint32_t max_pkt_len;
 extern uint32_t nb_pkt_per_burst;
 extern uint32_t mb_mempool_cache_size;
 
+/* Packet statistics per lcore */
+struct lcore_packet_stats {
+	uint64_t rx_packets;
+	uint64_t tx_packets;
+	uint64_t start_time;
+	/* Drop counters */
+	uint64_t dropped_invalid_ipv4;
+	uint64_t dropped_no_route;
+	uint64_t dropped_tx_failed;
+	uint64_t dropped_non_ip;
+	uint64_t dropped_unknown;
+};
+
+extern struct lcore_packet_stats lcore_stats[RTE_MAX_LCORE];
+
+/* Function declarations */
+void analyze_packet(struct rte_mbuf *pkt, unsigned int lcore_id, const char *direction, uint16_t queue_id);
+
 /* Send burst of packets on an output interface */
 static inline int
 send_burst(struct lcore_conf *qconf, uint16_t n, uint16_t port)
@@ -126,12 +152,33 @@ send_burst(struct lcore_conf *qconf, uint16_t n, uint16_t port)
 	struct rte_mbuf **m_table;
 	int ret;
 	uint16_t queueid;
+	unsigned int lcore_id = rte_lcore_id();
 
 	queueid = qconf->tx_queue_id[port];
 	m_table = (struct rte_mbuf **)qconf->tx_mbufs[port].m_table;
 
+#if L3FWD_DEBUG_LOGS
+	/* Analyze TX packets for debugging only when debug is enabled */
+	for (int i = 0; i < n; i++) {
+		analyze_packet(m_table[i], lcore_id, "TX", queueid);
+	}
+#endif
+
 	ret = rte_eth_tx_burst(port, queueid, m_table, n);
+
+	/* Update TX statistics */
+	lcore_stats[lcore_id].tx_packets += ret;
+
 	if (unlikely(ret < n)) {
+		/* Count failed TX packets */
+		lcore_stats[lcore_id].dropped_tx_failed += (n - ret);
+
+		/* Log TX congestion for debugging */
+		if (L3FWD_DEBUG_LOGS && (lcore_stats[lcore_id].dropped_tx_failed % 1000 == 0)) {
+			RTE_LOG(WARNING, L3FWD, "TX congestion on port %u: tried %u, sent %d, failed %u (total failed: %" PRIu64 ")\n",
+				port, n, ret, (n - ret), lcore_stats[lcore_id].dropped_tx_failed);
+		}
+
 		do {
 			rte_pktmbuf_free(m_table[ret]);
 		} while (++ret < n);
diff --git a/examples/l3fwd/l3fwd_lpm.c b/examples/l3fwd/l3fwd_lpm.c
index fec0aeb79c..3776cc094d 100644
--- a/examples/l3fwd/l3fwd_lpm.c
+++ b/examples/l3fwd/l3fwd_lpm.c
@@ -15,6 +15,8 @@
 #include <stdbool.h>
 #include <sys/socket.h>
 #include <arpa/inet.h>
+#include <signal.h>
+#include <netinet/in.h>
 
 #include <rte_debug.h>
 #include <rte_ether.h>
@@ -30,9 +32,16 @@
 #include "l3fwd.h"
 #include "l3fwd_common.h"
 #include "l3fwd_event.h"
+#include "l3fwd_pcm.h"
 
 #include "lpm_route_parse.c"
 
+#if L3FWD_DEBUG_LOGS
+#define L3FWD_DEBUG_LOG(fmt, args...) RTE_LOG(INFO, L3FWD, fmt, ##args)
+#else
+#define L3FWD_DEBUG_LOG(fmt, args...) do {} while(0)
+#endif
+
 #define IPV4_L3FWD_LPM_MAX_RULES         1024
 #define IPV4_L3FWD_LPM_NUMBER_TBL8S (1 << 8)
 #define IPV6_L3FWD_LPM_MAX_RULES         1024
@@ -41,6 +50,220 @@
 static struct rte_lpm *ipv4_l3fwd_lpm_lookup_struct[NB_SOCKETS];
 static struct rte_lpm6 *ipv6_l3fwd_lpm_lookup_struct[NB_SOCKETS];
 
+/* Global array of packet statistics per lcore */
+struct lcore_packet_stats lcore_stats[RTE_MAX_LCORE];
+
+/* Analyze and log packet details */
+void
+analyze_packet(struct rte_mbuf *pkt, unsigned int lcore_id, const char *direction, uint16_t queue_id)
+{
+#if L3FWD_DEBUG_LOGS
+	struct rte_ether_hdr *eth_hdr;
+	struct rte_ipv4_hdr *ipv4_hdr;
+	struct rte_tcp_hdr *tcp_hdr;
+	struct rte_udp_hdr *udp_hdr;
+	uint32_t src_ip, dst_ip;
+	uint16_t src_port = 0, dst_port = 0;
+	uint8_t proto;
+	char src_ip_str[INET_ADDRSTRLEN];
+	char dst_ip_str[INET_ADDRSTRLEN];
+	char src_mac_str[18];
+	char dst_mac_str[18];
+
+	eth_hdr = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
+
+	/* Convert MAC addresses to string format */
+	snprintf(src_mac_str, sizeof(src_mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+		 eth_hdr->src_addr.addr_bytes[0], eth_hdr->src_addr.addr_bytes[1],
+		 eth_hdr->src_addr.addr_bytes[2], eth_hdr->src_addr.addr_bytes[3],
+		 eth_hdr->src_addr.addr_bytes[4], eth_hdr->src_addr.addr_bytes[5]);
+	snprintf(dst_mac_str, sizeof(dst_mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+		 eth_hdr->dst_addr.addr_bytes[0], eth_hdr->dst_addr.addr_bytes[1],
+		 eth_hdr->dst_addr.addr_bytes[2], eth_hdr->dst_addr.addr_bytes[3],
+		 eth_hdr->dst_addr.addr_bytes[4], eth_hdr->dst_addr.addr_bytes[5]);
+
+	if (RTE_ETH_IS_IPV4_HDR(pkt->packet_type)) {
+		ipv4_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);
+		src_ip = rte_be_to_cpu_32(ipv4_hdr->src_addr);
+		dst_ip = rte_be_to_cpu_32(ipv4_hdr->dst_addr);
+		proto = ipv4_hdr->next_proto_id;
+
+		/* Convert IPs to string format */
+		struct in_addr addr;
+		addr.s_addr = rte_cpu_to_be_32(src_ip);
+		inet_ntop(AF_INET, &addr, src_ip_str, INET_ADDRSTRLEN);
+		addr.s_addr = rte_cpu_to_be_32(dst_ip);
+		inet_ntop(AF_INET, &addr, dst_ip_str, INET_ADDRSTRLEN);
+
+		/* Extract port numbers for TCP/UDP */
+		if (proto == IPPROTO_TCP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*tcp_hdr)) {
+			tcp_hdr = (struct rte_tcp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+			src_port = rte_be_to_cpu_16(tcp_hdr->src_port);
+			dst_port = rte_be_to_cpu_16(tcp_hdr->dst_port);
+			L3FWD_DEBUG_LOG("[%s] lcore=%u queue=%u TCP %s:%u -> %s:%u (MAC %s -> %s) (RSS=0x%08x)\n",
+				direction, lcore_id, queue_id, src_ip_str, src_port, dst_ip_str, dst_port, src_mac_str, dst_mac_str, pkt->hash.rss);
+		} else if (proto == IPPROTO_UDP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*udp_hdr)) {
+			udp_hdr = (struct rte_udp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+			src_port = rte_be_to_cpu_16(udp_hdr->src_port);
+			dst_port = rte_be_to_cpu_16(udp_hdr->dst_port);
+			L3FWD_DEBUG_LOG("[%s] lcore=%u queue=%u UDP %s:%u -> %s:%u (MAC %s -> %s) (RSS=0x%08x)\n",
+				direction, lcore_id, queue_id, src_ip_str, src_port, dst_ip_str, dst_port, src_mac_str, dst_mac_str, pkt->hash.rss);
+		} else {
+			L3FWD_DEBUG_LOG("[%s] lcore=%u queue=%u IP proto=%u %s -> %s (MAC %s -> %s) (RSS=0x%08x)\n",
+				direction, lcore_id, queue_id, proto, src_ip_str, dst_ip_str, src_mac_str, dst_mac_str, pkt->hash.rss);
+		}
+	} else if (RTE_ETH_IS_IPV6_HDR(pkt->packet_type)) {
+		L3FWD_DEBUG_LOG("[%s] lcore=%u queue=%u IPv6 packet (MAC %s -> %s)\n", direction, lcore_id, queue_id, src_mac_str, dst_mac_str);
+	} else {
+		L3FWD_DEBUG_LOG("[%s] lcore=%u queue=%u Non-IP packet (type=0x%04x) (MAC %s -> %s)\n",
+			direction, lcore_id, queue_id, rte_be_to_cpu_16(eth_hdr->ether_type), src_mac_str, dst_mac_str);
+	}
+#else
+	/* Suppress unused parameter warnings when debug is disabled */
+	(void)pkt;
+	(void)lcore_id;
+	(void)direction;
+	(void)queue_id;
+#endif
+}
+
+/* Print packet statistics when exiting */
+static void
+print_packet_stats(void)
+{
+	unsigned int lcore_id;
+	uint64_t total_rx = 0, total_tx = 0;
+	uint64_t current_time = rte_rdtsc();
+	uint64_t tsc_hz = rte_get_tsc_hz();
+
+	printf("\n");
+	printf("=====================================\n");
+	printf("L3FWD Packet Statistics Summary\n");
+	printf("=====================================\n");
+	printf("%-8s %-12s %-12s %-10s %-10s %-8s\n",
+		"Lcore", "RX Packets", "TX Packets", "RX Rate", "TX Rate", "Loss%");
+	printf("%-8s %-12s %-12s %-10s %-10s %-8s\n",
+		"-----", "----------", "----------", "--------", "--------", "------");
+
+	uint64_t total_dropped_invalid_ipv4 = 0, total_dropped_no_route = 0;
+	uint64_t total_dropped_tx_failed = 0, total_dropped_non_ip = 0, total_dropped_unknown = 0;
+
+	RTE_LCORE_FOREACH(lcore_id) {
+		if (lcore_stats[lcore_id].start_time > 0) {
+			uint64_t duration = current_time - lcore_stats[lcore_id].start_time;
+			double elapsed_sec = (double)duration / tsc_hz;
+			double rx_rate = elapsed_sec > 0 ? lcore_stats[lcore_id].rx_packets / elapsed_sec : 0;
+			double tx_rate = elapsed_sec > 0 ? lcore_stats[lcore_id].tx_packets / elapsed_sec : 0;
+			double loss_rate = lcore_stats[lcore_id].rx_packets > 0 ?
+				(double)(lcore_stats[lcore_id].rx_packets - lcore_stats[lcore_id].tx_packets) * 100.0 / lcore_stats[lcore_id].rx_packets : 0.0;
+
+			printf("%-8u %-12" PRIu64 " %-12" PRIu64 " %-10.1f %-10.1f %-8.1f\n",
+				lcore_id,
+				lcore_stats[lcore_id].rx_packets,
+				lcore_stats[lcore_id].tx_packets,
+				rx_rate / 1000000.0,  /* Convert to Mpps */
+				tx_rate / 1000000.0,
+				loss_rate);
+
+			total_rx += lcore_stats[lcore_id].rx_packets;
+			total_tx += lcore_stats[lcore_id].tx_packets;
+			total_dropped_invalid_ipv4 += lcore_stats[lcore_id].dropped_invalid_ipv4;
+			total_dropped_no_route += lcore_stats[lcore_id].dropped_no_route;
+			total_dropped_tx_failed += lcore_stats[lcore_id].dropped_tx_failed;
+			total_dropped_non_ip += lcore_stats[lcore_id].dropped_non_ip;
+			total_dropped_unknown += lcore_stats[lcore_id].dropped_unknown;
+		}
+	}
+
+	double total_loss_rate = total_rx > 0 ? (double)(total_rx - total_tx) * 100.0 / total_rx : 0.0;
+
+	printf("%-8s %-12s %-12s %-10s %-10s %-8s\n",
+		"-----", "----------", "----------", "--------", "--------", "------");
+	printf("%-8s %-12" PRIu64 " %-12" PRIu64 " %-10s %-10s %-8.1f\n",
+		"Total", total_rx, total_tx, "", "", total_loss_rate);
+	printf("=====================================\n");
+	printf("ANALYSIS: RX/TX difference = %" PRIu64 " packets (%.1f%% loss)\n",
+		total_rx - total_tx, total_loss_rate);
+
+	/* Print detailed drop analysis */
+	if (total_rx - total_tx > 0) {
+		printf("DROP ANALYSIS:\n");
+		printf("  Invalid IPv4 packets: %" PRIu64 "\n", total_dropped_invalid_ipv4);
+		printf("  No route found: %" PRIu64 "\n", total_dropped_no_route);
+		printf("  TX failed (queue full): %" PRIu64 " (%.1f%% of RX)\n",
+			total_dropped_tx_failed, total_rx > 0 ? (double)total_dropped_tx_failed * 100.0 / total_rx : 0.0);
+		printf("  Non-IP packets: %" PRIu64 "\n", total_dropped_non_ip);
+		printf("  Unknown drops: %" PRIu64 "\n", total_dropped_unknown);
+
+		if (total_dropped_tx_failed > 0) {
+			printf("\nTX CONGESTION ANALYSIS:\n");
+			printf("  - TX queue is overloaded (receiving faster than transmitting)\n");
+			printf("  - Consider: reducing RX rate, increasing TX queue size, or checking network bottleneck\n");
+		}
+	}
+
+	/* Always show CURRENT CONFIGURATION when stats are enabled */
+	if (stats_enabled) {
+		printf("\nCURRENT CONFIGURATION:\n");
+		printf("  RX_DESC_DEFAULT (nb_rxd): %u \n", nb_rxd);
+		printf("  TX_DESC_DEFAULT (nb_txd): %u \n", nb_txd);
+		printf("  MAX_PKT_BURST: %u\n", MAX_PKT_BURST);
+		printf("  DEFAULT_PKT_BURST: %u (actual nb_pkt_per_burst: %u)\n", DEFAULT_PKT_BURST, nb_pkt_per_burst);
+		printf("  BURST_TX_DRAIN_US: %u us\n", BURST_TX_DRAIN_US);
+		printf("  MAX_TX_BURST: %u\n", MAX_TX_BURST);
+		printf("  enabled_port_mask: 0x%x\n", enabled_port_mask);
+
+		/* Get port info for first enabled port */
+		uint16_t portid;
+		for (portid = 0; portid < RTE_MAX_ETHPORTS; portid++) {
+			if ((enabled_port_mask & (1 << portid)) != 0) {
+				struct rte_eth_dev_info dev_info;
+				struct rte_eth_link link;
+				if (rte_eth_dev_info_get(portid, &dev_info) == 0) {
+					printf("  Port %u driver_name: %s\n", portid, dev_info.driver_name);
+					printf("  Port %u max_tx_queues: %u\n", portid, dev_info.max_tx_queues);
+					printf("  Port %u max_rx_queues: %u\n", portid, dev_info.max_rx_queues);
+				}
+				if (rte_eth_link_get_nowait(portid, &link) == 0) {
+					printf("  Port %u link_speed: %u Mbps, %s\n", portid, link.link_speed,
+						link.link_status ? "UP" : "DOWN");
+				}
+				break; /* Only show first enabled port */
+			}
+		}
+	}
+	printf("=====================================\n");
+	
+	/* Print PCM performance statistics if available */
+	if (pcm_monitoring_is_available()) {
+		/* Collect final statistics BEFORE stopping monitoring */
+		pcm_monitoring_measure_all();
+		
+		/* Print comprehensive PCM statistics */
+		pcm_print_core_statistics();
+		pcm_print_memory_statistics();
+		pcm_print_io_statistics();
+		pcm_print_system_statistics();
+		
+		/* Stop measurement period after collecting statistics */
+		pcm_monitoring_stop_all();
+	}
+}
+
+/* Signal handler for graceful shutdown */
+static void
+signal_handler(int signum)
+{
+	if (signum == SIGINT || signum == SIGTERM) {
+		printf("\nReceived signal %d, shutting down...\n", signum);
+		if (stats_enabled) {
+			print_packet_stats();
+		}
+		stats_enabled = false;
+		force_quit = true;
+	}
+}
+
 /* Performing LPM-based lookups. 8< */
 static inline uint16_t
 lpm_get_ipv4_dst_port(const struct rte_ipv4_hdr *ipv4_hdr,
@@ -156,6 +379,17 @@ lpm_main_loop(__rte_unused void *dummy)
 	lcore_id = rte_lcore_id();
 	qconf = &lcore_conf[lcore_id];
 
+	/* Initialize packet statistics for this lcore */
+	lcore_stats[lcore_id].rx_packets = 0;
+	lcore_stats[lcore_id].tx_packets = 0;
+	lcore_stats[lcore_id].start_time = rte_rdtsc();
+
+	/* Install signal handlers only on master lcore */
+	if (rte_lcore_id() == rte_get_main_lcore()) {
+		signal(SIGINT, signal_handler);
+		signal(SIGTERM, signal_handler);
+	}
+
 	const uint16_t n_rx_q = qconf->n_rx_queue;
 	const uint16_t n_tx_p = qconf->n_tx_port;
 	if (n_rx_q == 0) {
@@ -163,17 +397,31 @@ lpm_main_loop(__rte_unused void *dummy)
 		return 0;
 	}
 
-	RTE_LOG(INFO, L3FWD, "entering main loop on lcore %u\n", lcore_id);
-
+	RTE_LOG(INFO, L3FWD, "[lpm] entering main loop on lcore %u\n", lcore_id);
 	for (i = 0; i < n_rx_q; i++) {
-
 		portid = qconf->rx_queue_list[i].port_id;
 		queueid = qconf->rx_queue_list[i].queue_id;
 		RTE_LOG(INFO, L3FWD,
-			" -- lcoreid=%u portid=%u rxqueueid=%" PRIu16 "\n",
+			" [RX] lcoreid=%u, port=%u rxq=%hhu\n",
 			lcore_id, portid, queueid);
 	}
 
+	for (i = 0; i < n_tx_p; i++) {
+		portid = qconf->tx_port_id[i];
+		RTE_LOG(INFO, L3FWD,
+			" [TX] lcoreid=%u, port=%u, txq=%hhu\n",
+			lcore_id, portid, qconf->tx_queue_id[portid]);
+	}
+
+	for (i = 0; i < n_rx_q; i++) {
+		portid = qconf->rx_queue_list[i].port_id;
+		queueid = qconf->rx_queue_list[i].queue_id;
+		uint16_t tx_queueid = qconf->tx_queue_id[portid];
+		RTE_LOG(INFO, L3FWD,
+			" -- lcoreid=%u portid=%u rxqueueid=%" PRIu16 " txqueueid=%" PRIu16 "\n",
+			lcore_id, portid, queueid, tx_queueid);
+	}
+
 	cur_tsc = rte_rdtsc();
 	prev_tsc = cur_tsc;
 
@@ -189,6 +437,9 @@ lpm_main_loop(__rte_unused void *dummy)
 				portid = qconf->tx_port_id[i];
 				if (qconf->tx_mbufs[portid].len == 0)
 					continue;
+
+				L3FWD_DEBUG_LOG("lcore %u sending %u packets to port %u queue %u\n",
+					lcore_id, qconf->tx_mbufs[portid].len, portid, qconf->tx_queue_id[portid]);
 				send_burst(qconf,
 					qconf->tx_mbufs[portid].len,
 					portid);
@@ -209,6 +460,21 @@ lpm_main_loop(__rte_unused void *dummy)
 			if (nb_rx == 0)
 				continue;
 
+			/* Update RX packet statistics */
+			if (stats_enabled) {
+				lcore_stats[lcore_id].rx_packets += nb_rx;
+			}
+
+			L3FWD_DEBUG_LOG("lcore %u received %d packets from port %u queue %u\n", lcore_id, nb_rx, portid, queueid);
+
+			/* Analyze first few packets for debugging */
+			if (L3FWD_DEBUG_LOGS) {
+				/* Analyze only first 3 packets to reduce overhead */
+				// int analyze_count = nb_rx > 3 ? 3 : nb_rx;
+				for (int j = 0; j < nb_rx; j++) {
+					analyze_packet(pkts_burst[j], lcore_id, "RX", queueid);
+				}
+			}
 #if defined RTE_ARCH_X86 || defined __ARM_NEON \
 			 || defined RTE_ARCH_PPC_64
 			l3fwd_lpm_send_packets(nb_rx, pkts_burst,
@@ -222,6 +488,11 @@ lpm_main_loop(__rte_unused void *dummy)
 		cur_tsc = rte_rdtsc();
 	}
 
+	/* Print statistics when main loop exits */
+	if (rte_lcore_id() == rte_get_main_lcore() && stats_enabled) {
+		print_packet_stats();
+	}
+
 	return 0;
 }
 
diff --git a/examples/l3fwd/l3fwd_lpm.h b/examples/l3fwd/l3fwd_lpm.h
index 4ee61e8d88..b2f0682abb 100644
--- a/examples/l3fwd/l3fwd_lpm.h
+++ b/examples/l3fwd/l3fwd_lpm.h
@@ -12,6 +12,7 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 	struct rte_ether_hdr *eth_hdr;
 	struct rte_ipv4_hdr *ipv4_hdr;
 	uint16_t dst_port;
+	unsigned int lcore_id = rte_lcore_id();
 
 	eth_hdr = rte_pktmbuf_mtod(m, struct rte_ether_hdr *);
 
@@ -23,6 +24,7 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 #ifdef DO_RFC_1812_CHECKS
 		/* Check to make sure the packet is valid (RFC1812) */
 		if (is_valid_ipv4_pkt(ipv4_hdr, m->pkt_len, m->ol_flags) < 0) {
+			lcore_stats[lcore_id].dropped_invalid_ipv4++;
 			rte_pktmbuf_free(m);
 			return;
 		}
@@ -31,8 +33,11 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 						qconf->ipv4_lookup_struct);
 
 		if (dst_port >= RTE_MAX_ETHPORTS ||
-			(enabled_port_mask & 1 << dst_port) == 0)
-			dst_port = portid;
+			(enabled_port_mask & 1 << dst_port) == 0) {
+			lcore_stats[lcore_id].dropped_no_route++;
+			rte_pktmbuf_free(m);
+			return;
+		}
 
 #ifdef DO_RFC_1812_CHECKS
 		/* Update time to live and header checksum */
@@ -58,8 +63,11 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 					qconf->ipv6_lookup_struct);
 
 		if (dst_port >= RTE_MAX_ETHPORTS ||
-			(enabled_port_mask & 1 << dst_port) == 0)
-			dst_port = portid;
+			(enabled_port_mask & 1 << dst_port) == 0) {
+			lcore_stats[lcore_id].dropped_no_route++;
+			rte_pktmbuf_free(m);
+			return;
+		}
 
 		/* dst addr */
 		*(uint64_t *)&eth_hdr->dst_addr = dest_eth_addr[dst_port];
@@ -71,6 +79,7 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 		send_single_packet(qconf, m, dst_port);
 	} else {
 		/* Free the mbuf that contains non-IPV4/IPV6 packet */
+		lcore_stats[lcore_id].dropped_non_ip++;
 		rte_pktmbuf_free(m);
 	}
 }
diff --git a/examples/l3fwd/l3fwd_pcm.c b/examples/l3fwd/l3fwd_pcm.c
new file mode 100644
index 0000000000..4ac89fc122
--- /dev/null
+++ b/examples/l3fwd/l3fwd_pcm.c
@@ -0,0 +1,563 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2010-2025 Intel Corporation
+ */
+
+#define _GNU_SOURCE
+#include "l3fwd_pcm.h"
+#include "l3fwd_pcm_wrapper.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <math.h>
+#include <dlfcn.h>
+#include <rte_common.h>
+#include <rte_lcore.h>
+#include <rte_cycles.h>
+#include <rte_log.h>
+
+/* Global PCM state */
+static struct pcm_global_state {
+    bool pcm_initialized;
+    bool monitoring_enabled;
+    bool use_static_wrapper;
+    uint32_t num_lcores;
+    double sampling_interval;
+    struct pcm_lcore_state lcore_states[PCM_MAX_LCORES];
+    struct pcm_core_metrics core_metrics[PCM_MAX_LCORES];
+    struct pcm_memory_metrics memory_metrics[PCM_MAX_SOCKETS];
+    struct pcm_io_metrics io_metrics[PCM_MAX_SOCKETS];
+    struct pcm_system_metrics system_metrics;
+    uint64_t start_timestamp;
+    uint64_t last_measurement_timestamp;
+} g_pcm_state = {0};
+
+/* Helper macros */
+#define PCM_LOG(level, fmt, args...) \
+    rte_log(RTE_LOG_ ## level, RTE_LOGTYPE_USER1, "[PCM] " fmt "\n", ##args)
+
+#define NSEC_PER_SEC 1000000000ULL
+#define USEC_PER_SEC 1000000ULL
+
+/* Utility functions */
+static uint64_t get_timestamp_ns(void)
+{
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    return ts.tv_sec * NSEC_PER_SEC + ts.tv_nsec;
+}
+
+/* Core PCM monitoring functions */
+int pcm_monitoring_init(void)
+{
+    printf("DEBUG: Starting PCM monitoring initialization...\n");
+    
+    if (g_pcm_state.pcm_initialized) {
+        PCM_LOG(WARNING, "PCM monitoring already initialized");
+        return 0;
+    }
+
+    /* Check if PCM is disabled via environment variable */
+    if (getenv("PCM_DISABLED")) {
+        printf("DEBUG: PCM monitoring disabled by PCM_DISABLED environment variable\n");
+        return -1;
+    }
+
+    /* Try static PCM wrapper */
+    printf("DEBUG: Trying static PCM wrapper...\n");
+    if (pcm_wrapper_is_available()) {
+        printf("DEBUG: Static PCM wrapper available, attempting initialization...\n");
+        if (pcm_wrapper_init() == 0) {
+            printf("DEBUG: Static PCM wrapper initialized successfully!\n");
+            
+            /* Initialize global state for static wrapper */
+            memset(&g_pcm_state, 0, sizeof(g_pcm_state));
+            g_pcm_state.pcm_initialized = true;
+            g_pcm_state.monitoring_enabled = true;
+            g_pcm_state.num_lcores = rte_lcore_count();
+            g_pcm_state.sampling_interval = 1.0;
+            g_pcm_state.use_static_wrapper = true; /* Flag to indicate static wrapper usage */
+
+            /* Initialize per-lcore states */
+            uint32_t lcore_id;
+            RTE_LCORE_FOREACH(lcore_id) {
+                struct pcm_lcore_state *state = &g_pcm_state.lcore_states[lcore_id];
+                state->lcore_id = lcore_id;
+                state->socket_id = rte_lcore_to_socket_id(lcore_id);
+                state->initialized = true;
+                state->monitoring_active = false;
+            }
+
+            /* Get and display system information */
+            char sys_info[1024];
+            if (pcm_wrapper_get_system_info(sys_info, sizeof(sys_info)) == 0) {
+                printf("=== PCM System Information ===\n%s=== End PCM System Info ===\n", sys_info);
+            }
+
+            PCM_LOG(INFO, "PCM monitoring initialized successfully with static wrapper for %u lcores", 
+                    g_pcm_state.num_lcores);
+            return 0;
+        } else {
+            printf("DEBUG: Static PCM wrapper initialization failed\n");
+        }
+    } else {
+        printf("DEBUG: Static PCM wrapper not available\n");
+    }
+
+    /* If static wrapper failed, return error (no fallback to dynamic loading to avoid GLIBCXX issues) */
+    PCM_LOG(ERR, "Failed to initialize PCM monitoring (static wrapper not available or failed)");
+    return -1;
+}
+
+void pcm_monitoring_cleanup(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    /* Stop monitoring on all active lcores */
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        if (g_pcm_state.lcore_states[lcore_id].monitoring_active) {
+            pcm_monitoring_stop_lcore(lcore_id);
+        }
+    }
+
+    /* Cleanup PCM */
+    if (g_pcm_state.use_static_wrapper) {
+        pcm_wrapper_cleanup();
+    }
+
+    /* Reset global state */
+    memset(&g_pcm_state, 0, sizeof(g_pcm_state));
+    
+    PCM_LOG(INFO, "PCM monitoring cleanup completed");
+}
+
+int pcm_monitoring_start_all(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        PCM_LOG(ERR, "PCM not initialized");
+        return -1;
+    }
+
+    /* Start measurement period in PCM wrapper */
+    if (g_pcm_state.use_static_wrapper) {
+        if (pcm_wrapper_start_measurement() != 0) {
+            PCM_LOG(ERR, "Failed to start PCM measurement");
+            return -1;
+        }
+    }
+
+    g_pcm_state.start_timestamp = get_timestamp_ns();
+    
+    /* Start monitoring on all available lcores */
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        pcm_monitoring_start_lcore(lcore_id);
+    }
+
+    printf("Starting PCM monitoring on all lcores...\n");
+    return 0;
+}
+
+int pcm_monitoring_stop_all(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return -1;
+    }
+
+    /* Stop measurement period in PCM wrapper */
+    if (g_pcm_state.use_static_wrapper) {
+        if (pcm_wrapper_stop_measurement() != 0) {
+            PCM_LOG(ERR, "Failed to stop PCM measurement");
+            return -1;
+        }
+    }
+
+    /* Stop monitoring on all lcores */
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        pcm_monitoring_stop_lcore(lcore_id);
+    }
+
+    printf("Stopped PCM monitoring on all lcores\n");
+    return 0;
+}
+
+int pcm_monitoring_start_lcore(uint32_t lcore_id)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return -1;
+    }
+
+    if (lcore_id >= RTE_MAX_LCORE) {
+        PCM_LOG(ERR, "Invalid lcore ID: %u", lcore_id);
+        return -1;
+    }
+
+    struct pcm_lcore_state *state = &g_pcm_state.lcore_states[lcore_id];
+    
+    if (!state->initialized) {
+        PCM_LOG(ERR, "Lcore %u not initialized", lcore_id);
+        return -1;
+    }
+
+    if (state->monitoring_active) {
+        PCM_LOG(WARNING, "Monitoring already active on lcore %u", lcore_id);
+        return 0;
+    }
+
+    state->monitoring_active = true;
+    PCM_LOG(INFO, "Started monitoring on lcore %u", lcore_id);
+    return 0;
+}
+
+int pcm_monitoring_stop_lcore(uint32_t lcore_id)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return -1;
+    }
+
+    if (lcore_id >= RTE_MAX_LCORE) {
+        return -1;
+    }
+
+    struct pcm_lcore_state *state = &g_pcm_state.lcore_states[lcore_id];
+    
+    if (!state->monitoring_active) {
+        return 0;
+    }
+
+    state->monitoring_active = false;
+    PCM_LOG(INFO, "Stopped monitoring on lcore %u", lcore_id);
+    return 0;
+}
+
+int pcm_monitoring_measure_all(void)
+{
+    if (!g_pcm_state.pcm_initialized || !g_pcm_state.use_static_wrapper) {
+        return -1;
+    }
+
+    uint64_t timestamp = get_timestamp_ns();
+    uint32_t lcore_id;
+
+    /* Collect core metrics for all active lcores */
+    RTE_LCORE_FOREACH(lcore_id) {
+        if (g_pcm_state.lcore_states[lcore_id].monitoring_active) {
+            struct pcm_core_metrics *metrics = &g_pcm_state.core_metrics[lcore_id];
+            pcm_core_counters_t counters;
+            
+            printf("DEBUG: Collecting metrics for lcore %u\n", lcore_id);
+            if (pcm_wrapper_get_core_counters(lcore_id, &counters) == 0) {
+                printf("DEBUG: Successfully got counters for lcore %u: cycles=%lu, instructions=%lu\n", 
+                       lcore_id, counters.cycles, counters.instructions);
+                metrics->cycles = counters.cycles;
+                metrics->instructions = counters.instructions;
+                metrics->l2_cache_hits = counters.l2_cache_hits;
+                metrics->l2_cache_misses = counters.l2_cache_misses;
+                metrics->l3_cache_hits = counters.l3_cache_hits;
+                metrics->l3_cache_misses = counters.l3_cache_misses;
+                metrics->ipc = counters.ipc;
+                metrics->l2_cache_hit_ratio = counters.l2_cache_hit_ratio;
+                metrics->l3_cache_hit_ratio = counters.l3_cache_hit_ratio;
+                metrics->frequency_ghz = counters.frequency_ghz;
+                metrics->cpu_utilization = counters.cpu_utilization;
+                metrics->energy_joules = counters.energy_joules;
+                metrics->timestamp = timestamp;
+            } else {
+                printf("DEBUG: Failed to get counters for lcore %u\n", lcore_id);
+            }
+        } else {
+            printf("DEBUG: Lcore %u not monitoring active\n", lcore_id);
+        }
+    }
+
+    /* Collect memory metrics for all sockets */
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_memory_metrics *metrics = &g_pcm_state.memory_metrics[socket];
+        pcm_memory_counters_t counters;
+        
+        if (pcm_wrapper_get_memory_counters(socket, &counters) == 0) {
+            metrics->dram_read_bytes = counters.dram_read_bytes;
+            metrics->dram_write_bytes = counters.dram_write_bytes;
+            metrics->dram_read_bandwidth_mbps = counters.dram_read_bandwidth_mbps;
+            metrics->dram_write_bandwidth_mbps = counters.dram_write_bandwidth_mbps;
+            metrics->memory_controller_utilization = counters.memory_controller_utilization;
+            metrics->numa_local_accesses = counters.numa_local_accesses;
+            metrics->numa_remote_accesses = counters.numa_remote_accesses;
+            metrics->numa_ratio = counters.numa_ratio;
+            metrics->timestamp = timestamp;
+        }
+    }
+
+    /* Collect I/O metrics for all sockets */
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_io_metrics *metrics = &g_pcm_state.io_metrics[socket];
+        pcm_io_counters_t counters;
+        
+        if (pcm_wrapper_get_io_counters(socket, &counters) == 0) {
+            metrics->pcie_read_bytes = counters.pcie_read_bytes;
+            metrics->pcie_write_bytes = counters.pcie_write_bytes;
+            metrics->pcie_read_bandwidth_mbps = counters.pcie_read_bandwidth_mbps;
+            metrics->pcie_write_bandwidth_mbps = counters.pcie_write_bandwidth_mbps;
+            metrics->qpi_upi_data_bytes = counters.qpi_upi_data_bytes;
+            metrics->qpi_upi_utilization = counters.qpi_upi_utilization;
+            metrics->uncore_freq_ghz = counters.uncore_freq_ghz;
+            metrics->imc_reads_gbps = counters.imc_reads_gbps;
+            metrics->imc_writes_gbps = counters.imc_writes_gbps;
+            metrics->timestamp = timestamp;
+        }
+    }
+
+    /* Collect system-wide metrics */
+    pcm_system_counters_t sys_counters;
+    if (pcm_wrapper_get_system_counters(&sys_counters) == 0) {
+        struct pcm_system_metrics *metrics = &g_pcm_state.system_metrics;
+        metrics->active_cores = sys_counters.active_cores;
+        metrics->total_energy_joules = sys_counters.total_energy_joules;
+        metrics->package_energy_joules = sys_counters.package_energy_joules;
+        metrics->dram_energy_joules = sys_counters.dram_energy_joules;
+        metrics->total_ipc = sys_counters.total_ipc;
+        metrics->memory_bandwidth_utilization = sys_counters.memory_bandwidth_utilization;
+        metrics->thermal_throttle_ratio = sys_counters.thermal_throttle_ratio;
+        metrics->timestamp = timestamp;
+    }
+
+    g_pcm_state.last_measurement_timestamp = timestamp;
+    return 0;
+}
+
+/* Enhanced statistics display functions */
+void pcm_print_core_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    printf("\n=====================================\n");
+    printf("Intel PCM Core Performance Statistics\n");
+    printf("=====================================\n");
+    printf("%-5s %-12s %-12s %-6s %-10s %-8s %-8s %-6s %-6s %-8s\n",
+           "Core", "Cycles", "Instructions", "IPC", "L3 Misses", "L2 Hit%", "L3 Hit%", "Freq", "CPU%", "Energy");
+    printf("%-5s %-12s %-12s %-6s %-10s %-8s %-8s %-6s %-6s %-8s\n",
+           "----", "----------", "----------", "----", "---------", "------", "------", "----", "----", "------");
+
+    uint64_t total_cycles = 0, total_instructions = 0, total_l3_misses = 0;
+    double total_energy = 0.0;
+    uint32_t active_cores = 0;
+
+    printf("DEBUG: Starting core statistics print...\n");
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        printf("DEBUG: Checking lcore %u, monitoring_active = %d\n", 
+               lcore_id, g_pcm_state.lcore_states[lcore_id].monitoring_active);
+        if (g_pcm_state.lcore_states[lcore_id].monitoring_active) {
+            struct pcm_core_metrics *metrics = &g_pcm_state.core_metrics[lcore_id];
+            
+            printf("DEBUG: Lcore %u metrics: cycles=%lu, instructions=%lu, ipc=%.2f\n",
+                   lcore_id, metrics->cycles, metrics->instructions, metrics->ipc);
+            
+            printf("%-5u %-12lu %-12lu %-6.2f %-10lu %-8.1f %-8.1f %-6.2f %-6.1f %-8.2f\n",
+                   lcore_id,
+                   metrics->cycles,
+                   metrics->instructions,
+                   metrics->ipc,
+                   metrics->l3_cache_misses,
+                   metrics->l2_cache_hit_ratio * 100.0,
+                   metrics->l3_cache_hit_ratio * 100.0,
+                   metrics->frequency_ghz,
+                   metrics->cpu_utilization * 100.0,
+                   metrics->energy_joules);
+
+            total_cycles += metrics->cycles;
+            total_instructions += metrics->instructions;
+            total_l3_misses += metrics->l3_cache_misses;
+            total_energy += metrics->energy_joules;
+            active_cores++;
+        }
+    }
+
+    printf("%-5s %-12s %-12s %-6s %-10s %-8s %-8s %-6s %-6s %-8s\n",
+           "----", "----------", "----------", "----", "---------", "------", "------", "----", "----", "------");
+    
+    double avg_ipc = total_cycles > 0 ? (double)total_instructions / total_cycles : 0.0;
+    printf("%-5s %-12lu %-12lu %-6.2f %-10lu %-8s %-8s %-6s %-6s %-8.2f\n",
+           "Total", total_cycles, total_instructions, avg_ipc, total_l3_misses, 
+           "-", "-", "-", "-", total_energy);
+    
+    printf("Active Cores: %u\n", active_cores);
+    printf("=====================================\n");
+}
+
+void pcm_print_memory_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    printf("\n=====================================\n");
+    printf("Intel PCM Memory Performance Statistics\n");
+    printf("=====================================\n");
+    printf("%-6s %-12s %-12s %-10s %-10s %-8s %-8s %-8s\n",
+           "Socket", "DRAM Read", "DRAM Write", "Read BW", "Write BW", "MC Util%", "NUMA", "Local%");
+    printf("%-6s %-12s %-12s %-10s %-10s %-8s %-8s %-8s\n",
+           "------", "----------", "-----------", "--------", "---------", "--------", "----", "------");
+
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_memory_metrics *metrics = &g_pcm_state.memory_metrics[socket];
+        
+        if (metrics->timestamp > 0) {
+            printf("%-6u %-12lu %-12lu %-10.1f %-10.1f %-8.1f %-8lu %-8.1f\n",
+                   socket,
+                   metrics->dram_read_bytes,
+                   metrics->dram_write_bytes,
+                   metrics->dram_read_bandwidth_mbps,
+                   metrics->dram_write_bandwidth_mbps,
+                   metrics->memory_controller_utilization * 100.0,
+                   metrics->numa_local_accesses + metrics->numa_remote_accesses,
+                   metrics->numa_ratio * 100.0);
+        }
+    }
+    printf("=====================================\n");
+}
+
+void pcm_print_io_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    printf("\n=====================================\n");
+    printf("Intel PCM I/O Performance Statistics\n");
+    printf("=====================================\n");
+    printf("%-6s %-12s %-12s %-10s %-10s %-8s %-8s %-8s\n",
+           "Socket", "PCIe Read", "PCIe Write", "PCIe R BW", "PCIe W BW", "UPI Util%", "IMC R", "IMC W");
+    printf("%-6s %-12s %-12s %-10s %-10s %-8s %-8s %-8s\n",
+           "------", "----------", "-----------", "---------", "---------", "---------", "-----", "-----");
+
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_io_metrics *metrics = &g_pcm_state.io_metrics[socket];
+        
+        if (metrics->timestamp > 0) {
+            printf("%-6u %-12lu %-12lu %-10.1f %-10.1f %-9.1f %-8.2f %-8.2f\n",
+                   socket,
+                   metrics->pcie_read_bytes,
+                   metrics->pcie_write_bytes,
+                   metrics->pcie_read_bandwidth_mbps,
+                   metrics->pcie_write_bandwidth_mbps,
+                   metrics->qpi_upi_utilization * 100.0,
+                   metrics->imc_reads_gbps,
+                   metrics->imc_writes_gbps);
+        }
+    }
+    printf("=====================================\n");
+}
+
+void pcm_print_system_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    struct pcm_system_metrics *metrics = &g_pcm_state.system_metrics;
+    
+    printf("\n=====================================\n");
+    printf("Intel PCM System-Wide Statistics\n");
+    printf("=====================================\n");
+    printf("Active Cores: %u\n", metrics->active_cores);
+    printf("Total IPC: %.2f\n", metrics->total_ipc);
+    printf("Total Energy: %.2f J\n", metrics->total_energy_joules);
+    printf("Package Energy: %.2f J\n", metrics->package_energy_joules);
+    printf("DRAM Energy: %.2f J\n", metrics->dram_energy_joules);
+    printf("Memory BW Utilization: %.1f%%\n", metrics->memory_bandwidth_utilization * 100.0);
+    printf("Thermal Throttle Ratio: %.1f%%\n", metrics->thermal_throttle_ratio * 100.0);
+    printf("=====================================\n");
+}
+
+/* Additional utility functions */
+
+bool pcm_monitoring_is_available(void)
+{
+    return g_pcm_state.pcm_initialized;
+}
+
+int pcm_monitoring_get_lcore_metrics(uint32_t lcore_id, struct pcm_core_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics || lcore_id >= RTE_MAX_LCORE) {
+        return -1;
+    }
+    
+    if (!g_pcm_state.lcore_states[lcore_id].monitoring_active) {
+        return -1;
+    }
+    
+    *metrics = g_pcm_state.core_metrics[lcore_id];
+    return 0;
+}
+
+int pcm_monitoring_get_memory_metrics(uint32_t socket_id, struct pcm_memory_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics || socket_id >= PCM_MAX_SOCKETS) {
+        return -1;
+    }
+    
+    *metrics = g_pcm_state.memory_metrics[socket_id];
+    return 0;
+}
+
+int pcm_monitoring_get_io_metrics(uint32_t socket_id, struct pcm_io_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics || socket_id >= PCM_MAX_SOCKETS) {
+        return -1;
+    }
+    
+    *metrics = g_pcm_state.io_metrics[socket_id];
+    return 0;
+}
+
+int pcm_monitoring_get_system_metrics(struct pcm_system_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics) {
+        return -1;
+    }
+    
+    *metrics = g_pcm_state.system_metrics;
+    return 0;
+}
+
+void pcm_monitoring_print_summary(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        printf("PCM monitoring not available\n");
+        return;
+    }
+    
+    printf("\n=== COMPREHENSIVE PCM PERFORMANCE SUMMARY ===\n");
+    pcm_print_core_statistics();
+    pcm_print_memory_statistics();
+    pcm_print_io_statistics();
+    pcm_print_system_statistics();
+    printf("=== END PCM PERFORMANCE SUMMARY ===\n");
+}
+
+int pcm_monitoring_get_info(char *info_buffer, size_t buffer_size)
+{
+    if (!info_buffer || buffer_size == 0) {
+        return -1;
+    }
+
+    if (!g_pcm_state.pcm_initialized) {
+        snprintf(info_buffer, buffer_size, "PCM monitoring not initialized");
+        return -1;
+    }
+
+    if (g_pcm_state.use_static_wrapper) {
+        return pcm_wrapper_get_system_info(info_buffer, buffer_size);
+    } else {
+        snprintf(info_buffer, buffer_size, "PCM monitoring active (fallback mode)");
+        return 0;
+    }
+}
diff --git a/examples/l3fwd/l3fwd_pcm.h b/examples/l3fwd/l3fwd_pcm.h
new file mode 100644
index 0000000000..998019c89f
--- /dev/null
+++ b/examples/l3fwd/l3fwd_pcm.h
@@ -0,0 +1,198 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2010-2025 Intel Corporation
+ */
+
+#ifndef __L3FWD_PCM_H__
+#define __L3FWD_PCM_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <rte_common.h>
+#include <rte_lcore.h>
+#include "l3fwd_pcm_wrapper.h"
+
+/* Maximum number of performance events to track */
+#define PCM_MAX_EVENTS 16
+#define PCM_MAX_LCORES RTE_MAX_LCORE
+#define PCM_MAX_SOCKETS 8
+
+/* Enhanced performance metrics structure */
+struct pcm_core_metrics {
+    uint64_t instructions;          /* Instructions retired */
+    uint64_t cycles;                /* CPU cycles */
+    uint64_t l2_cache_hits;        /* L2 cache hits */
+    uint64_t l2_cache_misses;      /* L2 cache misses */
+    uint64_t l3_cache_hits;        /* L3 cache hits */
+    uint64_t l3_cache_misses;      /* L3 cache misses (LLC) */
+    double ipc;                    /* Instructions per cycle */
+    double l2_cache_hit_ratio;     /* L2 cache hit ratio */
+    double l3_cache_hit_ratio;     /* L3 cache hit ratio */
+    double frequency_ghz;          /* Core frequency in GHz */
+    double cpu_utilization;        /* CPU utilization percentage */
+    double energy_joules;          /* Energy consumption in Joules */
+    uint64_t timestamp;            /* Timestamp of measurement */
+};
+
+/* Memory performance metrics structure */
+struct pcm_memory_metrics {
+    uint64_t dram_read_bytes;      /* DRAM read bytes */
+    uint64_t dram_write_bytes;     /* DRAM write bytes */
+    double dram_read_bandwidth_mbps;    /* DRAM read bandwidth MB/s */
+    double dram_write_bandwidth_mbps;   /* DRAM write bandwidth MB/s */
+    double memory_controller_utilization; /* Memory controller utilization */
+    uint64_t numa_local_accesses;      /* NUMA local memory accesses */
+    uint64_t numa_remote_accesses;     /* NUMA remote memory accesses */
+    double numa_ratio;                 /* NUMA locality ratio */
+    uint64_t timestamp;
+};
+
+/* I/O and uncore performance metrics structure */
+struct pcm_io_metrics {
+    uint64_t pcie_read_bytes;      /* PCIe read bytes */
+    uint64_t pcie_write_bytes;     /* PCIe write bytes */
+    double pcie_read_bandwidth_mbps;    /* PCIe read bandwidth MB/s */
+    double pcie_write_bandwidth_mbps;   /* PCIe write bandwidth MB/s */
+    uint64_t qpi_upi_data_bytes;       /* QPI/UPI data bytes */
+    double qpi_upi_utilization;        /* QPI/UPI utilization percentage */
+    uint64_t uncore_freq_ghz;          /* Uncore frequency GHz */
+    double imc_reads_gbps;             /* IMC reads GB/s */
+    double imc_writes_gbps;            /* IMC writes GB/s */
+    uint64_t timestamp;
+};
+
+/* System-wide PCM metrics */
+struct pcm_system_metrics {
+    uint32_t active_cores;              /* Number of active cores */
+    double total_energy_joules;         /* Total energy consumption */
+    double package_energy_joules;       /* Package energy consumption */
+    double dram_energy_joules;          /* DRAM energy consumption */
+    double total_ipc;                   /* System-wide IPC */
+    double memory_bandwidth_utilization; /* Memory bandwidth utilization % */
+    double thermal_throttle_ratio;      /* Thermal throttling ratio */
+    uint64_t timestamp;
+};
+
+/* Per-lcore PCM state */
+struct pcm_lcore_state {
+    uint32_t lcore_id;
+    uint32_t socket_id;
+    bool initialized;
+    bool monitoring_active;
+};
+
+/* Function declarations */
+
+/**
+ * Initialize PCM monitoring system
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_init(void);
+
+/**
+ * Cleanup PCM monitoring system
+ */
+void pcm_monitoring_cleanup(void);
+
+/**
+ * Start monitoring on a specific lcore
+ * @param lcore_id: The lcore to start monitoring
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_start_lcore(uint32_t lcore_id);
+
+/**
+ * Stop monitoring on a specific lcore
+ * @param lcore_id: The lcore to stop monitoring
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_stop_lcore(uint32_t lcore_id);
+
+/**
+ * Start monitoring on all active lcores
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_start_all(void);
+
+/**
+ * Stop monitoring on all active lcores
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_stop_all(void);
+
+/**
+ * Take measurements on all active lcores and collect comprehensive statistics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_measure_all(void);
+
+/**
+ * Check if PCM monitoring is available and initialized
+ * @return true if available, false otherwise
+ */
+bool pcm_monitoring_is_available(void);
+
+/**
+ * Get current core metrics for a specific lcore
+ * @param lcore_id: The lcore to query
+ * @param metrics: Pointer to store the core metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_lcore_metrics(uint32_t lcore_id, struct pcm_core_metrics *metrics);
+
+/**
+ * Get memory metrics for a specific socket
+ * @param socket_id: The socket to query
+ * @param metrics: Pointer to store the memory metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_memory_metrics(uint32_t socket_id, struct pcm_memory_metrics *metrics);
+
+/**
+ * Get I/O metrics for a specific socket
+ * @param socket_id: The socket to query
+ * @param metrics: Pointer to store the I/O metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_io_metrics(uint32_t socket_id, struct pcm_io_metrics *metrics);
+
+/**
+ * Get system-wide metrics
+ * @param metrics: Pointer to store the system metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_system_metrics(struct pcm_system_metrics *metrics);
+
+/**
+ * Print core performance statistics for all lcores
+ */
+void pcm_print_core_statistics(void);
+
+/**
+ * Print memory performance statistics for all sockets
+ */
+void pcm_print_memory_statistics(void);
+
+/**
+ * Print I/O performance statistics for all sockets
+ */
+void pcm_print_io_statistics(void);
+
+/**
+ * Print system-wide performance statistics
+ */
+void pcm_print_system_statistics(void);
+
+/**
+ * Print comprehensive performance summary (all categories)
+ */
+void pcm_monitoring_print_summary(void);
+
+/**
+ * Get PCM system information
+ * @param info_buffer: Buffer to store system info
+ * @param buffer_size: Size of the buffer
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_info(char *info_buffer, size_t buffer_size);
+
+#endif /* __L3FWD_PCM_H__ */
diff --git a/examples/l3fwd/l3fwd_pcm_new.h b/examples/l3fwd/l3fwd_pcm_new.h
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/examples/l3fwd/l3fwd_pcm_simple.c b/examples/l3fwd/l3fwd_pcm_simple.c
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/examples/l3fwd/l3fwd_pcm_wrapper.cpp b/examples/l3fwd/l3fwd_pcm_wrapper.cpp
new file mode 100644
index 0000000000..38518923d0
--- /dev/null
+++ b/examples/l3fwd/l3fwd_pcm_wrapper.cpp
@@ -0,0 +1,490 @@
+// C++ wrapper for PCM that will be statically linked
+#include "l3fwd_pcm_wrapper.h"
+#include <iostream>
+#include <memory>
+#include <cstdlib>
+#include <cstdio>
+#include <cstring>
+#include <unistd.h>
+
+// Intel PCM includes
+#include "cpucounters.h"
+
+using namespace pcm;
+
+extern "C" {
+
+// Global PCM state
+static PCM* g_pcm_instance = nullptr;
+static bool g_initialized = false;
+static bool g_measurement_active = false;
+
+// Counter state storage
+static std::vector<CoreCounterState> g_before_core_states;
+static std::vector<CoreCounterState> g_after_core_states;
+static std::vector<SocketCounterState> g_before_socket_states;
+static std::vector<SocketCounterState> g_after_socket_states;
+static SystemCounterState g_before_system_state;
+static SystemCounterState g_after_system_state;
+
+int pcm_wrapper_is_available(void) {
+    // Always return 1 for now, as PCM is statically linked
+    return 1;
+}
+
+int pcm_wrapper_init(void) {
+    if (g_initialized) {
+        return 0;  // Already initialized
+    }
+    
+    g_pcm_instance = PCM::getInstance();
+    if (!g_pcm_instance) {
+        printf("ERROR: Failed to get PCM instance\n");
+        return -1;
+    }
+    
+    // Check access permissions
+    printf("*** Attempting to program Intel PCM counters... ***\n");
+    auto status = g_pcm_instance->program();
+    
+    if (status == PCM::Success) {
+        printf("*** SUCCESS: Intel PCM counters programmed successfully! ***\n");
+        g_initialized = true;
+        
+        // Initialize state vectors
+        uint32_t num_cores = g_pcm_instance->getNumCores();
+        uint32_t num_sockets = g_pcm_instance->getNumSockets();
+        
+        g_before_core_states.resize(num_cores);
+        g_after_core_states.resize(num_cores);
+        g_before_socket_states.resize(num_sockets);
+        g_after_socket_states.resize(num_sockets);
+        
+        return 0;
+    } else if (status == PCM::MSRAccessDenied) {
+        printf("WARNING: MSR access denied, trying without MSR\n");
+        // Try programming with reduced privileges
+        status = g_pcm_instance->program(PCM::DEFAULT_EVENTS, nullptr, false, -1);
+        if (status == PCM::Success) {
+            printf("*** SUCCESS: Intel PCM counters programmed successfully (no MSR mode)! ***\n");
+            g_initialized = true;
+            return 0;
+        }
+    } else if (status == PCM::PMUBusy) {
+        printf("WARNING: PMU busy, trying to reset and retry\n");
+        g_pcm_instance->resetPMU();
+        status = g_pcm_instance->program();
+        if (status == PCM::Success) {
+            printf("*** SUCCESS: Intel PCM counters programmed successfully after reset! ***\n");
+            g_initialized = true;
+            
+            // Initialize state vectors
+            uint32_t num_cores = g_pcm_instance->getNumCores();
+            uint32_t num_sockets = g_pcm_instance->getNumSockets();
+            
+            g_before_core_states.resize(num_cores);
+            g_after_core_states.resize(num_cores);
+            g_before_socket_states.resize(num_sockets);
+            g_after_socket_states.resize(num_sockets);
+            
+            return 0;
+        }
+    }
+    
+    // Print detailed error information
+    printf("ERROR: Failed to program PCM counters. Status: %d\n", (int)status);
+    switch (status) {
+        case PCM::MSRAccessDenied:
+            printf("  - MSR access denied. Try running with sudo or check permissions.\n");
+            break;
+        case PCM::PMUBusy:
+            printf("  - PMU is busy. Another profiling tool might be running.\n");
+            break;
+        case PCM::UnknownError:
+            printf("  - Unknown error occurred.\n");
+            break;
+        default:
+            printf("  - Unhandled error code: %d\n", (int)status);
+            break;
+    }
+    
+    return -1;
+}
+
+void pcm_wrapper_cleanup(void) {
+    if (g_pcm_instance) {
+        g_pcm_instance->cleanup();
+        g_pcm_instance = nullptr;
+    }
+    g_initialized = false;
+    g_measurement_active = false;
+    
+    // Clear state vectors
+    g_before_core_states.clear();
+    g_after_core_states.clear();
+    g_before_socket_states.clear();
+    g_after_socket_states.clear();
+}
+
+int pcm_wrapper_start_measurement(void) {
+    if (!g_initialized || !g_pcm_instance) {
+        return -1;
+    }
+    
+    try {
+        printf("DEBUG: Starting PCM measurement - clearing old states\n");
+        
+        // Wait a bit to ensure clean counter state
+        usleep(100000); // 100ms
+        
+        printf("DEBUG: Capturing initial PCM states\n");
+        g_before_system_state = getSystemCounterState();
+        
+        for (uint32_t i = 0; i < g_pcm_instance->getNumCores(); ++i) {
+            g_before_core_states[i] = getCoreCounterState(i);
+        }
+        
+        for (uint32_t i = 0; i < g_pcm_instance->getNumSockets(); ++i) {
+            g_before_socket_states[i] = getSocketCounterState(i);
+        }
+        
+        g_measurement_active = true;
+        printf("PCM measurement started, captured BEFORE states for %u cores\n", 
+               g_pcm_instance->getNumCores());
+        return 0;
+    } catch (...) {
+        printf("Error capturing initial PCM states\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_stop_measurement(void) {
+    if (!g_initialized || !g_pcm_instance) {
+        return -1;
+    }
+    
+    try {
+        printf("DEBUG: Stopping PCM measurement - capturing final states\n");
+        
+        // Always capture final states regardless of g_measurement_active
+        g_after_system_state = getSystemCounterState();
+        
+        for (uint32_t i = 0; i < g_pcm_instance->getNumCores(); ++i) {
+            g_after_core_states[i] = getCoreCounterState(i);
+        }
+        
+        for (uint32_t i = 0; i < g_pcm_instance->getNumSockets(); ++i) {
+            g_after_socket_states[i] = getSocketCounterState(i);
+        }
+        
+        g_measurement_active = false;
+        printf("PCM measurement stopped, captured AFTER states for %u cores\n", 
+               g_pcm_instance->getNumCores());
+        return 0;
+    } catch (...) {
+        printf("Error capturing final PCM states\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_basic_counters(uint32_t core_id, uint64_t* cycles, uint64_t* instructions) {
+    if (!g_initialized || !g_pcm_instance || !cycles || !instructions) {
+        return -1;
+    }
+    
+    try {
+        if (core_id >= g_pcm_instance->getNumCores()) {
+            return -1;
+        }
+        
+        *cycles = getCycles(g_before_core_states[core_id], g_after_core_states[core_id]);
+        *instructions = getInstructionsRetired(g_before_core_states[core_id], g_after_core_states[core_id]);
+        return 0;
+    } catch (...) {
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_core_counters(uint32_t core_id, pcm_core_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        printf("DEBUG: pcm_wrapper_get_core_counters - not initialized or null counters\n");
+        return -1;
+    }
+    
+    try {
+        // Get current online CPU info to map DPDK lcore to PCM core
+        uint32_t num_cores = g_pcm_instance->getNumCores();
+        uint32_t pcm_core_id = core_id;
+        
+        // For DPDK, typically lcore 0-3 maps to first 4 online cores
+        // But we need to validate the mapping is reasonable
+        if (pcm_core_id >= num_cores) {
+            printf("Warning: DPDK lcore %u exceeds PCM cores %u, using modulo mapping\n", 
+                   core_id, num_cores);
+            pcm_core_id = core_id % num_cores;
+        }
+        
+        // Use instant measurement approach with short interval
+        printf("DEBUG: Taking instant PCM measurement for core %u (PCM core %u)\n", core_id, pcm_core_id);
+        
+        // Take two consecutive measurements with a small delay
+        CoreCounterState state1 = getCoreCounterState(pcm_core_id);
+        usleep(10000); // 10ms delay
+        CoreCounterState state2 = getCoreCounterState(pcm_core_id);
+        
+        // Use PCM's built-in metric calculation functions directly
+        double ipc = getIPC(state1, state2);
+        double freq_ghz = getAverageFrequency(state1, state2) / 1e9;
+        double util = getActiveRelativeFrequency(state1, state2); // Use relative frequency as utilization proxy
+        
+        // Get cache hit ratios directly
+        double l2_hit_ratio = getL2CacheHitRatio(state1, state2);
+        double l3_hit_ratio = getL3CacheHitRatio(state1, state2);
+        
+        printf("DEBUG: Core %u PCM metrics: IPC=%.3f, Freq=%.2f GHz, Util=%.1f%%, L2Hit=%.1f%%, L3Hit=%.1f%%\n", 
+               core_id, ipc, freq_ghz, util * 100.0, l2_hit_ratio * 100.0, l3_hit_ratio * 100.0);
+        
+        // Store the calculated metrics
+        counters->ipc = ipc;
+        counters->frequency_ghz = freq_ghz;
+        counters->cpu_utilization = util;  // Changed from utilization to cpu_utilization
+        counters->l2_cache_hit_ratio = l2_hit_ratio;
+        counters->l3_cache_hit_ratio = l3_hit_ratio;
+        
+        // For cycle and instruction counts, use approximation if the values are reasonable
+        uint64_t cycles_raw = getCycles(state1, state2);
+        uint64_t instructions_raw = getInstructionsRetired(state1, state2);
+        
+        // Only set these if they look reasonable (small positive numbers for 10ms interval)
+        if (cycles_raw > 0 && cycles_raw < 100000000) { // Less than 100M cycles in 10ms seems reasonable
+            counters->cycles = cycles_raw;
+            counters->instructions = instructions_raw;
+        } else {
+            // Estimate from frequency and time if raw counters don't work
+            counters->cycles = (uint64_t)(freq_ghz * 1e9 * 0.01); // 10ms worth
+            counters->instructions = (uint64_t)(counters->cycles * ipc);
+        }
+        
+        // Cache miss counts - use heuristics if available
+        uint64_t l2_misses = getL2CacheMisses(state1, state2);
+        uint64_t l3_misses = getL3CacheMisses(state1, state2);
+        uint64_t l2_hits = getL2CacheHits(state1, state2);
+        uint64_t l3_hits = getL3CacheHits(state1, state2);
+        
+        // Use reasonable defaults if raw counts are problematic
+        if (l2_misses < 10000000) counters->l2_cache_misses = l2_misses;
+        else counters->l2_cache_misses = 0;
+        
+        if (l3_misses < 10000000) counters->l3_cache_misses = l3_misses;
+        else counters->l3_cache_misses = 0;
+        
+        if (l2_hits < 10000000) counters->l2_cache_hits = l2_hits;
+        else counters->l2_cache_hits = 0;
+        
+        if (l3_hits < 10000000) counters->l3_cache_hits = l3_hits;
+        else counters->l3_cache_hits = 0;
+        
+        // Energy estimation
+        counters->energy_joules = 0.0; // Default for now
+        
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error in PCM counter calculation: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error in PCM counter calculation\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_memory_counters(uint32_t socket_id, pcm_memory_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+    
+    try {
+        if (socket_id >= g_pcm_instance->getNumSockets()) {
+            return -1;
+        }
+        
+        printf("DEBUG: Taking instant memory measurement for socket %u\n", socket_id);
+        
+        // Take two consecutive measurements
+        SocketCounterState state1 = getSocketCounterState(socket_id);
+        usleep(10000); // 10ms delay  
+        SocketCounterState state2 = getSocketCounterState(socket_id);
+        
+        // Use PCM's built-in bandwidth calculation methods
+        uint64_t bytes_read = getBytesReadFromMC(state1, state2);
+        uint64_t bytes_written = getBytesWrittenToMC(state1, state2);
+        
+        printf("DEBUG: Socket %u instant measurement: read=%lu bytes, write=%lu bytes\n", 
+               socket_id, bytes_read, bytes_written);
+        
+        // Convert to reasonable values (10ms measurement period)
+        double time_sec = 0.01; // 10ms
+        counters->dram_read_bytes = bytes_read;
+        counters->dram_write_bytes = bytes_written;
+        counters->dram_read_bandwidth_mbps = (double)bytes_read / (1024.0 * 1024.0) / time_sec;
+        counters->dram_write_bandwidth_mbps = (double)bytes_written / (1024.0 * 1024.0) / time_sec;
+        
+        // Estimate utilization 
+        double total_bw = counters->dram_read_bandwidth_mbps + counters->dram_write_bandwidth_mbps;
+        counters->memory_controller_utilization = (total_bw / 100000.0); // Assume 100 GB/s max = 100000 MB/s
+        if (counters->memory_controller_utilization > 1.0) counters->memory_controller_utilization = 0.0;
+        
+        // Initialize NUMA fields properly
+        counters->numa_local_accesses = 0;
+        counters->numa_remote_accesses = 0;
+        counters->numa_ratio = 0.8; // Default
+        
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error in memory counter calculation: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error in memory counter calculation\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_io_counters(uint32_t socket_id, pcm_io_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+    
+    try {
+        if (socket_id >= g_pcm_instance->getNumSockets()) {
+            return -1;
+        }
+        
+        printf("DEBUG: Taking instant I/O measurement for socket %u\n", socket_id);
+        
+        // Take two consecutive measurements for I/O counters
+        SocketCounterState state1 = getSocketCounterState(socket_id);
+        usleep(10000); // 10ms delay
+        SocketCounterState state2 = getSocketCounterState(socket_id);
+        
+        // Try to get PCIe read/write bytes using PCM functions
+        uint64_t pcie_read_bytes = 0;
+        uint64_t pcie_write_bytes = 0;
+        
+        // PCM might have specific PCIe counter functions - try memory controller as proxy
+        uint64_t mc_reads = getBytesReadFromMC(state1, state2);
+        uint64_t mc_writes = getBytesWrittenToMC(state1, state2);
+        
+        // For network-intensive workloads, significant portion of memory traffic is PCIe-related
+        // Estimate PCIe traffic as a fraction of memory controller traffic
+        double pcie_fraction = 0.3; // Assume 30% of memory traffic is PCIe-related
+        
+        if (mc_reads < 10000000000ULL && mc_writes < 10000000000ULL) { // Sanity check
+            pcie_read_bytes = (uint64_t)(mc_reads * pcie_fraction);
+            pcie_write_bytes = (uint64_t)(mc_writes * pcie_fraction);
+        }
+        
+        printf("DEBUG: Socket %u I/O measurement: PCIe read=%lu bytes, write=%lu bytes\n", 
+               socket_id, pcie_read_bytes, pcie_write_bytes);
+        
+        // Calculate bandwidth (10ms measurement period)
+        double time_sec = 0.01;
+        counters->pcie_read_bytes = pcie_read_bytes;
+        counters->pcie_write_bytes = pcie_write_bytes;
+        counters->pcie_read_bandwidth_mbps = (double)pcie_read_bytes / (1024.0 * 1024.0) / time_sec;
+        counters->pcie_write_bandwidth_mbps = (double)pcie_write_bytes / (1024.0 * 1024.0) / time_sec;
+        
+        // Memory controller bandwidth (IMC)
+        counters->imc_reads_gbps = (double)mc_reads / (1024.0 * 1024.0 * 1024.0) / time_sec;
+        counters->imc_writes_gbps = (double)mc_writes / (1024.0 * 1024.0 * 1024.0) / time_sec;
+        
+        // QPI/UPI data transfer and utilization
+        counters->qpi_upi_data_bytes = 0; // PCM might not support this directly
+        counters->qpi_upi_utilization = 0.0;
+        counters->uncore_freq_ghz = 0; // Could try to get uncore frequency if available
+        
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error in I/O counter calculation: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error in I/O counter calculation\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_system_counters(pcm_system_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+    
+    try {
+        // System-wide counters
+        counters->active_cores = g_pcm_instance->getNumOnlineCores();
+        
+        // Energy measurements with overflow protection
+        double total_energy_raw = getConsumedJoules(g_before_system_state, g_after_system_state);
+        double dram_energy_raw = getDRAMConsumedJoules(g_before_system_state, g_after_system_state);
+        
+        printf("DEBUG: System energy raw values: total=%.2f, dram=%.2f\n", 
+               total_energy_raw, dram_energy_raw);
+        
+        // Check for reasonable energy values - allow much higher values for longer measurements
+        const double max_energy = 100000.0;  // 100K joules (reasonable for minutes of measurement)
+        
+        counters->total_energy_joules = (total_energy_raw > 0 && total_energy_raw < max_energy) ? total_energy_raw : 0.0;
+        counters->package_energy_joules = counters->total_energy_joules;
+        counters->dram_energy_joules = (dram_energy_raw > 0 && dram_energy_raw < max_energy) ? dram_energy_raw : 0.0;
+        
+        // System-wide IPC with overflow protection
+        double system_ipc_raw = getIPC(g_before_system_state, g_after_system_state);
+        counters->total_ipc = (system_ipc_raw >= 0.0 && system_ipc_raw <= 10.0) ? system_ipc_raw : 0.0;  // IPC should be reasonable
+        
+        // Memory bandwidth utilization
+        uint64_t total_mem_bytes_raw = getBytesReadFromMC(g_before_system_state, g_after_system_state) +
+                                      getBytesWrittenToMC(g_before_system_state, g_after_system_state);
+        double elapsed = getExecUsage(g_before_system_state, g_after_system_state);
+        
+        // Check for overflow in memory bandwidth calculation
+        if (elapsed > 0 && total_mem_bytes_raw > 0 && total_mem_bytes_raw < 1000000000000000ULL) {
+            counters->memory_bandwidth_utilization = (double)total_mem_bytes_raw / (1024.0 * 1024.0 * 1024.0) / elapsed;  // GB/s
+        } else {
+            counters->memory_bandwidth_utilization = 0.0;
+        }
+        
+        // Thermal throttling (approximate) with bounds check
+        double rel_freq = getRelativeFrequency(g_before_system_state, g_after_system_state);
+        if (rel_freq >= 0.0 && rel_freq <= 2.0) {
+            counters->thermal_throttle_ratio = 1.0 - rel_freq;
+        } else {
+            counters->thermal_throttle_ratio = 0.0;
+        }
+        
+        return 0;
+    } catch (...) {
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_system_info(char* info_buffer, size_t buffer_size) {
+    if (!g_initialized || !g_pcm_instance) {
+        return -1;
+    }
+    
+    try {
+        snprintf(info_buffer, buffer_size, 
+                "CPU Brand: %s\n"
+                "Cores: %u\n"
+                "Online Cores: %u\n"
+                "Sockets: %u\n"
+                "Threads per Core: %u\n",
+                g_pcm_instance->getCPUBrandString().c_str(),
+                g_pcm_instance->getNumCores(),
+                g_pcm_instance->getNumOnlineCores(),
+                g_pcm_instance->getNumSockets(),
+                g_pcm_instance->getThreadsPerCore());
+        return 0;
+    } catch (...) {
+        return -1;
+    }
+}
+
+} // extern "C"
diff --git a/examples/l3fwd/l3fwd_pcm_wrapper.h b/examples/l3fwd/l3fwd_pcm_wrapper.h
new file mode 100644
index 0000000000..808e6fa7b7
--- /dev/null
+++ b/examples/l3fwd/l3fwd_pcm_wrapper.h
@@ -0,0 +1,137 @@
+#ifndef __L3FWD_PCM_WRAPPER_H__
+#define __L3FWD_PCM_WRAPPER_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* PCM wrapper functions for static linking */
+
+/* Core performance counters structure */
+typedef struct {
+    uint64_t cycles;
+    uint64_t instructions;
+    uint64_t l2_cache_hits;
+    uint64_t l2_cache_misses;
+    uint64_t l3_cache_hits;
+    uint64_t l3_cache_misses;
+    double ipc;
+    double l2_cache_hit_ratio;
+    double l3_cache_hit_ratio;
+    double frequency_ghz;
+    double cpu_utilization;
+    double energy_joules;
+} pcm_core_counters_t;
+
+/* Memory performance counters structure */
+typedef struct {
+    uint64_t dram_read_bytes;
+    uint64_t dram_write_bytes;
+    double dram_read_bandwidth_mbps;
+    double dram_write_bandwidth_mbps;
+    double memory_controller_utilization;
+    uint64_t numa_local_accesses;
+    uint64_t numa_remote_accesses;
+    double numa_ratio;
+} pcm_memory_counters_t;
+
+/* I/O and Uncore performance counters structure */
+typedef struct {
+    uint64_t pcie_read_bytes;
+    uint64_t pcie_write_bytes;
+    double pcie_read_bandwidth_mbps;
+    double pcie_write_bandwidth_mbps;
+    uint64_t qpi_upi_data_bytes;
+    double qpi_upi_utilization;
+    uint64_t uncore_freq_ghz;
+    double imc_reads_gbps;
+    double imc_writes_gbps;
+} pcm_io_counters_t;
+
+/* System-wide performance counters structure */
+typedef struct {
+    uint32_t active_cores;
+    double total_energy_joules;
+    double package_energy_joules;
+    double dram_energy_joules;
+    double total_ipc;
+    double memory_bandwidth_utilization;
+    double thermal_throttle_ratio;
+} pcm_system_counters_t;
+
+/**
+ * Check if PCM wrapper is available
+ * @return 1 if available, 0 if not
+ */
+int pcm_wrapper_is_available(void);
+
+/**
+ * Initialize PCM wrapper
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_init(void);
+
+/**
+ * Cleanup PCM wrapper
+ */
+void pcm_wrapper_cleanup(void);
+
+/**
+ * Get basic performance counters
+ * @param core_id: Core ID to get counters for
+ * @param cycles: Pointer to store cycle count
+ * @param instructions: Pointer to store instruction count
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_basic_counters(uint32_t core_id, uint64_t *cycles, uint64_t *instructions);
+
+/**
+ * Get comprehensive core performance counters
+ * @param core_id: Core ID to get counters for
+ * @param counters: Pointer to store core counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_core_counters(uint32_t core_id, pcm_core_counters_t *counters);
+
+/**
+ * Get memory performance counters
+ * @param socket_id: Socket ID to get counters for
+ * @param counters: Pointer to store memory counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_memory_counters(uint32_t socket_id, pcm_memory_counters_t *counters);
+
+/**
+ * Get I/O and uncore performance counters
+ * @param socket_id: Socket ID to get counters for
+ * @param counters: Pointer to store I/O counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_io_counters(uint32_t socket_id, pcm_io_counters_t *counters);
+
+/**
+ * Get system-wide performance counters
+ * @param counters: Pointer to store system counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_system_counters(pcm_system_counters_t *counters);
+
+/**
+ * Start measurement period
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_start_measurement(void);
+
+/**
+ * Stop measurement period and calculate differences
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_stop_measurement(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __L3FWD_PCM_WRAPPER_H__ */
diff --git a/examples/l3fwd/main.c b/examples/l3fwd/main.c
index ae3b4f6439..599e3fbf21 100644
--- a/examples/l3fwd/main.c
+++ b/examples/l3fwd/main.c
@@ -48,6 +48,7 @@
 #include "l3fwd.h"
 #include "l3fwd_event.h"
 #include "l3fwd_route.h"
+#include "l3fwd_pcm.h"
 
 #define MAX_TX_QUEUE_PER_PORT RTE_MAX_LCORE
 #define MAX_RX_QUEUE_PER_PORT 128
@@ -131,7 +132,8 @@ static struct rte_eth_conf port_conf = {
 	.rx_adv_conf = {
 		.rss_conf = {
 			.rss_key = NULL,
-			.rss_hf = RTE_ETH_RSS_IP,
+			// .rss_hf = RTE_ETH_RSS_IP,
+			.rss_hf = RTE_ETH_RSS_IP | RTE_ETH_RSS_TCP | RTE_ETH_RSS_UDP,
 		},
 	},
 	.txmode = {
@@ -1065,10 +1067,11 @@ parse_args(int argc, char **argv)
 	}
 
 	/* For ACL, update port config rss hash filter */
-	if (lookup_mode == L3FWD_LOOKUP_ACL) {
-		port_conf.rx_adv_conf.rss_conf.rss_hf |=
-				RTE_ETH_RSS_UDP | RTE_ETH_RSS_TCP | RTE_ETH_RSS_SCTP;
-	}
+	// if (lookup_mode == L3FWD_LOOKUP_ACL) {
+	// 	port_conf.rx_adv_conf.rss_conf.rss_hf |=
+	// 			RTE_ETH_RSS_UDP | RTE_ETH_RSS_TCP | RTE_ETH_RSS_SCTP;
+	// }
+	/* RSS hash filter now includes TCP/UDP ports for all modes */
 
 	if (optind >= 0)
 		argv[optind-1] = prgname;
@@ -1236,6 +1239,28 @@ signal_handler(int signum)
 	if (signum == SIGINT || signum == SIGTERM) {
 		printf("\n\nSignal %d received, preparing to exit...\n",
 				signum);
+		
+		/* Print PCM statistics before exit */
+		if (pcm_monitoring_is_available()) {
+			printf("\n\nReceived signal %d, shutting down...\n", signum);
+			
+			printf("\n=== Intel PCM Performance Statistics ===\n");
+			
+			/* First stop PCM monitoring to capture final state */
+			pcm_monitoring_stop_all();
+			
+			/* Then measure all cores with proper before/after states */
+			pcm_monitoring_measure_all();
+			
+			/* Print comprehensive PCM statistics */
+			pcm_print_core_statistics();
+			pcm_print_memory_statistics();
+			pcm_print_io_statistics();
+			pcm_print_system_statistics();
+			
+			printf("=== End PCM Statistics ===\n");
+		}
+		
 		force_quit = true;
 	}
 }
@@ -1448,13 +1473,17 @@ l3fwd_poll_resource_setup(void)
 			else
 				socketid = 0;
 
-			printf("txq=%u,%d,%d ", lcore_id, queueid, socketid);
+			// printf("TXQ=%u,%d,%d ", lcore_id, queueid, socketid);
 			fflush(stdout);
 
 			txconf = &dev_info.default_txconf;
 			txconf->offloads = local_port_conf.txmode.offloads;
 			ret = rte_eth_tx_queue_setup(portid, queueid, nb_txd,
 						     socketid, txconf);
+			printf("txconf: tx_thresh={pthresh=%u, hthresh=%u, wthresh=%u}, "
+				"tx_rs_thresh=%u, tx_free_thresh=%u, offloads=0x%"PRIx64"\n",
+				txconf->tx_thresh.pthresh, txconf->tx_thresh.hthresh, txconf->tx_thresh.wthresh,
+				txconf->tx_rs_thresh, txconf->tx_free_thresh, txconf->offloads);
 			if (ret < 0)
 				rte_exit(EXIT_FAILURE,
 					"rte_eth_tx_queue_setup: err=%d, "
@@ -1474,7 +1503,7 @@ l3fwd_poll_resource_setup(void)
 		if (rte_lcore_is_enabled(lcore_id) == 0)
 			continue;
 		qconf = &lcore_conf[lcore_id];
-		printf("\nInitializing rx queues on lcore %u ... ", lcore_id );
+		// printf("\nInitializing rx queues on lcore %u ... ", lcore_id );
 		fflush(stdout);
 		/* init RX queues */
 		for(queue = 0; queue < qconf->n_rx_queue; ++queue) {
@@ -1490,7 +1519,7 @@ l3fwd_poll_resource_setup(void)
 			else
 				socketid = 0;
 
-			printf("rxq=%d,%d,%d ", portid, queueid, socketid);
+			// printf("rxq=%d,%d,%d ", portid, queueid, socketid);
 			fflush(stdout);
 
 			ret = rte_eth_dev_info_get(portid, &dev_info);
@@ -1635,6 +1664,14 @@ main(int argc, char **argv)
 	argc -= ret;
 	argv += ret;
 
+	/* Initialize PCM monitoring early */
+	printf("=== Initializing Intel PCM Performance Monitoring ===\n");
+	if (pcm_monitoring_init() == 0) {
+		printf("=== Intel PCM initialized successfully ===\n");
+	} else {
+		printf("=== Intel PCM initialization failed, continuing without PCM ===\n");
+	}
+
 	force_quit = false;
 	signal(SIGINT, signal_handler);
 	signal(SIGTERM, signal_handler);
@@ -1727,6 +1764,17 @@ main(int argc, char **argv)
 	check_all_ports_link_status(enabled_port_mask);
 
 	ret = 0;
+	
+	/* Start PCM monitoring on all lcores before launching main loops */
+	if (pcm_monitoring_is_available()) {
+		printf("Starting PCM monitoring on all lcores...\n");
+		if (pcm_monitoring_start_all() == 0) {
+			printf("PCM monitoring started successfully\n");
+		} else {
+			printf("Failed to start PCM monitoring\n");
+		}
+	}
+	
 	/* launch per-lcore init on every lcore */
 	rte_eal_mp_remote_launch(l3fwd_lkp.main_loop, NULL, CALL_MAIN);
 
diff --git a/examples/l3fwd/meson.build b/examples/l3fwd/meson.build
index 74144c7979..b10568d0f4 100644
--- a/examples/l3fwd/meson.build
+++ b/examples/l3fwd/meson.build
@@ -7,7 +7,26 @@
 # DPDK instance, use 'make'
 
 allow_experimental_apis = true
+
+# Add C++ compiler support for PCM wrapper
+add_languages('cpp', required: true)
+
 deps += ['acl', 'hash', 'lpm', 'fib']
+
+# PCM library configuration for static linking
+pcm_base_path = meson.current_source_dir() / '..' / '..' / '..' / 'pcm'
+pcm_lib_path = pcm_base_path / 'build' / 'src'
+pcm_inc_path = pcm_base_path / 'src'
+
+# Check for PCM static library
+pcm_static_lib = pcm_lib_path / 'libpcm.a'
+pcm_found = false
+
+if fs.is_file(pcm_static_lib)
+    pcm_found = true
+    message('Found PCM static library: ' + pcm_static_lib)
+endif
+
 sources = files(
         'l3fwd_acl.c',
         'l3fwd_em.c',
@@ -16,9 +35,26 @@ sources = files(
         'l3fwd_event_generic.c',
         'l3fwd_fib.c',
         'l3fwd_lpm.c',
+        'l3fwd_pcm.c',
         'main.c',
 )
+
+# Add PCM wrapper if library found
+if pcm_found
+    sources += files('l3fwd_pcm_wrapper.cpp')
+    message('PCM integration enabled with static linking')
+endif
+
 if dpdk_conf.has('RTE_LIB_EVENTDEV')
     deps += 'eventdev'
 endif
 cflags += no_wvla_cflag
+
+# Initialize ldflags
+ldflags = []
+
+# Add PCM support if available
+if pcm_found
+    includes += include_directories('../../../pcm/src')
+    ldflags += [pcm_static_lib, '-static-libstdc++', '-static-libgcc', '-lpthread', '-ldl', '-lnuma']
+endif
