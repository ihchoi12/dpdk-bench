diff --git a/examples/l3fwd/Makefile b/examples/l3fwd/Makefile
index a06480a19e..505b282049 100644
--- a/examples/l3fwd/Makefile
+++ b/examples/l3fwd/Makefile
@@ -7,6 +7,7 @@ APP = l3fwd
 # all source are stored in SRCS-y
 SRCS-y := main.c l3fwd_acl.c l3fwd_lpm.c l3fwd_fib.c l3fwd_em.c l3fwd_event.c
 SRCS-y += l3fwd_event_generic.c l3fwd_event_internal_port.c
+SRCS-y += l3fwd_pcm.c l3fwd_pcm_wrapper.cpp
 
 PKGCONF ?= pkg-config
 
@@ -26,8 +27,13 @@ PC_FILE := $(shell $(PKGCONF) --path libdpdk 2>/dev/null)
 CFLAGS += -O3 $(shell $(PKGCONF) --cflags libdpdk)
 # Added for 'rte_eth_link_to_str()'
 CFLAGS += -DALLOW_EXPERIMENTAL_API
+# PCM include path
+CFLAGS += -I../../../pcm/src
 LDFLAGS_SHARED = $(shell $(PKGCONF) --libs libdpdk)
 LDFLAGS_STATIC = $(shell $(PKGCONF) --static --libs libdpdk)
+# PCM library linking
+LDFLAGS_SHARED += -L../../../pcm/build/lib -lpcm -lstdc++
+LDFLAGS_STATIC += -L../../../pcm/build/lib -lpcm -lstdc++
 
 CFLAGS += -I../common
 
diff --git a/examples/l3fwd/l3fwd.h b/examples/l3fwd/l3fwd.h
index 0cce3406ee..1f4029b232 100644
--- a/examples/l3fwd/l3fwd.h
+++ b/examples/l3fwd/l3fwd.h
@@ -5,10 +5,18 @@
 #ifndef __L3_FWD_H__
 #define __L3_FWD_H__
 
+#include <stdlib.h>
 #include <rte_ethdev.h>
 #include <rte_vect.h>
 #include <rte_acl.h>
 
+/* Debug logging control - MAIN CONFIGURATION */
+/* Set to 1 to enable debug logs, 0 to disable for better performance */
+#ifndef L3FWD_DEBUG_LOGS
+#define L3FWD_DEBUG_LOGS 0  /* 0 = disabled, 1 = enabled */
+#endif
+static volatile bool stats_enabled = true;
+
 #define DO_RFC_1812_CHECKS
 
 #define RTE_LOGTYPE_L3FWD RTE_LOGTYPE_USER1
@@ -110,6 +118,9 @@ extern xmm_t val_eth[RTE_MAX_ETHPORTS];
 
 extern struct lcore_conf lcore_conf[RTE_MAX_LCORE];
 
+/* NIC hardware statistics functions */
+void print_all_nic_hw_stats(void);
+
 extern struct parm_cfg parm_config;
 
 extern struct acl_algorithms acl_alg[];
@@ -119,6 +130,24 @@ extern uint32_t max_pkt_len;
 extern uint32_t nb_pkt_per_burst;
 extern uint32_t mb_mempool_cache_size;
 
+/* Packet statistics per lcore */
+struct lcore_packet_stats {
+	uint64_t rx_packets;
+	uint64_t tx_packets;
+	uint64_t start_time;
+	/* Drop counters */
+	uint64_t dropped_invalid_ipv4;
+	uint64_t dropped_no_route;
+	uint64_t dropped_tx_failed;
+	uint64_t dropped_non_ip;
+	uint64_t dropped_unknown;
+};
+
+extern struct lcore_packet_stats lcore_stats[RTE_MAX_LCORE];
+
+/* Function declarations */
+void analyze_packet(struct rte_mbuf *pkt, unsigned int lcore_id, const char *direction, uint16_t queue_id);
+
 /* Send burst of packets on an output interface */
 static inline int
 send_burst(struct lcore_conf *qconf, uint16_t n, uint16_t port)
@@ -126,12 +155,33 @@ send_burst(struct lcore_conf *qconf, uint16_t n, uint16_t port)
 	struct rte_mbuf **m_table;
 	int ret;
 	uint16_t queueid;
+	unsigned int lcore_id = rte_lcore_id();
 
 	queueid = qconf->tx_queue_id[port];
 	m_table = (struct rte_mbuf **)qconf->tx_mbufs[port].m_table;
 
+#if L3FWD_DEBUG_LOGS
+	/* Analyze TX packets for debugging only when debug is enabled */
+	for (int i = 0; i < n; i++) {
+		analyze_packet(m_table[i], lcore_id, "TX", queueid);
+	}
+#endif
+
 	ret = rte_eth_tx_burst(port, queueid, m_table, n);
+
+	/* Update TX statistics */
+	lcore_stats[lcore_id].tx_packets += ret;
+
 	if (unlikely(ret < n)) {
+		/* Count failed TX packets */
+		lcore_stats[lcore_id].dropped_tx_failed += (n - ret);
+
+		/* Log TX congestion for debugging */
+		if (L3FWD_DEBUG_LOGS && (lcore_stats[lcore_id].dropped_tx_failed % 1000 == 0)) {
+			RTE_LOG(WARNING, L3FWD, "TX congestion on port %u: tried %u, sent %d, failed %u (total failed: %" PRIu64 ")\n",
+				port, n, ret, (n - ret), lcore_stats[lcore_id].dropped_tx_failed);
+		}
+
 		do {
 			rte_pktmbuf_free(m_table[ret]);
 		} while (++ret < n);
diff --git a/examples/l3fwd/l3fwd_lpm.c b/examples/l3fwd/l3fwd_lpm.c
index fec0aeb79c..bb4b6311ae 100644
--- a/examples/l3fwd/l3fwd_lpm.c
+++ b/examples/l3fwd/l3fwd_lpm.c
@@ -15,6 +15,8 @@
 #include <stdbool.h>
 #include <sys/socket.h>
 #include <arpa/inet.h>
+#include <signal.h>
+#include <netinet/in.h>
 
 #include <rte_debug.h>
 #include <rte_ether.h>
@@ -30,9 +32,16 @@
 #include "l3fwd.h"
 #include "l3fwd_common.h"
 #include "l3fwd_event.h"
+#include "l3fwd_pcm.h"
 
 #include "lpm_route_parse.c"
 
+#if L3FWD_DEBUG_LOGS
+#define L3FWD_DEBUG_LOG(fmt, args...) RTE_LOG(INFO, L3FWD, fmt, ##args)
+#else
+#define L3FWD_DEBUG_LOG(fmt, args...) do {} while(0)
+#endif
+
 #define IPV4_L3FWD_LPM_MAX_RULES         1024
 #define IPV4_L3FWD_LPM_NUMBER_TBL8S (1 << 8)
 #define IPV6_L3FWD_LPM_MAX_RULES         1024
@@ -41,6 +50,222 @@
 static struct rte_lpm *ipv4_l3fwd_lpm_lookup_struct[NB_SOCKETS];
 static struct rte_lpm6 *ipv6_l3fwd_lpm_lookup_struct[NB_SOCKETS];
 
+/* Global array of packet statistics per lcore */
+struct lcore_packet_stats lcore_stats[RTE_MAX_LCORE];
+
+/* Analyze and log packet details */
+void
+analyze_packet(struct rte_mbuf *pkt, unsigned int lcore_id, const char *direction, uint16_t queue_id)
+{
+#if L3FWD_DEBUG_LOGS
+	struct rte_ether_hdr *eth_hdr;
+	struct rte_ipv4_hdr *ipv4_hdr;
+	struct rte_tcp_hdr *tcp_hdr;
+	struct rte_udp_hdr *udp_hdr;
+	uint32_t src_ip, dst_ip;
+	uint16_t src_port = 0, dst_port = 0;
+	uint8_t proto;
+	char src_ip_str[INET_ADDRSTRLEN];
+	char dst_ip_str[INET_ADDRSTRLEN];
+	char src_mac_str[18];
+	char dst_mac_str[18];
+
+	eth_hdr = rte_pktmbuf_mtod(pkt, struct rte_ether_hdr *);
+
+	/* Convert MAC addresses to string format */
+	snprintf(src_mac_str, sizeof(src_mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+		 eth_hdr->src_addr.addr_bytes[0], eth_hdr->src_addr.addr_bytes[1],
+		 eth_hdr->src_addr.addr_bytes[2], eth_hdr->src_addr.addr_bytes[3],
+		 eth_hdr->src_addr.addr_bytes[4], eth_hdr->src_addr.addr_bytes[5]);
+	snprintf(dst_mac_str, sizeof(dst_mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+		 eth_hdr->dst_addr.addr_bytes[0], eth_hdr->dst_addr.addr_bytes[1],
+		 eth_hdr->dst_addr.addr_bytes[2], eth_hdr->dst_addr.addr_bytes[3],
+		 eth_hdr->dst_addr.addr_bytes[4], eth_hdr->dst_addr.addr_bytes[5]);
+
+	if (RTE_ETH_IS_IPV4_HDR(pkt->packet_type)) {
+		ipv4_hdr = (struct rte_ipv4_hdr *)(eth_hdr + 1);
+		src_ip = rte_be_to_cpu_32(ipv4_hdr->src_addr);
+		dst_ip = rte_be_to_cpu_32(ipv4_hdr->dst_addr);
+		proto = ipv4_hdr->next_proto_id;
+
+		/* Convert IPs to string format */
+		struct in_addr addr;
+		addr.s_addr = rte_cpu_to_be_32(src_ip);
+		inet_ntop(AF_INET, &addr, src_ip_str, INET_ADDRSTRLEN);
+		addr.s_addr = rte_cpu_to_be_32(dst_ip);
+		inet_ntop(AF_INET, &addr, dst_ip_str, INET_ADDRSTRLEN);
+
+		/* Extract port numbers for TCP/UDP */
+		if (proto == IPPROTO_TCP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*tcp_hdr)) {
+			tcp_hdr = (struct rte_tcp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+			src_port = rte_be_to_cpu_16(tcp_hdr->src_port);
+			dst_port = rte_be_to_cpu_16(tcp_hdr->dst_port);
+			L3FWD_DEBUG_LOG("[%s] lcore=%u queue=%u TCP %s:%u -> %s:%u (MAC %s -> %s) (RSS=0x%08x)\n",
+				direction, lcore_id, queue_id, src_ip_str, src_port, dst_ip_str, dst_port, src_mac_str, dst_mac_str, pkt->hash.rss);
+		} else if (proto == IPPROTO_UDP && rte_pktmbuf_data_len(pkt) >= sizeof(*eth_hdr) + sizeof(*ipv4_hdr) + sizeof(*udp_hdr)) {
+			udp_hdr = (struct rte_udp_hdr *)((char *)ipv4_hdr + sizeof(*ipv4_hdr));
+			src_port = rte_be_to_cpu_16(udp_hdr->src_port);
+			dst_port = rte_be_to_cpu_16(udp_hdr->dst_port);
+			L3FWD_DEBUG_LOG("[%s] lcore=%u queue=%u UDP %s:%u -> %s:%u (MAC %s -> %s) (RSS=0x%08x)\n",
+				direction, lcore_id, queue_id, src_ip_str, src_port, dst_ip_str, dst_port, src_mac_str, dst_mac_str, pkt->hash.rss);
+		} else {
+			L3FWD_DEBUG_LOG("[%s] lcore=%u queue=%u IP proto=%u %s -> %s (MAC %s -> %s) (RSS=0x%08x)\n",
+				direction, lcore_id, queue_id, proto, src_ip_str, dst_ip_str, src_mac_str, dst_mac_str, pkt->hash.rss);
+		}
+	} else if (RTE_ETH_IS_IPV6_HDR(pkt->packet_type)) {
+		L3FWD_DEBUG_LOG("[%s] lcore=%u queue=%u IPv6 packet (MAC %s -> %s)\n", direction, lcore_id, queue_id, src_mac_str, dst_mac_str);
+	} else {
+		L3FWD_DEBUG_LOG("[%s] lcore=%u queue=%u Non-IP packet (type=0x%04x) (MAC %s -> %s)\n",
+			direction, lcore_id, queue_id, rte_be_to_cpu_16(eth_hdr->ether_type), src_mac_str, dst_mac_str);
+	}
+#else
+	/* Suppress unused parameter warnings when debug is disabled */
+	(void)pkt;
+	(void)lcore_id;
+	(void)direction;
+	(void)queue_id;
+#endif
+}
+
+/* Print packet statistics when exiting */
+static void
+print_packet_stats(void)
+{
+	unsigned int lcore_id;
+	uint64_t total_rx = 0, total_tx = 0;
+	uint64_t current_time = rte_rdtsc();
+	uint64_t tsc_hz = rte_get_tsc_hz();
+
+	printf("\n");
+	printf("=====================================\n");
+	printf("L3FWD Packet Statistics Summary\n");
+	printf("=====================================\n");
+	printf("%-8s %-12s %-12s %-10s %-10s %-8s\n",
+		"Lcore", "RX Packets", "TX Packets", "RX Rate", "TX Rate", "Loss%");
+	printf("%-8s %-12s %-12s %-10s %-10s %-8s\n",
+		"-----", "----------", "----------", "--------", "--------", "------");
+
+	uint64_t total_dropped_invalid_ipv4 = 0, total_dropped_no_route = 0;
+	uint64_t total_dropped_tx_failed = 0, total_dropped_non_ip = 0, total_dropped_unknown = 0;
+
+	RTE_LCORE_FOREACH(lcore_id) {
+		if (lcore_stats[lcore_id].start_time > 0) {
+			uint64_t duration = current_time - lcore_stats[lcore_id].start_time;
+			double elapsed_sec = (double)duration / tsc_hz;
+			double rx_rate = elapsed_sec > 0 ? lcore_stats[lcore_id].rx_packets / elapsed_sec : 0;
+			double tx_rate = elapsed_sec > 0 ? lcore_stats[lcore_id].tx_packets / elapsed_sec : 0;
+			double loss_rate = lcore_stats[lcore_id].rx_packets > 0 ?
+				(double)(lcore_stats[lcore_id].rx_packets - lcore_stats[lcore_id].tx_packets) * 100.0 / lcore_stats[lcore_id].rx_packets : 0.0;
+
+			printf("%-8u %-12" PRIu64 " %-12" PRIu64 " %-10.1f %-10.1f %-8.1f\n",
+				lcore_id,
+				lcore_stats[lcore_id].rx_packets,
+				lcore_stats[lcore_id].tx_packets,
+				rx_rate / 1000000.0,  /* Convert to Mpps */
+				tx_rate / 1000000.0,
+				loss_rate);
+
+			total_rx += lcore_stats[lcore_id].rx_packets;
+			total_tx += lcore_stats[lcore_id].tx_packets;
+			total_dropped_invalid_ipv4 += lcore_stats[lcore_id].dropped_invalid_ipv4;
+			total_dropped_no_route += lcore_stats[lcore_id].dropped_no_route;
+			total_dropped_tx_failed += lcore_stats[lcore_id].dropped_tx_failed;
+			total_dropped_non_ip += lcore_stats[lcore_id].dropped_non_ip;
+			total_dropped_unknown += lcore_stats[lcore_id].dropped_unknown;
+		}
+	}
+
+	double total_loss_rate = total_rx > 0 ? (double)(total_rx - total_tx) * 100.0 / total_rx : 0.0;
+
+	printf("%-8s %-12s %-12s %-10s %-10s %-8s\n",
+		"-----", "----------", "----------", "--------", "--------", "------");
+	printf("%-8s %-12" PRIu64 " %-12" PRIu64 " %-10s %-10s %-8.1f\n",
+		"Total", total_rx, total_tx, "", "", total_loss_rate);
+	printf("=====================================\n");
+	printf("ANALYSIS: RX/TX difference = %" PRIu64 " packets (%.1f%% loss)\n",
+		total_rx - total_tx, total_loss_rate);
+
+	/* Print detailed drop analysis */
+	if (total_rx - total_tx > 0) {
+		printf("DROP ANALYSIS:\n");
+		printf("  Invalid IPv4 packets: %" PRIu64 "\n", total_dropped_invalid_ipv4);
+		printf("  No route found: %" PRIu64 "\n", total_dropped_no_route);
+		printf("  TX failed (queue full): %" PRIu64 " (%.1f%% of RX)\n",
+			total_dropped_tx_failed, total_rx > 0 ? (double)total_dropped_tx_failed * 100.0 / total_rx : 0.0);
+		printf("  Non-IP packets: %" PRIu64 "\n", total_dropped_non_ip);
+		printf("  Unknown drops: %" PRIu64 "\n", total_dropped_unknown);
+
+		if (total_dropped_tx_failed > 0) {
+			printf("\nTX CONGESTION ANALYSIS:\n");
+			printf("  - TX queue is overloaded (receiving faster than transmitting)\n");
+			printf("  - Consider: reducing RX rate, increasing TX queue size, or checking network bottleneck\n");
+		}
+	}
+
+	/* Always show CURRENT CONFIGURATION when stats are enabled */
+	if (stats_enabled) {
+		printf("\nCURRENT CONFIGURATION:\n");
+		printf("  RX_DESC_DEFAULT (nb_rxd): %u \n", nb_rxd);
+		printf("  TX_DESC_DEFAULT (nb_txd): %u \n", nb_txd);
+		printf("  MAX_PKT_BURST: %u\n", MAX_PKT_BURST);
+		printf("  DEFAULT_PKT_BURST: %u (actual nb_pkt_per_burst: %u)\n", DEFAULT_PKT_BURST, nb_pkt_per_burst);
+		printf("  BURST_TX_DRAIN_US: %u us\n", BURST_TX_DRAIN_US);
+		printf("  MAX_TX_BURST: %u\n", MAX_TX_BURST);
+		printf("  enabled_port_mask: 0x%x\n", enabled_port_mask);
+
+		/* Get port info for first enabled port */
+		uint16_t portid;
+		for (portid = 0; portid < RTE_MAX_ETHPORTS; portid++) {
+			if ((enabled_port_mask & (1 << portid)) != 0) {
+				struct rte_eth_dev_info dev_info;
+				struct rte_eth_link link;
+				if (rte_eth_dev_info_get(portid, &dev_info) == 0) {
+					printf("  Port %u driver_name: %s\n", portid, dev_info.driver_name);
+					printf("  Port %u max_tx_queues: %u\n", portid, dev_info.max_tx_queues);
+					printf("  Port %u max_rx_queues: %u\n", portid, dev_info.max_rx_queues);
+				}
+				if (rte_eth_link_get_nowait(portid, &link) == 0) {
+					printf("  Port %u link_speed: %u Mbps, %s\n", portid, link.link_speed,
+						link.link_status ? "UP" : "DOWN");
+				}
+				break; /* Only show first enabled port */
+			}
+		}
+	}
+	printf("=====================================\n");
+	
+	print_all_nic_hw_stats();
+
+	/* Print PCM performance statistics if available */
+	if (stats_enabled && pcm_monitoring_is_available()) {
+		/* Stop measurement period FIRST to capture final state */
+		pcm_monitoring_stop_all();
+		
+		/* Then collect and calculate statistics immediately */
+		pcm_monitoring_measure_all();
+		
+		/* Print comprehensive PCM statistics */
+		pcm_print_core_statistics();
+		pcm_print_memory_statistics();
+		pcm_print_io_statistics();
+		pcm_print_system_statistics();
+	}
+}
+
+/* Signal handler for graceful shutdown */
+static void
+signal_handler(int signum)
+{
+	if (signum == SIGINT || signum == SIGTERM) {
+		printf("\nReceived signal %d, shutting down...\n", signum);
+		if (stats_enabled) {
+			print_packet_stats();
+		}
+		stats_enabled = false;
+		force_quit = true;
+	}
+}
+
 /* Performing LPM-based lookups. 8< */
 static inline uint16_t
 lpm_get_ipv4_dst_port(const struct rte_ipv4_hdr *ipv4_hdr,
@@ -156,6 +381,17 @@ lpm_main_loop(__rte_unused void *dummy)
 	lcore_id = rte_lcore_id();
 	qconf = &lcore_conf[lcore_id];
 
+	/* Initialize packet statistics for this lcore */
+	lcore_stats[lcore_id].rx_packets = 0;
+	lcore_stats[lcore_id].tx_packets = 0;
+	lcore_stats[lcore_id].start_time = rte_rdtsc();
+
+	/* Install signal handlers only on master lcore */
+	if (rte_lcore_id() == rte_get_main_lcore()) {
+		signal(SIGINT, signal_handler);
+		signal(SIGTERM, signal_handler);
+	}
+
 	const uint16_t n_rx_q = qconf->n_rx_queue;
 	const uint16_t n_tx_p = qconf->n_tx_port;
 	if (n_rx_q == 0) {
@@ -163,17 +399,31 @@ lpm_main_loop(__rte_unused void *dummy)
 		return 0;
 	}
 
-	RTE_LOG(INFO, L3FWD, "entering main loop on lcore %u\n", lcore_id);
-
+	RTE_LOG(INFO, L3FWD, "[lpm] entering main loop on lcore %u\n", lcore_id);
 	for (i = 0; i < n_rx_q; i++) {
-
 		portid = qconf->rx_queue_list[i].port_id;
 		queueid = qconf->rx_queue_list[i].queue_id;
 		RTE_LOG(INFO, L3FWD,
-			" -- lcoreid=%u portid=%u rxqueueid=%" PRIu16 "\n",
+			" [RX] lcoreid=%u, port=%u rxq=%hhu\n",
 			lcore_id, portid, queueid);
 	}
 
+	for (i = 0; i < n_tx_p; i++) {
+		portid = qconf->tx_port_id[i];
+		RTE_LOG(INFO, L3FWD,
+			" [TX] lcoreid=%u, port=%u, txq=%hhu\n",
+			lcore_id, portid, qconf->tx_queue_id[portid]);
+	}
+
+	for (i = 0; i < n_rx_q; i++) {
+		portid = qconf->rx_queue_list[i].port_id;
+		queueid = qconf->rx_queue_list[i].queue_id;
+		uint16_t tx_queueid = qconf->tx_queue_id[portid];
+		RTE_LOG(INFO, L3FWD,
+			" -- lcoreid=%u portid=%u rxqueueid=%" PRIu16 " txqueueid=%" PRIu16 "\n",
+			lcore_id, portid, queueid, tx_queueid);
+	}
+
 	cur_tsc = rte_rdtsc();
 	prev_tsc = cur_tsc;
 
@@ -189,6 +439,9 @@ lpm_main_loop(__rte_unused void *dummy)
 				portid = qconf->tx_port_id[i];
 				if (qconf->tx_mbufs[portid].len == 0)
 					continue;
+
+				L3FWD_DEBUG_LOG("lcore %u sending %u packets to port %u queue %u\n",
+					lcore_id, qconf->tx_mbufs[portid].len, portid, qconf->tx_queue_id[portid]);
 				send_burst(qconf,
 					qconf->tx_mbufs[portid].len,
 					portid);
@@ -209,6 +462,21 @@ lpm_main_loop(__rte_unused void *dummy)
 			if (nb_rx == 0)
 				continue;
 
+			/* Update RX packet statistics */
+			if (stats_enabled) {
+				lcore_stats[lcore_id].rx_packets += nb_rx;
+			}
+
+			L3FWD_DEBUG_LOG("lcore %u received %d packets from port %u queue %u\n", lcore_id, nb_rx, portid, queueid);
+
+			/* Analyze first few packets for debugging */
+			if (L3FWD_DEBUG_LOGS) {
+				/* Analyze only first 3 packets to reduce overhead */
+				// int analyze_count = nb_rx > 3 ? 3 : nb_rx;
+				for (int j = 0; j < nb_rx; j++) {
+					analyze_packet(pkts_burst[j], lcore_id, "RX", queueid);
+				}
+			}
 #if defined RTE_ARCH_X86 || defined __ARM_NEON \
 			 || defined RTE_ARCH_PPC_64
 			l3fwd_lpm_send_packets(nb_rx, pkts_burst,
@@ -222,6 +490,11 @@ lpm_main_loop(__rte_unused void *dummy)
 		cur_tsc = rte_rdtsc();
 	}
 
+	/* Print statistics when main loop exits */
+	if (rte_lcore_id() == rte_get_main_lcore() && stats_enabled) {
+		print_packet_stats();
+	}
+
 	return 0;
 }
 
diff --git a/examples/l3fwd/l3fwd_lpm.h b/examples/l3fwd/l3fwd_lpm.h
index 4ee61e8d88..b2f0682abb 100644
--- a/examples/l3fwd/l3fwd_lpm.h
+++ b/examples/l3fwd/l3fwd_lpm.h
@@ -12,6 +12,7 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 	struct rte_ether_hdr *eth_hdr;
 	struct rte_ipv4_hdr *ipv4_hdr;
 	uint16_t dst_port;
+	unsigned int lcore_id = rte_lcore_id();
 
 	eth_hdr = rte_pktmbuf_mtod(m, struct rte_ether_hdr *);
 
@@ -23,6 +24,7 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 #ifdef DO_RFC_1812_CHECKS
 		/* Check to make sure the packet is valid (RFC1812) */
 		if (is_valid_ipv4_pkt(ipv4_hdr, m->pkt_len, m->ol_flags) < 0) {
+			lcore_stats[lcore_id].dropped_invalid_ipv4++;
 			rte_pktmbuf_free(m);
 			return;
 		}
@@ -31,8 +33,11 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 						qconf->ipv4_lookup_struct);
 
 		if (dst_port >= RTE_MAX_ETHPORTS ||
-			(enabled_port_mask & 1 << dst_port) == 0)
-			dst_port = portid;
+			(enabled_port_mask & 1 << dst_port) == 0) {
+			lcore_stats[lcore_id].dropped_no_route++;
+			rte_pktmbuf_free(m);
+			return;
+		}
 
 #ifdef DO_RFC_1812_CHECKS
 		/* Update time to live and header checksum */
@@ -58,8 +63,11 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 					qconf->ipv6_lookup_struct);
 
 		if (dst_port >= RTE_MAX_ETHPORTS ||
-			(enabled_port_mask & 1 << dst_port) == 0)
-			dst_port = portid;
+			(enabled_port_mask & 1 << dst_port) == 0) {
+			lcore_stats[lcore_id].dropped_no_route++;
+			rte_pktmbuf_free(m);
+			return;
+		}
 
 		/* dst addr */
 		*(uint64_t *)&eth_hdr->dst_addr = dest_eth_addr[dst_port];
@@ -71,6 +79,7 @@ l3fwd_lpm_simple_forward(struct rte_mbuf *m, uint16_t portid,
 		send_single_packet(qconf, m, dst_port);
 	} else {
 		/* Free the mbuf that contains non-IPV4/IPV6 packet */
+		lcore_stats[lcore_id].dropped_non_ip++;
 		rte_pktmbuf_free(m);
 	}
 }
diff --git a/examples/l3fwd/l3fwd_pcm.c b/examples/l3fwd/l3fwd_pcm.c
new file mode 100644
index 0000000000..4cc9ceb1d2
--- /dev/null
+++ b/examples/l3fwd/l3fwd_pcm.c
@@ -0,0 +1,566 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2010-2025 Intel Corporation
+ */
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#include "l3fwd_pcm.h"
+#include "l3fwd_pcm_wrapper.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <math.h>
+#include <dlfcn.h>
+#include <rte_common.h>
+#include <rte_lcore.h>
+#include <rte_cycles.h>
+#include <rte_log.h>
+
+/* Global PCM state */
+static struct pcm_global_state {
+    bool pcm_initialized;
+    bool monitoring_enabled;
+    bool use_static_wrapper;
+    uint32_t num_lcores;
+    double sampling_interval;
+    struct pcm_lcore_state lcore_states[PCM_MAX_LCORES];
+    struct pcm_core_metrics core_metrics[PCM_MAX_LCORES];
+    struct pcm_memory_metrics memory_metrics[PCM_MAX_SOCKETS];
+    struct pcm_io_metrics io_metrics[PCM_MAX_SOCKETS];
+    struct pcm_system_metrics system_metrics;
+    uint64_t start_timestamp;
+    uint64_t last_measurement_timestamp;
+} g_pcm_state = {0};
+
+/* Helper macros */
+#define PCM_LOG(level, fmt, args...) \
+    rte_log(RTE_LOG_ ## level, RTE_LOGTYPE_USER1, "[PCM] " fmt "\n", ##args)
+
+#define NSEC_PER_SEC 1000000000ULL
+#define USEC_PER_SEC 1000000ULL
+
+/* Utility functions */
+static uint64_t get_timestamp_ns(void)
+{
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    return ts.tv_sec * NSEC_PER_SEC + ts.tv_nsec;
+}
+
+/* Core PCM monitoring functions */
+int pcm_monitoring_init(void)
+{
+    if (g_pcm_state.pcm_initialized) {
+        PCM_LOG(WARNING, "PCM monitoring already initialized");
+        return 0;
+    }
+
+    /* Check if PCM is disabled via environment variable */
+    if (getenv("PCM_DISABLED")) {
+        printf("DEBUG: PCM monitoring disabled by PCM_DISABLED environment variable\n");
+        return -1;
+    }
+
+    /* Try static PCM wrapper */
+    if (pcm_wrapper_is_available()) {
+        if (pcm_wrapper_init() == 0) {
+            
+            /* Initialize global state for static wrapper */
+            memset(&g_pcm_state, 0, sizeof(g_pcm_state));
+            g_pcm_state.pcm_initialized = true;
+            g_pcm_state.monitoring_enabled = true;
+            g_pcm_state.num_lcores = rte_lcore_count();
+            g_pcm_state.sampling_interval = 1.0;
+            g_pcm_state.use_static_wrapper = true; /* Flag to indicate static wrapper usage */
+            
+            /* Validate initialization parameters */
+            if (g_pcm_state.num_lcores == 0 || g_pcm_state.num_lcores > RTE_MAX_LCORE) {
+                printf("DEBUG: WARNING - Suspicious lcore count %u detected\n", g_pcm_state.num_lcores);
+            }
+
+            /* Initialize per-lcore states */
+            uint32_t lcore_id;
+            RTE_LCORE_FOREACH(lcore_id) {
+                struct pcm_lcore_state *state = &g_pcm_state.lcore_states[lcore_id];
+                state->lcore_id = lcore_id;
+                state->socket_id = rte_lcore_to_socket_id(lcore_id);
+                state->initialized = true;
+                state->monitoring_active = false;
+            }
+
+            /* Get and display system information */
+            char sys_info[1024];
+            if (pcm_wrapper_get_system_info(sys_info, sizeof(sys_info)) == 0) {
+                printf("=== PCM System Information ===\n%s=== End PCM System Info ===\n", sys_info);
+            }
+
+            PCM_LOG(INFO, "PCM monitoring initialized successfully with static wrapper for %u lcores", 
+                    g_pcm_state.num_lcores);
+            return 0;
+        } else {
+            printf("ERROR: Static PCM wrapper initialization failed\n");
+        }
+    } else {
+        printf("ERROR: Static PCM wrapper not available\n");
+    }
+
+    /* If static wrapper failed, return error (no fallback to dynamic loading to avoid GLIBCXX issues) */
+    PCM_LOG(ERR, "Failed to initialize PCM monitoring (static wrapper not available or failed)");
+    return -1;
+}
+
+void pcm_monitoring_cleanup(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    /* Stop monitoring on all active lcores */
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        if (g_pcm_state.lcore_states[lcore_id].monitoring_active) {
+            pcm_monitoring_stop_lcore(lcore_id);
+        }
+    }
+
+    /* Cleanup PCM */
+    if (g_pcm_state.use_static_wrapper) {
+        pcm_wrapper_cleanup();
+    }
+
+    /* Reset global state */
+    memset(&g_pcm_state, 0, sizeof(g_pcm_state));
+    
+    PCM_LOG(INFO, "PCM monitoring cleanup completed");
+}
+
+int pcm_monitoring_start_all(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        PCM_LOG(ERR, "PCM not initialized");
+        return -1;
+    }
+
+    /* Start measurement period in PCM wrapper */
+    if (g_pcm_state.use_static_wrapper) {
+        if (pcm_wrapper_start_measurement() != 0) {
+            PCM_LOG(ERR, "Failed to start PCM measurement");
+            return -1;
+        }
+    }
+
+    g_pcm_state.start_timestamp = get_timestamp_ns();
+    
+    /* Start monitoring on all available lcores */
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        pcm_monitoring_start_lcore(lcore_id);
+    }
+
+    printf("Starting PCM monitoring on all lcores...\n");
+    return 0;
+}
+
+int pcm_monitoring_stop_all(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return -1;
+    }
+
+    /* Stop measurement period in PCM wrapper */
+    if (g_pcm_state.use_static_wrapper) {
+        if (pcm_wrapper_stop_measurement() != 0) {
+            PCM_LOG(ERR, "Failed to stop PCM measurement");
+            return -1;
+        }
+    }
+
+    /* Stop monitoring on all lcores */
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        pcm_monitoring_stop_lcore(lcore_id);
+    }
+
+    printf("Stopped PCM monitoring on all lcores\n");
+    return 0;
+}
+
+int pcm_monitoring_start_lcore(uint32_t lcore_id)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return -1;
+    }
+
+    if (lcore_id >= RTE_MAX_LCORE) {
+        PCM_LOG(ERR, "Invalid lcore ID: %u", lcore_id);
+        return -1;
+    }
+
+    struct pcm_lcore_state *state = &g_pcm_state.lcore_states[lcore_id];
+    
+    if (!state->initialized) {
+        PCM_LOG(ERR, "Lcore %u not initialized", lcore_id);
+        return -1;
+    }
+
+    if (state->monitoring_active) {
+        PCM_LOG(WARNING, "Monitoring already active on lcore %u", lcore_id);
+        return 0;
+    }
+
+    state->monitoring_active = true;
+    PCM_LOG(INFO, "Started monitoring on lcore %u", lcore_id);
+    return 0;
+}
+
+int pcm_monitoring_stop_lcore(uint32_t lcore_id)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return -1;
+    }
+
+    if (lcore_id >= RTE_MAX_LCORE) {
+        return -1;
+    }
+
+    struct pcm_lcore_state *state = &g_pcm_state.lcore_states[lcore_id];
+    
+    if (!state->monitoring_active) {
+        return 0;
+    }
+
+    state->monitoring_active = false;
+    PCM_LOG(INFO, "Stopped monitoring on lcore %u", lcore_id);
+    return 0;
+}
+
+int pcm_monitoring_measure_all(void)
+{
+    if (!g_pcm_state.pcm_initialized || !g_pcm_state.use_static_wrapper) {
+        return -1;
+    }
+
+    uint64_t timestamp = get_timestamp_ns();
+    uint32_t lcore_id;
+
+    /* Collect core metrics for all active lcores */
+    RTE_LCORE_FOREACH(lcore_id) {
+        /* Always collect metrics for all lcores that were initialized, 
+         * regardless of monitoring_active flag since stop_all() resets it */
+        if (g_pcm_state.lcore_states[lcore_id].initialized) {
+            struct pcm_core_metrics *metrics = &g_pcm_state.core_metrics[lcore_id];
+            pcm_core_counters_t counters;
+            
+            if (pcm_wrapper_get_core_counters(lcore_id, &counters) == 0) {
+                metrics->cycles = counters.cycles;
+                metrics->instructions = counters.instructions;
+                metrics->l2_cache_hits = counters.l2_cache_hits;
+                metrics->l2_cache_misses = counters.l2_cache_misses;
+                metrics->l3_cache_hits = counters.l3_cache_hits;
+                metrics->l3_cache_misses = counters.l3_cache_misses;
+                metrics->ipc = counters.ipc;
+                metrics->l2_cache_hit_ratio = counters.l2_cache_hit_ratio;
+                metrics->l3_cache_hit_ratio = counters.l3_cache_hit_ratio;
+                metrics->frequency_ghz = counters.frequency_ghz;
+                metrics->cpu_utilization = counters.cpu_utilization;
+                metrics->energy_joules = counters.energy_joules;
+                metrics->timestamp = timestamp;
+                
+                /* Check for measurement anomalies */
+                if (counters.ipc > 5.0) {
+                    printf("DEBUG: WARNING - Very high IPC %.2f detected on lcore %u\n", counters.ipc, lcore_id);
+                }
+                if (counters.cycles > 0 && counters.instructions == 0) {
+                    printf("DEBUG: WARNING - Zero instructions with non-zero cycles on lcore %u\n", lcore_id);
+                }
+            } else {
+                printf("WARNING: Failed to get counters for lcore %u\n", lcore_id);
+            }
+        }
+    }
+
+    /* Collect memory metrics for all sockets */
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_memory_metrics *metrics = &g_pcm_state.memory_metrics[socket];
+        pcm_memory_counters_t counters;
+        
+        if (pcm_wrapper_get_memory_counters(socket, &counters) == 0) {
+            metrics->dram_read_bytes = counters.dram_read_bytes;
+            metrics->dram_write_bytes = counters.dram_write_bytes;
+            metrics->dram_read_bandwidth_mbps = counters.dram_read_bandwidth_mbps;
+            metrics->dram_write_bandwidth_mbps = counters.dram_write_bandwidth_mbps;
+            metrics->memory_controller_utilization = counters.memory_controller_utilization;
+            metrics->numa_local_accesses = counters.numa_local_accesses;
+            metrics->numa_remote_accesses = counters.numa_remote_accesses;
+            metrics->numa_ratio = counters.numa_ratio;
+            metrics->timestamp = timestamp;
+        }
+    }
+
+    /* Collect I/O metrics for all sockets */
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_io_metrics *metrics = &g_pcm_state.io_metrics[socket];
+        pcm_io_counters_t counters;
+        
+        if (pcm_wrapper_get_io_counters(socket, &counters) == 0) {
+            metrics->pcie_read_bytes = counters.pcie_read_bytes;
+            metrics->pcie_write_bytes = counters.pcie_write_bytes;
+            metrics->pcie_read_bandwidth_mbps = counters.pcie_read_bandwidth_mbps;
+            metrics->pcie_write_bandwidth_mbps = counters.pcie_write_bandwidth_mbps;
+            metrics->qpi_upi_data_bytes = counters.qpi_upi_data_bytes;
+            metrics->qpi_upi_utilization = counters.qpi_upi_utilization;
+            metrics->uncore_freq_ghz = counters.uncore_freq_ghz;
+            metrics->imc_reads_gbps = counters.imc_reads_gbps;
+            metrics->imc_writes_gbps = counters.imc_writes_gbps;
+            metrics->timestamp = timestamp;
+        }
+    }
+
+    /* Collect system-wide metrics */
+    pcm_system_counters_t sys_counters;
+    if (pcm_wrapper_get_system_counters(&sys_counters) == 0) {
+        struct pcm_system_metrics *metrics = &g_pcm_state.system_metrics;
+        metrics->active_cores = sys_counters.active_cores;
+        metrics->total_energy_joules = sys_counters.total_energy_joules;
+        metrics->package_energy_joules = sys_counters.package_energy_joules;
+        metrics->dram_energy_joules = sys_counters.dram_energy_joules;
+        metrics->total_ipc = sys_counters.total_ipc;
+        metrics->memory_bandwidth_utilization = sys_counters.memory_bandwidth_utilization;
+        metrics->thermal_throttle_ratio = sys_counters.thermal_throttle_ratio;
+        metrics->timestamp = timestamp;
+    }
+
+    g_pcm_state.last_measurement_timestamp = timestamp;
+    return 0;
+}
+
+/* Enhanced statistics display functions */
+void pcm_print_core_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    printf("\n=====================================\n");
+    printf("Intel PCM Core Performance Statistics\n");
+    printf("=====================================\n");
+    printf("%-5s %-12s %-12s %-6s %-10s %-8s %-8s %-6s %-6s %-8s\n",
+           "Core", "Cycles", "Instructions", "IPC", "L3 Misses", "L2 Hit%", "L3 Hit%", "Freq", "CPU%", "Energy");
+    printf("%-5s %-12s %-12s %-6s %-10s %-8s %-8s %-6s %-6s %-8s\n",
+           "----", "----------", "----------", "----", "---------", "------", "------", "----", "----", "------");
+
+    uint64_t total_cycles = 0, total_instructions = 0, total_l3_misses = 0;
+    double total_energy = 0.0;
+    uint32_t active_cores = 0;
+
+    uint32_t lcore_id;
+    RTE_LCORE_FOREACH(lcore_id) {
+        /* Check if lcore was initialized and has valid metrics */
+        if (g_pcm_state.lcore_states[lcore_id].initialized && 
+            (g_pcm_state.core_metrics[lcore_id].cycles > 0 || g_pcm_state.core_metrics[lcore_id].instructions > 0)) {
+            struct pcm_core_metrics *metrics = &g_pcm_state.core_metrics[lcore_id];
+            
+            printf("%-5u %-12lu %-12lu %-6.2f %-10lu %-8.1f %-8.1f %-6.2f %-6.1f %-8.2f\n",
+                   lcore_id,
+                   metrics->cycles,
+                   metrics->instructions,
+                   metrics->ipc,
+                   metrics->l3_cache_misses,
+                   metrics->l2_cache_hit_ratio * 100.0,
+                   metrics->l3_cache_hit_ratio * 100.0,
+                   metrics->frequency_ghz,
+                   metrics->cpu_utilization * 100.0,
+                   metrics->energy_joules);
+
+            total_cycles += metrics->cycles;
+            total_instructions += metrics->instructions;
+            total_l3_misses += metrics->l3_cache_misses;
+            total_energy += metrics->energy_joules;
+            active_cores++;
+        }
+    }
+
+    printf("%-5s %-12s %-12s %-6s %-10s %-8s %-8s %-6s %-6s %-8s\n",
+           "----", "----------", "----------", "----", "---------", "------", "------", "----", "----", "------");
+    
+    double avg_ipc = total_cycles > 0 ? (double)total_instructions / total_cycles : 0.0;
+    printf("%-5s %-12lu %-12lu %-6.2f %-10lu %-8s %-8s %-6s %-6s %-8.2f\n",
+           "Total", total_cycles, total_instructions, avg_ipc, total_l3_misses, 
+           "-", "-", "-", "-", total_energy);
+    
+    printf("Active Cores: %u\n", active_cores);
+    printf("=====================================\n");
+}
+
+void pcm_print_memory_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    printf("\n=====================================\n");
+    printf("Intel PCM Memory Performance Statistics\n");
+    printf("=====================================\n");
+    printf("%-6s %-12s %-12s %-10s %-10s %-8s %-8s %-8s\n",
+           "Socket", "DRAM Read", "DRAM Write", "Read BW", "Write BW", "MC Util%", "NUMA", "Local%");
+    printf("%-6s %-12s %-12s %-10s %-10s %-8s %-8s %-8s\n",
+           "------", "----------", "-----------", "--------", "---------", "--------", "----", "------");
+
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_memory_metrics *metrics = &g_pcm_state.memory_metrics[socket];
+        
+        if (metrics->timestamp > 0) {
+            printf("%-6u %-12lu %-12lu %-10.1f %-10.1f %-8.1f %-8lu %-8.1f\n",
+                   socket,
+                   metrics->dram_read_bytes,
+                   metrics->dram_write_bytes,
+                   metrics->dram_read_bandwidth_mbps,
+                   metrics->dram_write_bandwidth_mbps,
+                   metrics->memory_controller_utilization * 100.0,
+                   metrics->numa_local_accesses + metrics->numa_remote_accesses,
+                   metrics->numa_ratio * 100.0);
+        }
+    }
+    printf("=====================================\n");
+}
+
+void pcm_print_io_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    printf("\n=====================================\n");
+    printf("Intel PCM I/O Performance Statistics\n");
+    printf("=====================================\n");
+    printf("%-6s %-12s %-12s %-10s %-10s %-8s %-8s %-8s\n",
+           "Socket", "PCIe Read", "PCIe Write", "PCIe R BW", "PCIe W BW", "UPI Util%", "IMC R", "IMC W");
+    printf("%-6s %-12s %-12s %-10s %-10s %-8s %-8s %-8s\n",
+           "------", "----------", "-----------", "---------", "---------", "---------", "-----", "-----");
+
+    for (uint32_t socket = 0; socket < PCM_MAX_SOCKETS; socket++) {
+        struct pcm_io_metrics *metrics = &g_pcm_state.io_metrics[socket];
+        
+        if (metrics->timestamp > 0) {
+            printf("%-6u %-12lu %-12lu %-10.1f %-10.1f %-9.1f %-8.2f %-8.2f\n",
+                   socket,
+                   metrics->pcie_read_bytes,
+                   metrics->pcie_write_bytes,
+                   metrics->pcie_read_bandwidth_mbps,
+                   metrics->pcie_write_bandwidth_mbps,
+                   metrics->qpi_upi_utilization * 100.0,
+                   metrics->imc_reads_gbps,
+                   metrics->imc_writes_gbps);
+        }
+    }
+    printf("=====================================\n");
+}
+
+void pcm_print_system_statistics(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        return;
+    }
+
+    struct pcm_system_metrics *metrics = &g_pcm_state.system_metrics;
+    
+    printf("\n=====================================\n");
+    printf("Intel PCM System-Wide Statistics\n");
+    printf("=====================================\n");
+    printf("Active Cores: %u\n", metrics->active_cores);
+    printf("Total IPC: %.2f\n", metrics->total_ipc);
+    printf("Total Energy: %.2f J\n", metrics->total_energy_joules);
+    printf("Package Energy: %.2f J\n", metrics->package_energy_joules);
+    printf("DRAM Energy: %.2f J\n", metrics->dram_energy_joules);
+    printf("Memory BW Utilization: %.1f%%\n", metrics->memory_bandwidth_utilization * 100.0);
+    printf("Thermal Throttle Ratio: %.1f%%\n", metrics->thermal_throttle_ratio * 100.0);
+    printf("=====================================\n");
+}
+
+/* Additional utility functions */
+
+bool pcm_monitoring_is_available(void)
+{
+    return g_pcm_state.pcm_initialized;
+}
+
+int pcm_monitoring_get_lcore_metrics(uint32_t lcore_id, struct pcm_core_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics || lcore_id >= RTE_MAX_LCORE) {
+        return -1;
+    }
+    
+    if (!g_pcm_state.lcore_states[lcore_id].monitoring_active) {
+        return -1;
+    }
+    
+    *metrics = g_pcm_state.core_metrics[lcore_id];
+    return 0;
+}
+
+int pcm_monitoring_get_memory_metrics(uint32_t socket_id, struct pcm_memory_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics || socket_id >= PCM_MAX_SOCKETS) {
+        return -1;
+    }
+    
+    *metrics = g_pcm_state.memory_metrics[socket_id];
+    return 0;
+}
+
+int pcm_monitoring_get_io_metrics(uint32_t socket_id, struct pcm_io_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics || socket_id >= PCM_MAX_SOCKETS) {
+        return -1;
+    }
+    
+    *metrics = g_pcm_state.io_metrics[socket_id];
+    return 0;
+}
+
+int pcm_monitoring_get_system_metrics(struct pcm_system_metrics *metrics)
+{
+    if (!g_pcm_state.pcm_initialized || !metrics) {
+        return -1;
+    }
+    
+    *metrics = g_pcm_state.system_metrics;
+    return 0;
+}
+
+void pcm_monitoring_print_summary(void)
+{
+    if (!g_pcm_state.pcm_initialized) {
+        printf("PCM monitoring not available\n");
+        return;
+    }
+    
+    printf("\n=== COMPREHENSIVE PCM PERFORMANCE SUMMARY ===\n");
+    pcm_print_core_statistics();
+    pcm_print_memory_statistics();
+    pcm_print_io_statistics();
+    pcm_print_system_statistics();
+    printf("=== END PCM PERFORMANCE SUMMARY ===\n");
+}
+
+int pcm_monitoring_get_info(char *info_buffer, size_t buffer_size)
+{
+    if (!info_buffer || buffer_size == 0) {
+        return -1;
+    }
+
+    if (!g_pcm_state.pcm_initialized) {
+        snprintf(info_buffer, buffer_size, "PCM monitoring not initialized");
+        return -1;
+    }
+
+    if (g_pcm_state.use_static_wrapper) {
+        return pcm_wrapper_get_system_info(info_buffer, buffer_size);
+    } else {
+        snprintf(info_buffer, buffer_size, "PCM monitoring active (fallback mode)");
+        return 0;
+    }
+}
diff --git a/examples/l3fwd/l3fwd_pcm.h b/examples/l3fwd/l3fwd_pcm.h
new file mode 100644
index 0000000000..998019c89f
--- /dev/null
+++ b/examples/l3fwd/l3fwd_pcm.h
@@ -0,0 +1,198 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2010-2025 Intel Corporation
+ */
+
+#ifndef __L3FWD_PCM_H__
+#define __L3FWD_PCM_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <rte_common.h>
+#include <rte_lcore.h>
+#include "l3fwd_pcm_wrapper.h"
+
+/* Maximum number of performance events to track */
+#define PCM_MAX_EVENTS 16
+#define PCM_MAX_LCORES RTE_MAX_LCORE
+#define PCM_MAX_SOCKETS 8
+
+/* Enhanced performance metrics structure */
+struct pcm_core_metrics {
+    uint64_t instructions;          /* Instructions retired */
+    uint64_t cycles;                /* CPU cycles */
+    uint64_t l2_cache_hits;        /* L2 cache hits */
+    uint64_t l2_cache_misses;      /* L2 cache misses */
+    uint64_t l3_cache_hits;        /* L3 cache hits */
+    uint64_t l3_cache_misses;      /* L3 cache misses (LLC) */
+    double ipc;                    /* Instructions per cycle */
+    double l2_cache_hit_ratio;     /* L2 cache hit ratio */
+    double l3_cache_hit_ratio;     /* L3 cache hit ratio */
+    double frequency_ghz;          /* Core frequency in GHz */
+    double cpu_utilization;        /* CPU utilization percentage */
+    double energy_joules;          /* Energy consumption in Joules */
+    uint64_t timestamp;            /* Timestamp of measurement */
+};
+
+/* Memory performance metrics structure */
+struct pcm_memory_metrics {
+    uint64_t dram_read_bytes;      /* DRAM read bytes */
+    uint64_t dram_write_bytes;     /* DRAM write bytes */
+    double dram_read_bandwidth_mbps;    /* DRAM read bandwidth MB/s */
+    double dram_write_bandwidth_mbps;   /* DRAM write bandwidth MB/s */
+    double memory_controller_utilization; /* Memory controller utilization */
+    uint64_t numa_local_accesses;      /* NUMA local memory accesses */
+    uint64_t numa_remote_accesses;     /* NUMA remote memory accesses */
+    double numa_ratio;                 /* NUMA locality ratio */
+    uint64_t timestamp;
+};
+
+/* I/O and uncore performance metrics structure */
+struct pcm_io_metrics {
+    uint64_t pcie_read_bytes;      /* PCIe read bytes */
+    uint64_t pcie_write_bytes;     /* PCIe write bytes */
+    double pcie_read_bandwidth_mbps;    /* PCIe read bandwidth MB/s */
+    double pcie_write_bandwidth_mbps;   /* PCIe write bandwidth MB/s */
+    uint64_t qpi_upi_data_bytes;       /* QPI/UPI data bytes */
+    double qpi_upi_utilization;        /* QPI/UPI utilization percentage */
+    uint64_t uncore_freq_ghz;          /* Uncore frequency GHz */
+    double imc_reads_gbps;             /* IMC reads GB/s */
+    double imc_writes_gbps;            /* IMC writes GB/s */
+    uint64_t timestamp;
+};
+
+/* System-wide PCM metrics */
+struct pcm_system_metrics {
+    uint32_t active_cores;              /* Number of active cores */
+    double total_energy_joules;         /* Total energy consumption */
+    double package_energy_joules;       /* Package energy consumption */
+    double dram_energy_joules;          /* DRAM energy consumption */
+    double total_ipc;                   /* System-wide IPC */
+    double memory_bandwidth_utilization; /* Memory bandwidth utilization % */
+    double thermal_throttle_ratio;      /* Thermal throttling ratio */
+    uint64_t timestamp;
+};
+
+/* Per-lcore PCM state */
+struct pcm_lcore_state {
+    uint32_t lcore_id;
+    uint32_t socket_id;
+    bool initialized;
+    bool monitoring_active;
+};
+
+/* Function declarations */
+
+/**
+ * Initialize PCM monitoring system
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_init(void);
+
+/**
+ * Cleanup PCM monitoring system
+ */
+void pcm_monitoring_cleanup(void);
+
+/**
+ * Start monitoring on a specific lcore
+ * @param lcore_id: The lcore to start monitoring
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_start_lcore(uint32_t lcore_id);
+
+/**
+ * Stop monitoring on a specific lcore
+ * @param lcore_id: The lcore to stop monitoring
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_stop_lcore(uint32_t lcore_id);
+
+/**
+ * Start monitoring on all active lcores
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_start_all(void);
+
+/**
+ * Stop monitoring on all active lcores
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_stop_all(void);
+
+/**
+ * Take measurements on all active lcores and collect comprehensive statistics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_measure_all(void);
+
+/**
+ * Check if PCM monitoring is available and initialized
+ * @return true if available, false otherwise
+ */
+bool pcm_monitoring_is_available(void);
+
+/**
+ * Get current core metrics for a specific lcore
+ * @param lcore_id: The lcore to query
+ * @param metrics: Pointer to store the core metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_lcore_metrics(uint32_t lcore_id, struct pcm_core_metrics *metrics);
+
+/**
+ * Get memory metrics for a specific socket
+ * @param socket_id: The socket to query
+ * @param metrics: Pointer to store the memory metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_memory_metrics(uint32_t socket_id, struct pcm_memory_metrics *metrics);
+
+/**
+ * Get I/O metrics for a specific socket
+ * @param socket_id: The socket to query
+ * @param metrics: Pointer to store the I/O metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_io_metrics(uint32_t socket_id, struct pcm_io_metrics *metrics);
+
+/**
+ * Get system-wide metrics
+ * @param metrics: Pointer to store the system metrics
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_system_metrics(struct pcm_system_metrics *metrics);
+
+/**
+ * Print core performance statistics for all lcores
+ */
+void pcm_print_core_statistics(void);
+
+/**
+ * Print memory performance statistics for all sockets
+ */
+void pcm_print_memory_statistics(void);
+
+/**
+ * Print I/O performance statistics for all sockets
+ */
+void pcm_print_io_statistics(void);
+
+/**
+ * Print system-wide performance statistics
+ */
+void pcm_print_system_statistics(void);
+
+/**
+ * Print comprehensive performance summary (all categories)
+ */
+void pcm_monitoring_print_summary(void);
+
+/**
+ * Get PCM system information
+ * @param info_buffer: Buffer to store system info
+ * @param buffer_size: Size of the buffer
+ * @return 0 on success, negative on error
+ */
+int pcm_monitoring_get_info(char *info_buffer, size_t buffer_size);
+
+#endif /* __L3FWD_PCM_H__ */
diff --git a/examples/l3fwd/l3fwd_pcm_new.h b/examples/l3fwd/l3fwd_pcm_new.h
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/examples/l3fwd/l3fwd_pcm_simple.c b/examples/l3fwd/l3fwd_pcm_simple.c
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/examples/l3fwd/l3fwd_pcm_wrapper.cpp b/examples/l3fwd/l3fwd_pcm_wrapper.cpp
new file mode 100644
index 0000000000..b9b52a9f15
--- /dev/null
+++ b/examples/l3fwd/l3fwd_pcm_wrapper.cpp
@@ -0,0 +1,692 @@
+// C++ wrapper for PCM that will be statically linked
+#include "l3fwd_pcm_wrapper.h"
+#include <iostream>
+#include <memory>
+#include <cstdlib>
+#include <cstdio>
+#include <cstring>
+#include <unistd.h>
+
+// Intel PCM includes
+#include "cpucounters.h"
+
+using namespace pcm;
+
+extern "C" {
+
+// Global PCM state
+static PCM* g_pcm_instance = nullptr;
+static bool g_initialized = false;
+static bool g_measurement_active = false;
+
+// Counter state storage
+static std::vector<CoreCounterState> g_before_core_states;
+static std::vector<CoreCounterState> g_after_core_states;
+static std::vector<SocketCounterState> g_before_socket_states;
+static std::vector<SocketCounterState> g_after_socket_states;
+static SystemCounterState g_before_system_state;
+static SystemCounterState g_after_system_state;
+
+int pcm_wrapper_is_available(void) {
+    // Always return 1 for now, as PCM is statically linked
+    return 1;
+}
+
+int pcm_wrapper_init(void) {
+    if (g_initialized) {
+        return 0;  // Already initialized
+    }
+    
+    g_pcm_instance = PCM::getInstance();
+    if (!g_pcm_instance) {
+        printf("ERROR: Failed to get PCM instance\n");
+        return -1;
+    }
+    
+    // Check access permissions
+    printf("*** Attempting to program Intel PCM counters... ***\n");
+    auto status = g_pcm_instance->program();
+    
+    if (status == PCM::Success) {
+        printf("*** SUCCESS: Intel PCM counters programmed successfully! ***\n");
+        g_initialized = true;
+        
+        // Initialize state vectors
+        uint32_t num_cores = g_pcm_instance->getNumCores();
+        uint32_t num_sockets = g_pcm_instance->getNumSockets();
+        
+        g_before_core_states.resize(num_cores);
+        g_after_core_states.resize(num_cores);
+        g_before_socket_states.resize(num_sockets);
+        g_after_socket_states.resize(num_sockets);
+        
+        return 0;
+    } else if (status == PCM::MSRAccessDenied) {
+        printf("WARNING: MSR access denied, trying without MSR\n");
+        // Try programming with reduced privileges
+        status = g_pcm_instance->program(PCM::DEFAULT_EVENTS, nullptr, false, -1);
+        if (status == PCM::Success) {
+            printf("*** SUCCESS: Intel PCM counters programmed successfully (no MSR mode)! ***\n");
+            g_initialized = true;
+            return 0;
+        }
+    } else if (status == PCM::PMUBusy) {
+        printf("WARNING: PMU busy, trying to reset and retry\n");
+        g_pcm_instance->resetPMU();
+        status = g_pcm_instance->program();
+        if (status == PCM::Success) {
+            printf("*** SUCCESS: Intel PCM counters programmed successfully after reset! ***\n");
+            g_initialized = true;
+            
+            // Initialize state vectors
+            uint32_t num_cores = g_pcm_instance->getNumCores();
+            uint32_t num_sockets = g_pcm_instance->getNumSockets();
+            
+            g_before_core_states.resize(num_cores);
+            g_after_core_states.resize(num_cores);
+            g_before_socket_states.resize(num_sockets);
+            g_after_socket_states.resize(num_sockets);
+            
+            return 0;
+        }
+    }
+    
+    // Print detailed error information
+    printf("ERROR: Failed to program PCM counters. Status: %d\n", (int)status);
+    switch (status) {
+        case PCM::MSRAccessDenied:
+            printf("  - MSR access denied. Try running with sudo or check permissions.\n");
+            break;
+        case PCM::PMUBusy:
+            printf("  - PMU is busy. Another profiling tool might be running.\n");
+            break;
+        case PCM::UnknownError:
+            printf("  - Unknown error occurred.\n");
+            break;
+        default:
+            printf("  - Unhandled error code: %d\n", (int)status);
+            break;
+    }
+    
+    return -1;
+}
+
+void pcm_wrapper_cleanup(void) {
+    if (g_pcm_instance) {
+        g_pcm_instance->cleanup();
+        g_pcm_instance = nullptr;
+    }
+    g_initialized = false;
+    g_measurement_active = false;
+    
+    // Clear state vectors
+    g_before_core_states.clear();
+    g_after_core_states.clear();
+    g_before_socket_states.clear();
+    g_after_socket_states.clear();
+}
+
+int pcm_wrapper_start_measurement(void) {
+    if (!g_initialized || !g_pcm_instance) {
+        printf("ERROR: PCM not initialized when trying to start measurement\n");
+        return -1;
+    }
+    
+    try {
+        // Wait a bit to ensure clean counter state
+        usleep(100000); // 100ms
+        
+        g_before_system_state = getSystemCounterState();
+        
+        uint32_t num_cores = g_pcm_instance->getNumCores();
+        if (num_cores == 0 || num_cores > 1024) {
+            printf("DEBUG: Suspicious core count %u, measurement may be unreliable\n", num_cores);
+        }
+        
+        for (uint32_t i = 0; i < num_cores; ++i) {
+            g_before_core_states[i] = getCoreCounterState(i);
+        }
+        
+        uint32_t num_sockets = g_pcm_instance->getNumSockets();
+        for (uint32_t i = 0; i < num_sockets; ++i) {
+            g_before_socket_states[i] = getSocketCounterState(i);
+        }
+        
+        g_measurement_active = true;
+        
+        printf("PCM measurement started, capturing states for %u cores and %u sockets\n", 
+               num_cores, num_sockets);
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error capturing initial PCM states: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error capturing initial PCM states\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_stop_measurement(void) {
+    if (!g_initialized || !g_pcm_instance) {
+        printf("ERROR: PCM not initialized when trying to stop measurement\n");
+        return -1;
+    }
+    
+    try {
+        // Always capture final states regardless of g_measurement_active
+        g_after_system_state = getSystemCounterState();
+        
+        uint32_t num_cores = g_pcm_instance->getNumCores();
+        for (uint32_t i = 0; i < num_cores; ++i) {
+            g_after_core_states[i] = getCoreCounterState(i);
+        }
+        
+        uint32_t num_sockets = g_pcm_instance->getNumSockets();
+        for (uint32_t i = 0; i < num_sockets; ++i) {
+            g_after_socket_states[i] = getSocketCounterState(i);
+        }
+        
+        g_measurement_active = false;
+        printf("PCM measurement stopped, captured states for %u cores and %u sockets\n", 
+               num_cores, num_sockets);
+               
+        // Quick sanity check - test one core calculation
+        if (num_cores > 0) {
+            try {
+                double test_ipc = getIPC(g_before_core_states[0], g_after_core_states[0]);
+                uint64_t test_cycles = getCycles(g_before_core_states[0], g_after_core_states[0]);
+                
+                // Check for suspicious values that indicate measurement problems
+                if (test_ipc <= 0.001 || test_ipc > 10.0) {
+                    printf("DEBUG: WARNING - Suspicious IPC value %.3f detected in measurement\n", test_ipc);
+                }
+                if (test_cycles < 1000 || test_cycles > 1000000000000ULL) {
+                    printf("DEBUG: WARNING - Suspicious cycle count %lu detected in measurement\n", test_cycles);
+                }
+            } catch (...) {
+                printf("DEBUG: ERROR - Failed to perform sanity check calculation\n");
+            }
+        }
+        
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error capturing final PCM states: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error capturing final PCM states\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_basic_counters(uint32_t core_id, uint64_t* cycles, uint64_t* instructions) {
+    if (!g_initialized || !g_pcm_instance || !cycles || !instructions) {
+        return -1;
+    }
+    
+    try {
+        if (core_id >= g_pcm_instance->getNumCores()) {
+            return -1;
+        }
+        
+        *cycles = getCycles(g_before_core_states[core_id], g_after_core_states[core_id]);
+        *instructions = getInstructionsRetired(g_before_core_states[core_id], g_after_core_states[core_id]);
+        return 0;
+    } catch (...) {
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_core_counters(uint32_t core_id, pcm_core_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+    
+    try {
+        uint32_t num_cores = g_pcm_instance->getNumCores();
+        uint32_t pcm_core_id = core_id;
+        
+        // Map DPDK lcore to PCM core with bounds checking
+        if (pcm_core_id >= num_cores) {
+            printf("Warning: DPDK lcore %u exceeds PCM cores %u, using modulo mapping\n", 
+                   core_id, num_cores);
+            pcm_core_id = core_id % num_cores;
+        }
+        
+        // Make sure we have valid before/after states
+        if (g_before_core_states.size() <= pcm_core_id || g_after_core_states.size() <= pcm_core_id) {
+            printf("ERROR: Invalid core state vectors for core %u\n", pcm_core_id);
+            return -1;
+        }
+        
+        // Use the stored before/after states to calculate metrics over the entire measurement period
+        const CoreCounterState& before = g_before_core_states[pcm_core_id];
+        const CoreCounterState& after = g_after_core_states[pcm_core_id];
+        
+        // Calculate metrics using PCM's built-in functions with error checking
+        double ipc = 0.0;
+        double freq_ghz = 0.0;
+        double util = 0.0;
+        double l2_hit_ratio = 0.0;
+        double l3_hit_ratio = 0.0;
+        uint64_t cycles = 0;
+        uint64_t instructions = 0;
+        uint64_t l2_hits = 0;
+        uint64_t l2_misses = 0;
+        uint64_t l3_hits = 0;
+        uint64_t l3_misses = 0;
+        
+        try {
+            ipc = getIPC(before, after);
+            if (std::isnan(ipc) || std::isinf(ipc) || ipc < 0 || ipc > 10) {
+                printf("WARNING: Invalid IPC value %.3f, setting to 0\n", ipc);
+                ipc = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate IPC\n");
+            ipc = 0.0;
+        }
+        
+        try {
+            freq_ghz = getAverageFrequency(before, after) / 1e9;
+            if (std::isnan(freq_ghz) || std::isinf(freq_ghz) || freq_ghz < 0 || freq_ghz > 10) {
+                printf("WARNING: Invalid frequency %.3f, setting to 0\n", freq_ghz);
+                freq_ghz = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate frequency\n");
+            freq_ghz = 0.0;
+        }
+        
+        try {
+            util = getActiveRelativeFrequency(before, after);
+            if (std::isnan(util) || std::isinf(util) || util < 0 || util > 2) {
+                printf("WARNING: Invalid utilization %.3f, setting to 0\n", util);
+                util = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate utilization\n");
+            util = 0.0;
+        }
+        
+        try {
+            l2_hit_ratio = getL2CacheHitRatio(before, after);
+            if (std::isnan(l2_hit_ratio) || std::isinf(l2_hit_ratio) || l2_hit_ratio < 0 || l2_hit_ratio > 1) {
+                printf("WARNING: Invalid L2 hit ratio %.3f, setting to 0\n", l2_hit_ratio);
+                l2_hit_ratio = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate L2 hit ratio\n");
+            l2_hit_ratio = 0.0;
+        }
+        
+        try {
+            l3_hit_ratio = getL3CacheHitRatio(before, after);
+            if (std::isnan(l3_hit_ratio) || std::isinf(l3_hit_ratio) || l3_hit_ratio < 0 || l3_hit_ratio > 1) {
+                printf("WARNING: Invalid L3 hit ratio %.3f, setting to 0\n", l3_hit_ratio);
+                l3_hit_ratio = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate L3 hit ratio\n");
+            l3_hit_ratio = 0.0;
+        }
+        
+        // Get raw counter values with overflow protection
+        try {
+            cycles = getCycles(before, after);
+            // Check for reasonable cycle count - allow much higher values for longer measurements
+            if (cycles > 1000000000000ULL) {  // 1T cycles (much higher threshold)
+                printf("WARNING: Suspicious cycle count %lu, setting to 0\n", cycles);
+                cycles = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get cycles\n");
+            cycles = 0;
+        }
+        
+        try {
+            instructions = getInstructionsRetired(before, after);
+            // Adjust threshold for instructions - allow much higher values for longer measurements
+            if (instructions > 1000000000000ULL) {  // 1T instructions (much higher threshold)
+                printf("WARNING: Suspicious instruction count %lu, setting to 0\n", instructions);
+                instructions = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get instructions\n");
+            instructions = 0;
+        }
+        
+        try {
+            l2_hits = getL2CacheHits(before, after);
+            if (l2_hits > 100000000000ULL) {  // 100B threshold
+                printf("WARNING: Suspicious L2 hit count %lu, setting to 0\n", l2_hits);
+                l2_hits = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get L2 hits\n");
+            l2_hits = 0;
+        }
+        
+        try {
+            l2_misses = getL2CacheMisses(before, after);
+            if (l2_misses > 100000000000ULL) {  // 100B threshold
+                printf("WARNING: Suspicious L2 miss count %lu, setting to 0\n", l2_misses);
+                l2_misses = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get L2 misses\n");
+            l2_misses = 0;
+        }
+        
+        try {
+            l3_hits = getL3CacheHits(before, after);
+            if (l3_hits > 100000000000ULL) {  // 100B threshold
+                printf("WARNING: Suspicious L3 hit count %lu, setting to 0\n", l3_hits);
+                l3_hits = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get L3 hits\n");
+            l3_hits = 0;
+        }
+        
+        try {
+            l3_misses = getL3CacheMisses(before, after);
+            if (l3_misses > 100000000000ULL) {  // 100B threshold
+                printf("WARNING: Suspicious L3 miss count %lu, setting to 0\n", l3_misses);
+                l3_misses = 0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to get L3 misses\n");
+            l3_misses = 0;
+        }
+        
+        // Store all the calculated metrics
+        counters->cycles = cycles;
+        counters->instructions = instructions;
+        counters->l2_cache_hits = l2_hits;
+        counters->l2_cache_misses = l2_misses;
+        counters->l3_cache_hits = l3_hits;
+        counters->l3_cache_misses = l3_misses;
+        counters->ipc = ipc;
+        counters->l2_cache_hit_ratio = l2_hit_ratio;
+        counters->l3_cache_hit_ratio = l3_hit_ratio;
+        counters->frequency_ghz = freq_ghz;
+        counters->cpu_utilization = util;
+        
+        // Check for completely zero metrics which might indicate measurement issues
+        if (cycles == 0 && instructions == 0 && ipc == 0.0) {
+            printf("DEBUG: WARNING - All core metrics are zero for core %u, check PCM measurement\n", core_id);
+        }
+        
+        // Energy estimation (may need different approach depending on PCM version)
+        try {
+            // For core-level energy, we need to use system-level or socket-level energy
+            // Core-level energy might not be available in all PCM versions
+            counters->energy_joules = 0.0; // Default for core-level
+        } catch (...) {
+            counters->energy_joules = 0.0;
+        }
+        
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error in PCM counter calculation: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error in PCM counter calculation\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_memory_counters(uint32_t socket_id, pcm_memory_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+    
+    try {
+        if (socket_id >= g_pcm_instance->getNumSockets()) {
+            return -1;
+        }
+        
+        // Take two consecutive measurements
+        SocketCounterState state1 = getSocketCounterState(socket_id);
+        usleep(10000); // 10ms delay  
+        SocketCounterState state2 = getSocketCounterState(socket_id);
+        
+        // Use PCM's built-in bandwidth calculation methods
+        uint64_t bytes_read = getBytesReadFromMC(state1, state2);
+        uint64_t bytes_written = getBytesWrittenToMC(state1, state2);
+        
+        // Convert to reasonable values (10ms measurement period)
+        double time_sec = 0.01; // 10ms
+        counters->dram_read_bytes = bytes_read;
+        counters->dram_write_bytes = bytes_written;
+        counters->dram_read_bandwidth_mbps = (double)bytes_read / (1024.0 * 1024.0) / time_sec;
+        counters->dram_write_bandwidth_mbps = (double)bytes_written / (1024.0 * 1024.0) / time_sec;
+        
+        // Estimate utilization 
+        double total_bw = counters->dram_read_bandwidth_mbps + counters->dram_write_bandwidth_mbps;
+        counters->memory_controller_utilization = (total_bw / 100000.0); // Assume 100 GB/s max = 100000 MB/s
+        if (counters->memory_controller_utilization > 1.0) counters->memory_controller_utilization = 0.0;
+        
+        // Initialize NUMA fields properly
+        counters->numa_local_accesses = 0;
+        counters->numa_remote_accesses = 0;
+        counters->numa_ratio = 0.8; // Default
+        
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error in memory counter calculation: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error in memory counter calculation\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_io_counters(uint32_t socket_id, pcm_io_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+    
+    try {
+        if (socket_id >= g_pcm_instance->getNumSockets()) {
+            return -1;
+        }
+        
+        // Take two consecutive measurements for I/O counters
+        SocketCounterState state1 = getSocketCounterState(socket_id);
+        usleep(10000); // 10ms delay
+        SocketCounterState state2 = getSocketCounterState(socket_id);
+        
+        // Try to get PCIe read/write bytes using PCM functions
+        uint64_t pcie_read_bytes = 0;
+        uint64_t pcie_write_bytes = 0;
+        
+        // PCM might have specific PCIe counter functions - try memory controller as proxy
+        uint64_t mc_reads = getBytesReadFromMC(state1, state2);
+        uint64_t mc_writes = getBytesWrittenToMC(state1, state2);
+        
+        // For network-intensive workloads, significant portion of memory traffic is PCIe-related
+        // Estimate PCIe traffic as a fraction of memory controller traffic
+        double pcie_fraction = 0.3; // Assume 30% of memory traffic is PCIe-related
+        
+        if (mc_reads < 10000000000ULL && mc_writes < 10000000000ULL) { // Sanity check
+            pcie_read_bytes = (uint64_t)(mc_reads * pcie_fraction);
+            pcie_write_bytes = (uint64_t)(mc_writes * pcie_fraction);
+        }
+        
+        // Calculate bandwidth (10ms measurement period)
+        double time_sec = 0.01;
+        counters->pcie_read_bytes = pcie_read_bytes;
+        counters->pcie_write_bytes = pcie_write_bytes;
+        counters->pcie_read_bandwidth_mbps = (double)pcie_read_bytes / (1024.0 * 1024.0) / time_sec;
+        counters->pcie_write_bandwidth_mbps = (double)pcie_write_bytes / (1024.0 * 1024.0) / time_sec;
+        
+        // Memory controller bandwidth (IMC)
+        counters->imc_reads_gbps = (double)mc_reads / (1024.0 * 1024.0 * 1024.0) / time_sec;
+        counters->imc_writes_gbps = (double)mc_writes / (1024.0 * 1024.0 * 1024.0) / time_sec;
+        
+        // QPI/UPI data transfer and utilization
+        counters->qpi_upi_data_bytes = 0; // PCM might not support this directly
+        counters->qpi_upi_utilization = 0.0;
+        counters->uncore_freq_ghz = 0; // Could try to get uncore frequency if available
+        
+        return 0;
+    } catch (const std::exception& e) {
+        printf("Error in I/O counter calculation: %s\n", e.what());
+        return -1;
+    } catch (...) {
+        printf("Unknown error in I/O counter calculation\n");
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_system_counters(pcm_system_counters_t* counters) {
+    if (!g_initialized || !g_pcm_instance || !counters) {
+        return -1;
+    }
+    
+    try {
+        // System-wide counters
+        counters->active_cores = g_pcm_instance->getNumOnlineCores();
+        
+        // Energy measurements with overflow protection
+        double total_energy_raw = 0.0;
+        double dram_energy_raw = 0.0;
+        
+        try {
+            total_energy_raw = getConsumedJoules(g_before_system_state, g_after_system_state);
+            if (std::isnan(total_energy_raw) || std::isinf(total_energy_raw) || total_energy_raw < 0 || total_energy_raw > 100000.0) {
+                printf("WARNING: Invalid total energy %.2f, setting to 0\n", total_energy_raw);
+                total_energy_raw = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate total energy\n");
+            total_energy_raw = 0.0;
+        }
+        
+        try {
+            dram_energy_raw = getDRAMConsumedJoules(g_before_system_state, g_after_system_state);
+            if (std::isnan(dram_energy_raw) || std::isinf(dram_energy_raw) || dram_energy_raw < 0 || dram_energy_raw > 100000.0) {
+                printf("WARNING: Invalid DRAM energy %.2f, setting to 0\n", dram_energy_raw);
+                dram_energy_raw = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate DRAM energy\n");
+            dram_energy_raw = 0.0;
+        }
+        
+        counters->total_energy_joules = total_energy_raw;
+        counters->package_energy_joules = total_energy_raw;
+        counters->dram_energy_joules = dram_energy_raw;
+        
+        // Check if energy measurements seem reasonable
+        if (total_energy_raw > 10000.0) {  // More than 10kJ seems very high
+            printf("DEBUG: WARNING - Very high energy consumption detected: total=%.1f J, dram=%.1f J\n", 
+                   total_energy_raw, dram_energy_raw);
+        } else if (total_energy_raw == 0.0 && dram_energy_raw == 0.0) {
+            printf("DEBUG: WARNING - Zero energy measurements detected, check PMU access\n");
+        }
+        
+        // System-wide IPC with overflow protection
+        double system_ipc_raw = 0.0;
+        try {
+            system_ipc_raw = getIPC(g_before_system_state, g_after_system_state);
+            if (std::isnan(system_ipc_raw) || std::isinf(system_ipc_raw) || system_ipc_raw < 0.0 || system_ipc_raw > 10.0) {
+                printf("WARNING: Invalid system IPC %.3f, setting to 0\n", system_ipc_raw);
+                system_ipc_raw = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate system IPC\n");
+            system_ipc_raw = 0.0;
+        }
+        counters->total_ipc = system_ipc_raw;
+        
+        // Memory bandwidth utilization
+        uint64_t total_mem_bytes_raw = 0;
+        double elapsed = 0.0;
+        
+        try {
+            uint64_t read_bytes = getBytesReadFromMC(g_before_system_state, g_after_system_state);
+            uint64_t write_bytes = getBytesWrittenToMC(g_before_system_state, g_after_system_state);
+            
+            if (read_bytes < 1000000000000000ULL && write_bytes < 1000000000000000ULL) {
+                total_mem_bytes_raw = read_bytes + write_bytes;
+            } else {
+                printf("WARNING: Suspicious memory byte counts: read=%lu, write=%lu\n", read_bytes, write_bytes);
+                total_mem_bytes_raw = 0;
+            }
+            
+            elapsed = getExecUsage(g_before_system_state, g_after_system_state);
+            if (std::isnan(elapsed) || std::isinf(elapsed) || elapsed <= 0 || elapsed > 1000.0) {
+                printf("WARNING: Invalid elapsed time %.3f, setting memory BW to 0\n", elapsed);
+                elapsed = 0.0;
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate memory bandwidth\n");
+            total_mem_bytes_raw = 0;
+            elapsed = 0.0;
+        }
+        
+        if (elapsed > 0 && total_mem_bytes_raw > 0) {
+            counters->memory_bandwidth_utilization = (double)total_mem_bytes_raw / (1024.0 * 1024.0 * 1024.0) / elapsed;  // GB/s
+            
+            // Check for unreasonably high memory bandwidth
+            if (counters->memory_bandwidth_utilization > 1000.0) {  // More than 1TB/s seems suspicious
+                printf("DEBUG: WARNING - Very high memory bandwidth detected: %.1f GB/s\n", 
+                       counters->memory_bandwidth_utilization);
+            }
+        } else {
+            counters->memory_bandwidth_utilization = 0.0;
+            if (elapsed <= 0) {
+                printf("DEBUG: WARNING - Invalid elapsed time %.3f for memory bandwidth calculation\n", elapsed);
+            }
+        }
+        
+        // Thermal throttling (approximate) with bounds check
+        double rel_freq = 0.0;
+        try {
+            rel_freq = getRelativeFrequency(g_before_system_state, g_after_system_state);
+            if (std::isnan(rel_freq) || std::isinf(rel_freq) || rel_freq < 0.0 || rel_freq > 2.0) {
+                printf("WARNING: Invalid relative frequency %.3f, setting throttle to 0\n", rel_freq);
+                rel_freq = 1.0;  // assume no throttling
+            }
+        } catch (...) {
+            printf("WARNING: Failed to calculate relative frequency\n");
+            rel_freq = 1.0;  // assume no throttling
+        }
+        
+        counters->thermal_throttle_ratio = (rel_freq > 0) ? (1.0 - rel_freq) : 0.0;
+        if (counters->thermal_throttle_ratio < 0) {
+            counters->thermal_throttle_ratio = 0.0;
+        }
+        
+        return 0;
+    } catch (...) {
+        return -1;
+    }
+}
+
+int pcm_wrapper_get_system_info(char* info_buffer, size_t buffer_size) {
+    if (!g_initialized || !g_pcm_instance) {
+        return -1;
+    }
+    
+    try {
+        snprintf(info_buffer, buffer_size, 
+                "CPU Brand: %s\n"
+                "Cores: %u\n"
+                "Online Cores: %u\n"
+                "Sockets: %u\n"
+                "Threads per Core: %u\n",
+                g_pcm_instance->getCPUBrandString().c_str(),
+                g_pcm_instance->getNumCores(),
+                g_pcm_instance->getNumOnlineCores(),
+                g_pcm_instance->getNumSockets(),
+                g_pcm_instance->getThreadsPerCore());
+        return 0;
+    } catch (...) {
+        return -1;
+    }
+}
+
+} // extern "C"
diff --git a/examples/l3fwd/l3fwd_pcm_wrapper.h b/examples/l3fwd/l3fwd_pcm_wrapper.h
new file mode 100644
index 0000000000..86b84086f4
--- /dev/null
+++ b/examples/l3fwd/l3fwd_pcm_wrapper.h
@@ -0,0 +1,146 @@
+#ifndef __L3FWD_PCM_WRAPPER_H__
+#define __L3FWD_PCM_WRAPPER_H__
+
+#include <stdint.h>
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* PCM wrapper functions for static linking */
+
+/* Core performance counters structure */
+typedef struct {
+    uint64_t cycles;
+    uint64_t instructions;
+    uint64_t l2_cache_hits;
+    uint64_t l2_cache_misses;
+    uint64_t l3_cache_hits;
+    uint64_t l3_cache_misses;
+    double ipc;
+    double l2_cache_hit_ratio;
+    double l3_cache_hit_ratio;
+    double frequency_ghz;
+    double cpu_utilization;
+    double energy_joules;
+} pcm_core_counters_t;
+
+/* Memory performance counters structure */
+typedef struct {
+    uint64_t dram_read_bytes;
+    uint64_t dram_write_bytes;
+    double dram_read_bandwidth_mbps;
+    double dram_write_bandwidth_mbps;
+    double memory_controller_utilization;
+    uint64_t numa_local_accesses;
+    uint64_t numa_remote_accesses;
+    double numa_ratio;
+} pcm_memory_counters_t;
+
+/* I/O and Uncore performance counters structure */
+typedef struct {
+    uint64_t pcie_read_bytes;
+    uint64_t pcie_write_bytes;
+    double pcie_read_bandwidth_mbps;
+    double pcie_write_bandwidth_mbps;
+    uint64_t qpi_upi_data_bytes;
+    double qpi_upi_utilization;
+    uint64_t uncore_freq_ghz;
+    double imc_reads_gbps;
+    double imc_writes_gbps;
+} pcm_io_counters_t;
+
+/* System-wide performance counters structure */
+typedef struct {
+    uint32_t active_cores;
+    double total_energy_joules;
+    double package_energy_joules;
+    double dram_energy_joules;
+    double total_ipc;
+    double memory_bandwidth_utilization;
+    double thermal_throttle_ratio;
+} pcm_system_counters_t;
+
+/**
+ * Check if PCM wrapper is available
+ * @return 1 if available, 0 if not
+ */
+int pcm_wrapper_is_available(void);
+
+/**
+ * Initialize PCM wrapper
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_init(void);
+
+/**
+ * Cleanup PCM wrapper
+ */
+void pcm_wrapper_cleanup(void);
+
+/**
+ * Get basic performance counters
+ * @param core_id: Core ID to get counters for
+ * @param cycles: Pointer to store cycle count
+ * @param instructions: Pointer to store instruction count
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_basic_counters(uint32_t core_id, uint64_t *cycles, uint64_t *instructions);
+
+/**
+ * Get comprehensive core performance counters
+ * @param core_id: Core ID to get counters for
+ * @param counters: Pointer to store core counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_core_counters(uint32_t core_id, pcm_core_counters_t *counters);
+
+/**
+ * Get memory performance counters
+ * @param socket_id: Socket ID to get counters for
+ * @param counters: Pointer to store memory counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_memory_counters(uint32_t socket_id, pcm_memory_counters_t *counters);
+
+/**
+ * Get I/O and uncore performance counters
+ * @param socket_id: Socket ID to get counters for
+ * @param counters: Pointer to store I/O counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_io_counters(uint32_t socket_id, pcm_io_counters_t *counters);
+
+/**
+ * Get system-wide performance counters
+ * @param counters: Pointer to store system counters
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_system_counters(pcm_system_counters_t *counters);
+
+/**
+ * Start measurement period
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_start_measurement(void);
+
+/**
+ * Stop measurement period and calculate differences
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_stop_measurement(void);
+
+/**
+ * Get system information
+ * @param info_buffer Buffer to store system info
+ * @param buffer_size Size of the buffer
+ * @return 0 on success, negative on error
+ */
+int pcm_wrapper_get_system_info(char* info_buffer, size_t buffer_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __L3FWD_PCM_WRAPPER_H__ */
diff --git a/examples/l3fwd/main.c b/examples/l3fwd/main.c
index ae3b4f6439..306be4ed0d 100644
--- a/examples/l3fwd/main.c
+++ b/examples/l3fwd/main.c
@@ -48,6 +48,7 @@
 #include "l3fwd.h"
 #include "l3fwd_event.h"
 #include "l3fwd_route.h"
+#include "l3fwd_pcm.h"
 
 #define MAX_TX_QUEUE_PER_PORT RTE_MAX_LCORE
 #define MAX_RX_QUEUE_PER_PORT 128
@@ -131,7 +132,8 @@ static struct rte_eth_conf port_conf = {
 	.rx_adv_conf = {
 		.rss_conf = {
 			.rss_key = NULL,
-			.rss_hf = RTE_ETH_RSS_IP,
+			// .rss_hf = RTE_ETH_RSS_IP,
+			.rss_hf = RTE_ETH_RSS_IP | RTE_ETH_RSS_TCP | RTE_ETH_RSS_UDP,
 		},
 	},
 	.txmode = {
@@ -1065,10 +1067,11 @@ parse_args(int argc, char **argv)
 	}
 
 	/* For ACL, update port config rss hash filter */
-	if (lookup_mode == L3FWD_LOOKUP_ACL) {
-		port_conf.rx_adv_conf.rss_conf.rss_hf |=
-				RTE_ETH_RSS_UDP | RTE_ETH_RSS_TCP | RTE_ETH_RSS_SCTP;
-	}
+	// if (lookup_mode == L3FWD_LOOKUP_ACL) {
+	// 	port_conf.rx_adv_conf.rss_conf.rss_hf |=
+	// 			RTE_ETH_RSS_UDP | RTE_ETH_RSS_TCP | RTE_ETH_RSS_SCTP;
+	// }
+	/* RSS hash filter now includes TCP/UDP ports for all modes */
 
 	if (optind >= 0)
 		argv[optind-1] = prgname;
@@ -1230,12 +1233,172 @@ check_all_ports_link_status(uint32_t port_mask)
 	}
 }
 
+/**
+ * print_nic_hw_stats - Print NIC hardware statistics for a specific port
+ *
+ * DESCRIPTION
+ * Print detailed NIC hardware statistics including drops, errors, and buffer states
+ *
+ * RETURNS: N/A
+ */
+static void
+print_nic_hw_stats(uint16_t port_id)
+{
+    struct rte_eth_stats eth_stats;
+    struct rte_eth_xstat *xstats = NULL;
+    struct rte_eth_xstat_name *xstat_names = NULL;
+    int cnt_xstats, ret, i;
+
+    printf("\n=== NIC Hardware Statistics (Port %u) ===\n", port_id);
+
+    /* Get basic ethernet statistics */
+    ret = rte_eth_stats_get(port_id, &eth_stats);
+    if (ret == 0) {
+        printf("Hardware RX Packets:     %"PRIu64"\n", eth_stats.ipackets);
+        printf("Hardware TX Packets:     %"PRIu64"\n", eth_stats.opackets);
+        printf("Hardware RX Bytes:       %"PRIu64"\n", eth_stats.ibytes);
+        printf("Hardware TX Bytes:       %"PRIu64"\n", eth_stats.obytes);
+        printf("Hardware RX Errors:      %"PRIu64"\n", eth_stats.ierrors);
+        printf("Hardware TX Errors:      %"PRIu64"\n", eth_stats.oerrors);
+        printf("Hardware RX Missed:      %"PRIu64" (packets dropped by HW)\n", eth_stats.imissed);
+        printf("Hardware RX No MBuf:     %"PRIu64" (mbuf allocation failed)\n", eth_stats.rx_nombuf);
+
+        /* Print per-queue statistics if available */
+        bool has_queue_stats = false;
+        for (i = 0; i < RTE_ETHDEV_QUEUE_STAT_CNTRS && i < 8; i++) {
+            if (eth_stats.q_ipackets[i] > 0 || eth_stats.q_opackets[i] > 0 || eth_stats.q_errors[i] > 0) {
+                if (!has_queue_stats) {
+                    printf("\nPer-Queue Statistics:\n");
+                    has_queue_stats = true;
+                }
+                printf("  Queue %d: RX=%"PRIu64", TX=%"PRIu64", Errors=%"PRIu64"\n",
+                    i, eth_stats.q_ipackets[i], eth_stats.q_opackets[i], eth_stats.q_errors[i]);
+            }
+        }
+
+        /* Calculate packet loss if any */
+        if (eth_stats.ipackets > 0) {
+            uint64_t total_drops = eth_stats.imissed + eth_stats.rx_nombuf + eth_stats.ierrors;
+            if (total_drops > 0) {
+                double drop_rate = (double)total_drops * 100.0 / (eth_stats.ipackets + total_drops);
+                printf("\nPacket Loss Analysis:\n");
+                printf("  Total Drops:           %"PRIu64"\n", total_drops);
+                printf("  Drop Rate:             %.2f%%\n", drop_rate);
+                printf("  Primary Drop Cause:    ");
+                if (eth_stats.imissed > eth_stats.rx_nombuf && eth_stats.imissed > eth_stats.ierrors) {
+                    printf("HW Ring Full (imissed)\n");
+                } else if (eth_stats.rx_nombuf > eth_stats.ierrors) {
+                    printf("No MBuf Available\n");
+                } else if (eth_stats.ierrors > 0) {
+                    printf("HW Errors\n");
+                } else {
+                    printf("Unknown\n");
+                }
+            }
+        }
+    } else {
+        printf("Failed to get basic statistics for port %u\n", port_id);
+    }
+
+    /* Get extended statistics for detailed drop analysis */
+    cnt_xstats = rte_eth_xstats_get_names(port_id, NULL, 0);
+    if (cnt_xstats > 0) {
+        xstat_names = malloc(sizeof(struct rte_eth_xstat_name) * cnt_xstats);
+        xstats = malloc(sizeof(struct rte_eth_xstat) * cnt_xstats);
+
+        if (xstat_names && xstats) {
+            ret = rte_eth_xstats_get_names(port_id, xstat_names, cnt_xstats);
+            if (ret == cnt_xstats) {
+                ret = rte_eth_xstats_get(port_id, xstats, cnt_xstats);
+                if (ret == cnt_xstats) {
+                    printf("\nDetailed Drop/Error Statistics:\n");
+                    bool found_drops = false;
+                    for (i = 0; i < cnt_xstats; i++) {
+                        const char *name = xstat_names[i].name;
+                        uint64_t value = xstats[i].value;
+
+                        /* Filter for drop/error related statistics */
+                        if (value > 0 && (strstr(name, "drop") || strstr(name, "discard") ||
+                                         strstr(name, "error") || strstr(name, "miss") ||
+                                         strstr(name, "full") || strstr(name, "overflow") ||
+                                         strstr(name, "underrun") || strstr(name, "crc") ||
+                                         strstr(name, "fragment") || strstr(name, "jabber"))) {
+                            printf("  %-30s: %"PRIu64"\n", name, value);
+                            found_drops = true;
+                        }
+                    }
+                    if (!found_drops) {
+                        printf("  No drop/error statistics found\n");
+                    }
+                }
+            }
+        }
+
+        free(xstat_names);
+        free(xstats);
+    }
+    printf("==========================================\n");
+}
+
+/**
+ * print_all_nic_hw_stats - Print NIC hardware statistics for all enabled ports
+ *
+ * DESCRIPTION
+ * Print NIC hardware statistics for all ports currently enabled in l3fwd
+ *
+ * RETURNS: N/A
+ */
+void
+print_all_nic_hw_stats(void)
+{
+    uint16_t portid;
+
+    printf("\n########################################\n");
+    printf("# NIC HARDWARE STATISTICS ANALYSIS\n");
+    printf("########################################\n");
+
+    for (portid = 0; portid < RTE_MAX_ETHPORTS; portid++) {
+        if ((enabled_port_mask & (1 << portid)) != 0) {
+            print_nic_hw_stats(portid);
+        }
+    }
+
+    printf("########################################\n");
+}
+
 static void
 signal_handler(int signum)
 {
 	if (signum == SIGINT || signum == SIGTERM) {
 		printf("\n\nSignal %d received, preparing to exit...\n",
 				signum);
+		
+		/* Print NIC hardware statistics before exit if stats are enabled */
+		if (stats_enabled) {
+			print_all_nic_hw_stats();
+		}
+		
+		/* Print PCM statistics before exit */
+		if (stats_enabled && pcm_monitoring_is_available()) {
+			printf("\n\nReceived signal %d, shutting down...\n", signum);
+			
+			printf("\n=== Intel PCM Performance Statistics ===\n");
+			
+			/* First stop PCM monitoring to capture final state */
+			pcm_monitoring_stop_all();
+			
+			/* Then measure all cores with proper before/after states */
+			pcm_monitoring_measure_all();
+			
+			/* Print comprehensive PCM statistics */
+			pcm_print_core_statistics();
+			pcm_print_memory_statistics();
+			pcm_print_io_statistics();
+			pcm_print_system_statistics();
+			
+			printf("=== End PCM Statistics ===\n");
+		}
+		
 		force_quit = true;
 	}
 }
@@ -1448,13 +1611,17 @@ l3fwd_poll_resource_setup(void)
 			else
 				socketid = 0;
 
-			printf("txq=%u,%d,%d ", lcore_id, queueid, socketid);
+			// printf("TXQ=%u,%d,%d ", lcore_id, queueid, socketid);
 			fflush(stdout);
 
 			txconf = &dev_info.default_txconf;
 			txconf->offloads = local_port_conf.txmode.offloads;
 			ret = rte_eth_tx_queue_setup(portid, queueid, nb_txd,
 						     socketid, txconf);
+			printf("txconf: tx_thresh={pthresh=%u, hthresh=%u, wthresh=%u}, "
+				"tx_rs_thresh=%u, tx_free_thresh=%u, offloads=0x%"PRIx64"\n",
+				txconf->tx_thresh.pthresh, txconf->tx_thresh.hthresh, txconf->tx_thresh.wthresh,
+				txconf->tx_rs_thresh, txconf->tx_free_thresh, txconf->offloads);
 			if (ret < 0)
 				rte_exit(EXIT_FAILURE,
 					"rte_eth_tx_queue_setup: err=%d, "
@@ -1474,7 +1641,7 @@ l3fwd_poll_resource_setup(void)
 		if (rte_lcore_is_enabled(lcore_id) == 0)
 			continue;
 		qconf = &lcore_conf[lcore_id];
-		printf("\nInitializing rx queues on lcore %u ... ", lcore_id );
+		// printf("\nInitializing rx queues on lcore %u ... ", lcore_id );
 		fflush(stdout);
 		/* init RX queues */
 		for(queue = 0; queue < qconf->n_rx_queue; ++queue) {
@@ -1490,7 +1657,7 @@ l3fwd_poll_resource_setup(void)
 			else
 				socketid = 0;
 
-			printf("rxq=%d,%d,%d ", portid, queueid, socketid);
+			// printf("rxq=%d,%d,%d ", portid, queueid, socketid);
 			fflush(stdout);
 
 			ret = rte_eth_dev_info_get(portid, &dev_info);
@@ -1635,6 +1802,14 @@ main(int argc, char **argv)
 	argc -= ret;
 	argv += ret;
 
+	/* Initialize PCM monitoring early */
+	printf("=== Initializing Intel PCM Performance Monitoring ===\n");
+	if (pcm_monitoring_init() == 0) {
+		printf("=== Intel PCM initialized successfully ===\n");
+	} else {
+		printf("=== Intel PCM initialization failed, continuing without PCM ===\n");
+	}
+
 	force_quit = false;
 	signal(SIGINT, signal_handler);
 	signal(SIGTERM, signal_handler);
@@ -1727,6 +1902,17 @@ main(int argc, char **argv)
 	check_all_ports_link_status(enabled_port_mask);
 
 	ret = 0;
+	
+	/* Start PCM monitoring on all lcores before launching main loops */
+	if (stats_enabled && pcm_monitoring_is_available()) {
+		printf("Starting PCM monitoring on all lcores...\n");
+		if (pcm_monitoring_start_all() == 0) {
+			printf("PCM monitoring started successfully\n");
+		} else {
+			printf("Failed to start PCM monitoring\n");
+		}
+	}
+	
 	/* launch per-lcore init on every lcore */
 	rte_eal_mp_remote_launch(l3fwd_lkp.main_loop, NULL, CALL_MAIN);
 
diff --git a/examples/l3fwd/meson.build b/examples/l3fwd/meson.build
index 74144c7979..b10568d0f4 100644
--- a/examples/l3fwd/meson.build
+++ b/examples/l3fwd/meson.build
@@ -7,7 +7,26 @@
 # DPDK instance, use 'make'
 
 allow_experimental_apis = true
+
+# Add C++ compiler support for PCM wrapper
+add_languages('cpp', required: true)
+
 deps += ['acl', 'hash', 'lpm', 'fib']
+
+# PCM library configuration for static linking
+pcm_base_path = meson.current_source_dir() / '..' / '..' / '..' / 'pcm'
+pcm_lib_path = pcm_base_path / 'build' / 'src'
+pcm_inc_path = pcm_base_path / 'src'
+
+# Check for PCM static library
+pcm_static_lib = pcm_lib_path / 'libpcm.a'
+pcm_found = false
+
+if fs.is_file(pcm_static_lib)
+    pcm_found = true
+    message('Found PCM static library: ' + pcm_static_lib)
+endif
+
 sources = files(
         'l3fwd_acl.c',
         'l3fwd_em.c',
@@ -16,9 +35,26 @@ sources = files(
         'l3fwd_event_generic.c',
         'l3fwd_fib.c',
         'l3fwd_lpm.c',
+        'l3fwd_pcm.c',
         'main.c',
 )
+
+# Add PCM wrapper if library found
+if pcm_found
+    sources += files('l3fwd_pcm_wrapper.cpp')
+    message('PCM integration enabled with static linking')
+endif
+
 if dpdk_conf.has('RTE_LIB_EVENTDEV')
     deps += 'eventdev'
 endif
 cflags += no_wvla_cflag
+
+# Initialize ldflags
+ldflags = []
+
+# Add PCM support if available
+if pcm_found
+    includes += include_directories('../../../pcm/src')
+    ldflags += [pcm_static_lib, '-static-libstdc++', '-static-libgcc', '-lpthread', '-ldl', '-lnuma']
+endif
